
.. _program_listing_file_include_flamegpu_runtime_DeviceAPI.cuh:

Program Listing for File DeviceAPI.cuh
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_DeviceAPI.cuh>` (``include/flamegpu/runtime/DeviceAPI.cuh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_DEVICEAPI_CUH_
   #define INCLUDE_FLAMEGPU_RUNTIME_DEVICEAPI_CUH_
   
   
   #include <cassert>
   #include <cstdint>
   #include <limits>
   
   #ifndef __CUDACC_RTC__
   #include "flamegpu/runtime/detail/curve/curve.cuh"
   #include "flamegpu/runtime/messaging_device.h"
   #else
   #include "dynamic/curve_rtc_dynamic.h"
   #endif  // !_RTC
   #include "flamegpu/runtime/utility/AgentRandom.cuh"
   #include "flamegpu/runtime/utility/DeviceEnvironment.cuh"
   #include "flamegpu/runtime/AgentFunction.cuh"
   #include "flamegpu/runtime/AgentFunctionCondition.cuh"
   #include "flamegpu/defines.h"
   
   #ifdef USE_GLM
   #ifdef __CUDACC__
   #pragma diag_suppress = esa_on_defaulted_function_ignored
   #endif
   #include <glm/glm.hpp>
   #endif
   
   namespace flamegpu {
   
   class ReadOnlyDeviceAPI {
       // Friends have access to TID() & TS_ID()
       template<typename AgentFunctionCondition>
       friend __global__ void agent_function_condition_wrapper(
   #if !defined(SEATBELTS) || SEATBELTS
           exception::DeviceExceptionBuffer *error_buffer,
   #endif
           detail::curve::Curve::NamespaceHash,
           detail::curve::Curve::NamespaceHash,
           const unsigned int,
           curandState *,
           unsigned int *);
   
    public:
       __device__ ReadOnlyDeviceAPI(
           const detail::curve::Curve::NamespaceHash &instance_id_hash,
           const detail::curve::Curve::NamespaceHash &agentfuncname_hash,
           curandState *&d_rng)
           : random(AgentRandom(&d_rng[getThreadIndex()]))
           , environment(DeviceEnvironment(instance_id_hash))
           , agent_func_name_hash(agentfuncname_hash) { }
       template<typename T, unsigned int N> __device__
       T getVariable(const char(&variable_name)[N]) const;
       template<typename T, unsigned int N, unsigned int M> __device__
       T getVariable(const char(&variable_name)[M], const unsigned int &index) const;
       __device__ id_t getID() {
           return getVariable<id_t>("_id");
       }
   
       const AgentRandom random;
       const DeviceEnvironment environment;
   
       __forceinline__ __device__ unsigned int getStepCounter() const {
           return environment.getProperty<unsigned int>("_stepCount");
       }
   
       __forceinline__ __device__ static unsigned int getThreadIndex() {
           /*
           // 3D version
           auto blockId = blockIdx.x + blockIdx.y * gridDim.x
           + gridDim.x * gridDim.y * blockIdx.z;
           auto threadId = blockId * (blockDim.x * blockDim.y * blockDim.z)
           + (threadIdx.z * (blockDim.x * blockDim.y))
           + (threadIdx.y * blockDim.x)
           + threadIdx.x;
           return threadId;*/
   #ifdef SEATBELTS
           assert(blockDim.y == 1);
           assert(blockDim.z == 1);
           assert(gridDim.y == 1);
           assert(gridDim.z == 1);
   #endif
           return blockIdx.x * blockDim.x + threadIdx.x;
       }
   
    protected:
       detail::curve::Curve::NamespaceHash agent_func_name_hash;
   };
   
   template<typename MessageIn, typename MessageOut>
   class DeviceAPI : public ReadOnlyDeviceAPI{
       // Friends have access to TID() & TS_ID()
       template<typename AgentFunction, typename _MessageIn, typename _MessageOut>
       friend __global__ void agent_function_wrapper(
   #if !defined(SEATBELTS) || SEATBELTS
           exception::DeviceExceptionBuffer *error_buffer,
   #endif
           detail::curve::Curve::NamespaceHash,
           detail::curve::Curve::NamespaceHash,
           detail::curve::Curve::NamespaceHash,
           detail::curve::Curve::NamespaceHash,
           detail::curve::Curve::NamespaceHash,
           id_t*,
           const unsigned int,
           const void *,
           const void *,
           curandState *,
           unsigned int *,
           unsigned int *,
           unsigned int *);
   
    public:
       class AgentOut {
        public:
           __device__ AgentOut(const detail::curve::Curve::NamespaceHash &aoh, id_t *&d_agent_output_nextID, unsigned int *&scan_flag_agentOutput)
               : agent_output_hash(aoh)
               , scan_flag(scan_flag_agentOutput)
               , nextID(d_agent_output_nextID) { }
           template<typename T, unsigned int N>
           __device__ void setVariable(const char(&variable_name)[N], T value) const;
           template<typename T, unsigned int N, unsigned int M>
           __device__ void setVariable(const char(&variable_name)[M], const unsigned int &index, T value) const;
           __device__ id_t getID() const;
   
        private:
           __device__ void genID() const;
           const detail::curve::Curve::NamespaceHash agent_output_hash;
           unsigned int* const scan_flag;
           mutable id_t id = ID_NOT_SET;
           id_t *nextID;
       };
       __device__ DeviceAPI(
           const detail::curve::Curve::NamespaceHash &instance_id_hash,
           const detail::curve::Curve::NamespaceHash &agentfuncname_hash,
           const detail::curve::Curve::NamespaceHash &_agent_output_hash,
           id_t *&d_agent_output_nextID,
           curandState *&d_rng,
           unsigned int *&scanFlag_agentOutput,
           typename MessageIn::In &&message_in,
           typename MessageOut::Out &&message_out)
           : ReadOnlyDeviceAPI(instance_id_hash, agentfuncname_hash, d_rng)
           , message_in(message_in)
           , message_out(message_out)
           , agent_out(AgentOut(_agent_output_hash, d_agent_output_nextID, scanFlag_agentOutput))
       { }
       template<typename T, unsigned int N>
       __device__ void setVariable(const char(&variable_name)[N], T value);
       template<typename T, unsigned int N, unsigned int M>
       __device__ void setVariable(const char(&variable_name)[M], const unsigned int &index, const T &value);
   
       const typename MessageIn::In message_in;
       const typename MessageOut::Out message_out;
       const AgentOut agent_out;
   };
   
   
   /******************************************************************************************************* Implementation ********************************************************/
   
   template<typename T, unsigned int N>
   __device__ T ReadOnlyDeviceAPI::getVariable(const char(&variable_name)[N]) const {
       // simple indexing assumes index is the thread number (this may change later)
       const unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
   
       // get the value from curve
       T value = detail::curve::Curve::getAgentVariable<T>(variable_name, agent_func_name_hash , index);
   
       // return the variable from curve
       return value;
   }
   
   template<typename MessageIn, typename MessageOut>
   template<typename T, unsigned int N>
   __device__ void DeviceAPI<MessageIn, MessageOut>::setVariable(const char(&variable_name)[N], T value) {
       if (variable_name[0] == '_') {
           return;  // Fail silently
       }
       // simple indexing assumes index is the thread number (this may change later)
       const unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
       // set the variable using curve
       detail::curve::Curve::setAgentVariable<T>(variable_name, agent_func_name_hash,  value, index);
   }
   
   template<typename T, unsigned int N, unsigned int M>
   __device__ T ReadOnlyDeviceAPI::getVariable(const char(&variable_name)[M], const unsigned int &array_index) const {
       // simple indexing assumes index is the thread number (this may change later)
       const unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
   
       // get the value from curve
       T value = detail::curve::Curve::getAgentArrayVariable<T, N>(variable_name, agent_func_name_hash , index, array_index);
   
       // return the variable from curve
       return value;
   }
   
   template<typename MessageIn, typename MessageOut>
   template<typename T, unsigned int N, unsigned int M>
   __device__ void DeviceAPI<MessageIn, MessageOut>::setVariable(const char(&variable_name)[M], const unsigned int &array_index, const T &value) {
       if (variable_name[0] == '_') {
           return;  // Fail silently
       }
       // simple indexing assumes index is the thread number (this may change later)
       const unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
   
       // set the variable using curve
       detail::curve::Curve::setAgentArrayVariable<T, N>(variable_name , agent_func_name_hash,  value, index, array_index);
   }
   
   template<typename MessageIn, typename MessageOut>
   template<typename T, unsigned int N>
   __device__ void DeviceAPI<MessageIn, MessageOut>::AgentOut::setVariable(const char(&variable_name)[N], T value) const {
       if (agent_output_hash) {
           if (variable_name[0] == '_') {
               return;  // Fail silently
           }
           if (agent_output_hash) {
               // simple indexing assumes index is the thread number (this may change later)
               const unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
   
               // set the variable using curve
               detail::curve::Curve::setNewAgentVariable<T>(variable_name, agent_output_hash, value, index);
   
               // Mark scan flag
               genID();
           }
   #if !defined(SEATBELTS) || SEATBELTS
       } else {
           DTHROW("Agent output must be enabled per agent function when defining the model.\n");
   #endif
       }
   }
   template<typename MessageIn, typename MessageOut>
   template<typename T, unsigned int N, unsigned int M>
   __device__ void DeviceAPI<MessageIn, MessageOut>::AgentOut::setVariable(const char(&variable_name)[M], const unsigned int &array_index, T value) const {
       if (agent_output_hash) {
           if (variable_name[0] == '_') {
               return;  // Fail silently
           }
           // simple indexing assumes index is the thread number (this may change later)
           const unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
   
           // set the variable using curve
           detail::curve::Curve::setNewAgentArrayVariable<T, N>(variable_name, agent_output_hash, value, index, array_index);
   
           // Mark scan flag
           genID();
   #if !defined(SEATBELTS) || SEATBELTS
       } else {
           DTHROW("Agent output must be enabled per agent function when defining the model.\n");
   #endif
       }
   }
   
   template<typename MessageIn, typename MessageOut>
   __device__ id_t DeviceAPI<MessageIn, MessageOut>::AgentOut::getID() const {
       if (agent_output_hash) {
           genID();
           return this->id;
       }
   #if !defined(SEATBELTS) || SEATBELTS
       DTHROW("Agent output must be enabled per agent function when defining the model.\n");
   #endif
       return ID_NOT_SET;
   }
   #ifdef __CUDACC__
   template<typename MessageIn, typename MessageOut>
   __device__ void DeviceAPI<MessageIn, MessageOut>::AgentOut::genID() const {
       // Only assign id and scan flag once
       if (this->id == ID_NOT_SET) {
           this->id = atomicInc(this->nextID, std::numeric_limits<id_t>().max());
           const unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
           detail::curve::Curve::setNewAgentVariable<id_t>("_id", agent_output_hash, this->id, index);  // Can't use ID_VARIABLE_NAME inline, as it isn't of char[N] type
           this->scan_flag[index] = 1;
       }
   }
   #endif
   
   }  // namespace flamegpu
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_DEVICEAPI_CUH_
