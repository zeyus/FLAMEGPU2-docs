
.. _program_listing_file_include_flamegpu_runtime_messaging_Spatial2D_Spatial2DDevice.h:

Program Listing for File Spatial2DDevice.h
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_messaging_Spatial2D_Spatial2DDevice.h>` (``include/flamegpu/runtime/messaging/Spatial2D/Spatial2DDevice.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_SPATIAL2D_SPATIAL2DDEVICE_H_
   #define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_SPATIAL2D_SPATIAL2DDEVICE_H_
   
   #include "flamegpu/runtime/messaging/Spatial2D.h"
   #include "flamegpu/runtime/messaging/BruteForce/BruteForceDevice.h"
   
   
   class MsgSpatial2D::In {
    public:
       class Filter {
        public:
           class Message {
               const Filter &_parent;
               int relative_cell = { -2 };
               int cell_index_max = 0;
               int cell_index = 0;
   
            public:
               __device__ Message(const Filter &parent, const int &relative_cell_y, const int &_cell_index_max, const int &_cell_index)
                   : _parent(parent)
                   , cell_index_max(_cell_index_max)
                   , cell_index(_cell_index) {
                   relative_cell = relative_cell_y;
               }
               __device__ Message(const Filter &parent)
                   : _parent(parent) { }
               __device__ bool operator==(const Message& rhs) const {
                   return this->relative_cell == rhs.relative_cell
                       && this->cell_index_max == rhs.cell_index_max
                       && this->cell_index == rhs.cell_index;
               }
               __device__ bool operator!=(const Message& rhs) const {
                   // The incoming Message& is end(), so we don't care about that
                   // We only care that the host object has reached end
                   // When the strip number equals 2, it has exceeded the [-1, 1] range
                   return !(this->relative_cell >= 2);
               }
               __device__ Message& operator++();
               __device__ void nextStrip() {
                   relative_cell++;
               }
               template<typename T, size_type N>
               __device__ T getVariable(const char(&variable_name)[N]) const;
           };
           class iterator {  // class iterator : public std::iterator <std::random_access_iterator_tag, void, void, void, void> {
               Message _message;
   
            public:
               __device__ iterator(const Filter &parent, const int &relative_cell_y, const int &_cell_index_max, const int &_cell_index)
                   : _message(parent, relative_cell_y, _cell_index_max, _cell_index) {
                   // Increment to find first message
                   ++_message;
               }
               __device__ iterator(const Filter &parent)
                   : _message(parent) { }
               __device__ iterator& operator++() { ++_message;  return *this; }
               __device__ iterator operator++(int) {
                   iterator temp = *this;
                   ++*this;
                   return temp;
               }
               __device__ bool operator==(const iterator& rhs) const { return  _message == rhs._message; }
               __device__ bool operator!=(const iterator& rhs) const { return  _message != rhs._message; }
               __device__ Message& operator*() { return _message; }
               __device__ Message* operator->() { return &_message; }
           };
           __device__ Filter(const MetaData *_metadata, const Curve::NamespaceHash &combined_hash, const float &x, const float &y);
           inline __device__ iterator begin(void) const {
               // Bin before initial bin, as the constructor calls increment operator
               return iterator(*this, -2, 1, 0);
           }
           inline __device__ iterator end(void) const {
               // Empty init, because this object is never used
               // iterator equality doesn't actually check the end object
               return iterator(*this);
           }
   
        private:
           float loc[2];
           GridPos2D cell;
           const MetaData *metadata;
           Curve::NamespaceHash combined_hash;
       };
       __device__ In(Curve::NamespaceHash agentfn_hash, Curve::NamespaceHash msg_hash, const void *_metadata)
           : combined_hash(agentfn_hash + msg_hash)
           , metadata(reinterpret_cast<const MetaData*>(_metadata))
       { }
        inline __device__ Filter operator() (const float &x, const float &y) const {
            return Filter(metadata, combined_hash, x, y);
        }
   
        __forceinline__ __device__ float radius() const {
            return metadata->radius;
       }
   
    private:
       Curve::NamespaceHash combined_hash;
       const MetaData *metadata;
   };
   
   class MsgSpatial2D::Out : public MsgBruteForce::Out {
    public:
       __device__ Out(Curve::NamespaceHash agentfn_hash, Curve::NamespaceHash msg_hash, const void *, unsigned int *scan_flag_messageOutput)
           : MsgBruteForce::Out(agentfn_hash, msg_hash, nullptr, scan_flag_messageOutput)
       { }
       __device__ void setLocation(const float &x, const float &y) const;
   };
   
   template<typename T, unsigned int N>
   __device__ T MsgSpatial2D::In::Filter::Message::getVariable(const char(&variable_name)[N]) const {
   #if !defined(SEATBELTS) || SEATBELTS
       // Ensure that the message is within bounds.
       if (relative_cell >= 2) {
           DTHROW("MsgSpatial2D in invalid bin, unable to get variable '%s'.\n", variable_name);
           return static_cast<T>(0);
       }
   #endif
       // get the value from curve using the stored hashes and message index.
       T value = Curve::getMessageVariable<T>(variable_name, this->_parent.combined_hash, cell_index);
       return value;
   }
   
   
   __device__ __forceinline__ MsgSpatial2D::GridPos2D getGridPosition2D(const MsgSpatial2D::MetaData *md, float x, float y) {
       // Clamp each grid coord to 0<=x<dim
       int gridPos[2] = {
           static_cast<int>(floorf(((x-md->min[0]) / md->environmentWidth[0])*md->gridDim[0])),
           static_cast<int>(floorf(((y-md->min[1]) / md->environmentWidth[1])*md->gridDim[1]))
       };
       MsgSpatial2D::GridPos2D rtn = {
           gridPos[0] < 0 ? 0 : (gridPos[0] >= static_cast<int>(md->gridDim[0]) ? static_cast<int>(md->gridDim[0]) - 1 : gridPos[0]),
           gridPos[1] < 0 ? 0 : (gridPos[1] >= static_cast<int>(md->gridDim[1]) ? static_cast<int>(md->gridDim[1]) - 1 : gridPos[1])
       };
       return rtn;
   }
   __device__ __forceinline__ unsigned int getHash2D(const MsgSpatial2D::MetaData *md, const MsgSpatial2D::GridPos2D &xyz) {
       // Bound gridPos to gridDimensions
       unsigned int gridPos[3] = {
           (unsigned int)(xyz.x < 0 ? 0 : (xyz.x >= static_cast<int>(md->gridDim[0]) - 1 ? static_cast<int>(md->gridDim[0]) - 1 : xyz.x)),  // Only x should ever be out of bounds here
           (unsigned int) xyz.y,  // xyz.y < 0 ? 0 : (xyz.y >= md->gridDim[1] - 1 ? md->gridDim[1] - 1 : xyz.y)
       };
       // Compute hash (effectivley an index for to a bin within the partitioning grid in this case)
       return (unsigned int)(
           (gridPos[1] * md->gridDim[0]) +                    // y
           gridPos[0]);                                      // x
   }
   
   __device__ inline void MsgSpatial2D::Out::setLocation(const float &x, const float &y) const {
       unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;  // + d_message_count;
   
       // set the variables using curve
       Curve::setMessageVariable<float>("x", combined_hash, x, index);
       Curve::setMessageVariable<float>("y", combined_hash, y, index);
   
       // Set scan flag incase the message is optional
       this->scan_flag[index] = 1;
   }
   
   __device__ inline MsgSpatial2D::In::Filter::Filter(const MetaData* _metadata, const Curve::NamespaceHash &_combined_hash, const float& x, const float& y)
       : metadata(_metadata)
       , combined_hash(_combined_hash) {
       loc[0] = x;
       loc[1] = y;
       cell = getGridPosition2D(_metadata, x, y);
   }
   __device__ inline MsgSpatial2D::In::Filter::Message& MsgSpatial2D::In::Filter::Message::operator++() {
       cell_index++;
       bool move_strip = cell_index >= cell_index_max;
       while (move_strip) {
           nextStrip();
           cell_index = 0;
           cell_index_max = 1;
           if (relative_cell < 2) {
               // Calculate the strips start and end hash
               int absolute_cell_y = _parent.cell.y + relative_cell;
               // Skip the strip if it is completely out of bounds
               if (absolute_cell_y >= 0 && absolute_cell_y < static_cast<int>(_parent.metadata->gridDim[1])) {
                   unsigned int start_hash = getHash2D(_parent.metadata, { _parent.cell.x - 1, absolute_cell_y });
                   unsigned int end_hash = getHash2D(_parent.metadata, { _parent.cell.x + 1, absolute_cell_y });
                   // Lookup start and end indicies from PBM
                   cell_index = _parent.metadata->PBM[start_hash];
                   cell_index_max = _parent.metadata->PBM[end_hash + 1];
               } else {
                   // Goto next strip
                   // Don't update move_strip
                   continue;
               }
           }
           move_strip = cell_index >= cell_index_max;
       }
       return *this;
   }
   
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_SPATIAL2D_SPATIAL2DDEVICE_H_
