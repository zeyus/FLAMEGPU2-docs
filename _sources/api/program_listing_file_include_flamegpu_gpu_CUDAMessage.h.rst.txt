
.. _program_listing_file_include_flamegpu_gpu_CUDAMessage.h:

Program Listing for File CUDAMessage.h
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_gpu_CUDAMessage.h>` (``include/flamegpu/gpu/CUDAMessage.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef INCLUDE_FLAMEGPU_GPU_CUDAMESSAGE_H_
   #define INCLUDE_FLAMEGPU_GPU_CUDAMESSAGE_H_
   
   #include <memory>
   #include <utility>
   #include <string>
   
   // include sub classes
   #include "flamegpu/gpu/CUDAMessageList.h"
   #include "flamegpu/runtime/messaging/BruteForce/BruteForceHost.h"
   
   // forward declare classes from other modules
   
   class CUDAScatter;
   struct AgentFunctionData;
   struct MessageData;
   class Curve;
   class MsgSpecialisationHandler;
   class CUDAAgent;
   class CUDAMessage {
    public:
       explicit CUDAMessage(const MsgBruteForce::Data& description, const CUDASimulation& cuda_model);
       virtual ~CUDAMessage(void);
       const MsgBruteForce::Data& getMessageDescription() const;
       unsigned int getMaximumListSize() const;
       unsigned int getMessageCount() const;
       void setMessageCount(const unsigned int &_message_count);
       void init(CUDAScatter &scatter, const unsigned int &streamId);
       void resize(unsigned int newSize, CUDAScatter &scatter, const unsigned int &streamId);
       void mapReadRuntimeVariables(const AgentFunctionData& func, const CUDAAgent& cuda_agent, const unsigned int &instance_id) const;
       void mapWriteRuntimeVariables(const AgentFunctionData& func, const CUDAAgent& cuda_agent, const unsigned int &writeLen, const unsigned int &instance_id) const;
       void unmapRuntimeVariables(const AgentFunctionData& func, const unsigned int &instance_id) const;
       void *getReadPtr(const std::string &var_name);
       const CUDAMsgMap &getReadList() { return message_list->getReadList(); }
       const CUDAMsgMap &getWriteList() { return message_list->getWriteList(); }
       void swap(bool isOptional, const unsigned int &newMsgCount, CUDAScatter &scatter, const unsigned int &streamId);
       void swap();
       bool getTruncateMessageListFlag() const { return truncate_messagelist_flag; }
       void setTruncateMessageListFlag() { truncate_messagelist_flag = true; }
       void clearTruncateMessageListFlag() { truncate_messagelist_flag = false; }
       bool getPBMConstructionRequiredFlag() const  { return pbm_construction_required; }
       void setPBMConstructionRequiredFlag() { pbm_construction_required = true; }
       void clearPBMConstructionRequiredFlag() { pbm_construction_required = false; }
       void buildIndex(CUDAScatter &scatter, const unsigned int &streamId, const cudaStream_t &stream);
       const void *getMetaDataDevicePtr() const;
   
    protected:
       void zeroAllMessageData();
   
    private:
       const MsgBruteForce::Data& message_description;
       std::unique_ptr<CUDAMessageList> message_list;  // CUDAMessageMap message_list;
       unsigned int message_count;
       unsigned int max_list_size;
       bool truncate_messagelist_flag;
       bool pbm_construction_required;
       std::unique_ptr<MsgSpecialisationHandler> specialisation_handler;
   
       const CUDASimulation& cuda_model;
   };
   
   #endif  // INCLUDE_FLAMEGPU_GPU_CUDAMESSAGE_H_
