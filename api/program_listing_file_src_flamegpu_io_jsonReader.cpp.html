

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Program Listing for File jsonReader.cpp &mdash; FLAME GPU 2 0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: black" >
          

          
            <a href="../index.html" class="icon icon-home"> FLAME GPU 2
          

          
            
            <img src="../_static/flamegpu2-icon-notext-128.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
<li class="toctree-l1"><a class="reference internal" href="class_view_hierarchy.html">Class Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_view_hierarchy.html">File Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="unabridged_api.html">Full API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FLAME GPU 2</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File jsonReader.cpp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/program_listing_file_src_flamegpu_io_jsonReader.cpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-jsonreader-cpp">
<span id="program-listing-file-src-flamegpu-io-jsonreader-cpp"></span><h1>Program Listing for File jsonReader.cpp<a class="headerlink" href="#program-listing-for-file-jsonreader-cpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_flamegpu_io_jsonReader.cpp.html#file-src-flamegpu-io-jsonreader-cpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/flamegpu/io/jsonReader.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#include &quot;flamegpu/io/jsonReader.h&quot;

#include &lt;rapidjson/stream.h&gt;
#include &lt;rapidjson/reader.h&gt;
#include &lt;stack&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;cerrno&gt;

#include &quot;flamegpu/exception/FGPUException.h&quot;
#include &quot;flamegpu/pop/AgentVector.h&quot;
#include &quot;flamegpu/model/AgentDescription.h&quot;
#include &quot;flamegpu/gpu/CUDASimulation.h&quot;
#include &quot;flamegpu/util/StringPair.h&quot;

jsonReader::jsonReader(
    const std::string &amp;model_name,
    const std::unordered_map&lt;std::string, EnvironmentDescription::PropData&gt; &amp;env_desc,
    std::unordered_map&lt;std::pair&lt;std::string, unsigned int&gt;, Any&gt; &amp;env_init,
    StringPairUnorderedMap&lt;std::shared_ptr&lt;AgentVector&gt;&gt; &amp;model_state,
    const std::string &amp;input,
    Simulation *sim_instance)
    : StateReader(model_name, env_desc, env_init, model_state, input, sim_instance) {}
class jsonReader_impl : public rapidjson::BaseReaderHandler&lt;rapidjson::UTF8&lt;&gt;, jsonReader_impl&gt;  {
    enum Mode{ Nop, Root, Config, Stats, SimCfg, CUDACfg, Environment, Agents, Agent, State, AgentInstance, VariableArray };
    std::stack&lt;Mode&gt; mode;
    std::string lastKey;
    std::string filename;
    const std::unordered_map&lt;std::string, EnvironmentDescription::PropData&gt; env_desc;
    std::unordered_map&lt;std::pair&lt;std::string, unsigned int&gt;, Any&gt; &amp;env_init;
    StringPairUnorderedMap&lt;std::shared_ptr&lt;AgentVector&gt;&gt;&amp;model_state;
    unsigned int current_variable_array_index = 0;
    std::string current_agent;
    std::string current_state;

 public:
    jsonReader_impl(const std::string &amp;_filename,
        const std::unordered_map&lt;std::string, EnvironmentDescription::PropData&gt; &amp;_env_desc,
        std::unordered_map&lt;std::pair&lt;std::string, unsigned int&gt;, Any&gt; &amp;_env_init,
        StringPairUnorderedMap&lt;std::shared_ptr&lt;AgentVector&gt;&gt; &amp;_model_state)
        : filename(_filename)
        , env_desc(_env_desc)
        , env_init(_env_init)
        , model_state(_model_state) { }
    template&lt;typename T&gt;
    bool processValue(const T&amp;val) {
        Mode isArray = Nop;
        if (mode.top() == VariableArray) {
            isArray = mode.top();
            mode.pop();
        }
        if (mode.top() == Environment) {
            const auto it = env_desc.find(lastKey);
            if (it == env_desc.end()) {
                THROW RapidJSONError(&quot;Input file contains unrecognised environment property &#39;%s&#39;,&quot;
                    &quot;in jsonReader::parse()\n&quot;, lastKey.c_str());
            }
            if (env_init.find(make_pair(lastKey, current_variable_array_index)) != env_init.end()) {
                THROW RapidJSONError(&quot;Input file contains environment property &#39;%s&#39; multiple times, &quot;
                    &quot;in jsonReader::parse()\n&quot;, lastKey.c_str());
            }
            const std::type_index val_type = it-&gt;second.data.type;
            if (val_type == std::type_index(typeid(float))) {
                const float t = static_cast&lt;float&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(float), val_type, 1));
            } else if (val_type == std::type_index(typeid(double))) {
                const double t = static_cast&lt;double&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(double), val_type, 1));
            } else if (val_type == std::type_index(typeid(int64_t))) {
                const int64_t t = static_cast&lt;int64_t&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(int64_t), val_type, 1));
            } else if (val_type == std::type_index(typeid(uint64_t))) {
                const uint64_t t = static_cast&lt;uint64_t&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(uint64_t), val_type, 1));
            } else if (val_type == std::type_index(typeid(int32_t))) {
                const int32_t t = static_cast&lt;int32_t&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(int32_t), val_type, 1));
            } else if (val_type == std::type_index(typeid(uint32_t))) {
                const uint32_t t = static_cast&lt;uint32_t&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(uint32_t), val_type, 1));
            } else if (val_type == std::type_index(typeid(int16_t))) {
                const int16_t t = static_cast&lt;int16_t&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(int16_t), val_type, 1));
            } else if (val_type == std::type_index(typeid(uint16_t))) {
                const uint16_t t = static_cast&lt;uint16_t&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(uint16_t), val_type, 1));
            } else if (val_type == std::type_index(typeid(int8_t))) {
                const int8_t t = static_cast&lt;int8_t&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(int8_t), val_type, 1));
            } else if (val_type == std::type_index(typeid(uint8_t))) {
                const uint8_t t = static_cast&lt;uint8_t&gt;(val);
                env_init.emplace(make_pair(lastKey, current_variable_array_index++), Any(&amp;t, sizeof(uint8_t), val_type, 1));
            } else {
                THROW RapidJSONError(&quot;Model contains environment property &#39;%s&#39; of unsupported type &#39;%s&#39;, &quot;
                    &quot;in jsonReader::parse()\n&quot;, lastKey.c_str(), val_type.name());
            }
        } else if (mode.top() == AgentInstance) {
            const std::shared_ptr&lt;AgentVector&gt; &amp;pop = model_state.at({current_agent, current_state});
            AgentVector::Agent instance = pop-&gt;back();
            const std::type_index val_type = pop-&gt;getVariableType(lastKey);
            if (val_type == std::type_index(typeid(float))) {
                instance.setVariable&lt;float&gt;(lastKey, current_variable_array_index++, static_cast&lt;float&gt;(val));
            } else if (val_type == std::type_index(typeid(double))) {
                instance.setVariable&lt;double&gt;(lastKey, current_variable_array_index++, static_cast&lt;double&gt;(val));
            } else if (val_type == std::type_index(typeid(int64_t))) {
                instance.setVariable&lt;int64_t&gt;(lastKey, current_variable_array_index++, static_cast&lt;int64_t&gt;(val));
            } else if (val_type == std::type_index(typeid(uint64_t))) {
                instance.setVariable&lt;uint64_t&gt;(lastKey, current_variable_array_index++, static_cast&lt;uint64_t&gt;(val));
            } else if (val_type == std::type_index(typeid(int32_t))) {
                instance.setVariable&lt;int32_t&gt;(lastKey, current_variable_array_index++, static_cast&lt;int32_t&gt;(val));
            } else if (val_type == std::type_index(typeid(uint32_t))) {
                instance.setVariable&lt;uint32_t&gt;(lastKey, current_variable_array_index++, static_cast&lt;uint32_t&gt;(val));
            } else if (val_type == std::type_index(typeid(int16_t))) {
                instance.setVariable&lt;int16_t&gt;(lastKey, current_variable_array_index++, static_cast&lt;int16_t&gt;(val));
            } else if (val_type == std::type_index(typeid(uint16_t))) {
                instance.setVariable&lt;uint16_t&gt;(lastKey, current_variable_array_index++, static_cast&lt;uint16_t&gt;(val));
            } else if (val_type == std::type_index(typeid(int8_t))) {
                instance.setVariable&lt;int8_t&gt;(lastKey, current_variable_array_index++, static_cast&lt;int8_t&gt;(val));
            } else if (val_type == std::type_index(typeid(uint8_t))) {
                instance.setVariable&lt;uint8_t&gt;(lastKey, current_variable_array_index++, static_cast&lt;uint8_t&gt;(val));
            } else {
                THROW RapidJSONError(&quot;Model contains environment property &#39;%s&#39; of unsupported type &#39;%s&#39;, &quot;
                    &quot;in jsonReader::parse()\n&quot;, lastKey.c_str(), val_type.name());
            }
        }  else if (mode.top() == CUDACfg || mode.top() == SimCfg || mode.top() == Stats) {
            // Not useful
            // Cfg are loaded by counter
        } else {
            THROW RapidJSONError(&quot;Unexpected value whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
        }
        if (isArray == VariableArray) {
            mode.push(isArray);
        } else {
            current_variable_array_index = 0;  // Didn&#39;t actually want to increment it above, because not in an array
        }
        return true;
    }
    bool Null() { return true; }
    bool Bool(bool b) { return processValue&lt;bool&gt;(b); }
    bool Int(int i) { return processValue&lt;int32_t&gt;(i); }
    bool Uint(unsigned u) { return processValue&lt;uint32_t&gt;(u); }
    bool Int64(int64_t i) { return processValue&lt;int64_t&gt;(i); }
    bool Uint64(uint64_t u) { return processValue&lt;uint64_t&gt;(u); }
    bool Double(double d) { return processValue&lt;double&gt;(d); }
    bool String(const char*, rapidjson::SizeType, bool) {
        // String is only possible in config, and config is not processed by this handler
        if (mode.top() == SimCfg || mode.top() == CUDACfg) {
            return true;
        }
        THROW RapidJSONError(&quot;Unexpected string whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
    }
    bool StartObject() {
        if (mode.empty()) {
            mode.push(Root);
        } else if (mode.top() == Root) {
            if (lastKey == &quot;config&quot;) {
                mode.push(Config);
            } else if (lastKey == &quot;stats&quot;) {
                mode.push(Stats);
            } else if (lastKey == &quot;environment&quot;) {
                mode.push(Environment);
            } else if (lastKey == &quot;agents&quot;) {
                mode.push(Agents);
            } else {
                THROW RapidJSONError(&quot;Unexpected object start whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
            }
        } else if (mode.top() == Config) {
            if (lastKey == &quot;simulation&quot;) {
                mode.push(SimCfg);
            } else if (lastKey == &quot;cuda&quot;) {
                mode.push(CUDACfg);
            } else {
                THROW RapidJSONError(&quot;Unexpected object start whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
            }
        } else if (mode.top() == Agents) {
            current_agent = lastKey;
            mode.push(Agent);
        } else if (mode.top() == State) {
            mode.push(AgentInstance);
            auto f = model_state.find({ current_agent, current_state });
            if (f == model_state.end()) {
                THROW RapidJSONError(&quot;Input file &#39;%s&#39; contains data for agent:state combination &#39;%s:%s&#39; not found in model description hierarchy.\n&quot;, filename.c_str());
            }
            f-&gt;second-&gt;push_back();
        } else {
            THROW RapidJSONError(&quot;Unexpected object start whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
        }
        return true;
    }
    bool Key(const char* str, rapidjson::SizeType, bool) {
        lastKey = str;
        return true;
    }
    bool EndObject(rapidjson::SizeType) {
        mode.pop();
        return true;
    }
    bool StartArray() {
        if (current_variable_array_index != 0) {
            THROW RapidJSONError(&quot;Array start when current_variable_array_index !=0, in file &#39;%s&#39;. This should never happen.\n&quot;, filename.c_str());
        }
        if (mode.top() == AgentInstance) {
            mode.push(VariableArray);
        } else if (mode.top() == Environment) {
            mode.push(VariableArray);
        } else if (mode.top() == Agent) {
            current_state = lastKey;
            mode.push(State);
        } else {
            THROW RapidJSONError(&quot;Unexpected array start whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
        }
        return true;
    }
    bool EndArray(rapidjson::SizeType) {
        if (mode.top() == VariableArray) {
            current_variable_array_index = 0;
        }
        mode.pop();
        return true;
    }
};
class jsonReader_agentsize_counter : public rapidjson::BaseReaderHandler&lt;rapidjson::UTF8&lt;&gt;, jsonReader_impl&gt;  {
    enum Mode{ Nop, Root, Config, Stats, SimCfg, CUDACfg, Environment, Agents, Agent, State, AgentInstance, VariableArray };
    std::stack&lt;Mode&gt; mode;
    std::string lastKey;
    unsigned int currentIndex = 0;
    std::string filename;
    std::string current_agent = &quot;&quot;;
    std::string current_state = &quot;&quot;;
    StringPairUnorderedMap&lt;unsigned int&gt; agentstate_counts;
    Simulation *sim_instance;
    CUDASimulation *cudamodel_instance;

 public:
     StringPairUnorderedMap&lt;unsigned int&gt; getAgentCounts() const {
        return agentstate_counts;
    }
    explicit jsonReader_agentsize_counter(const std::string &amp;_filename, Simulation *_sim_instance)
        : filename(_filename)
        , sim_instance(_sim_instance)
        , cudamodel_instance(dynamic_cast&lt;CUDASimulation*&gt;(_sim_instance)) { }

    template&lt;typename T&gt;
    bool processValue(const T&amp;val) {
        Mode isArray = Nop;
        if (mode.top() == VariableArray) {
            isArray = mode.top();
            mode.pop();
        }
        if (mode.top() == SimCfg) {
            if (sim_instance) {
                if (lastKey == &quot;random_seed&quot;) {
                    sim_instance-&gt;SimulationConfig().random_seed = static_cast&lt;unsigned int&gt;(val);
                } else if (lastKey == &quot;steps&quot;) {
                    sim_instance-&gt;SimulationConfig().steps = static_cast&lt;unsigned int&gt;(val);
                } else if (lastKey == &quot;timing&quot;) {
                    sim_instance-&gt;SimulationConfig().timing = static_cast&lt;bool&gt;(val);
                } else if (lastKey == &quot;verbose&quot;) {
                    sim_instance-&gt;SimulationConfig().verbose = static_cast&lt;bool&gt;(val);
                } else if (lastKey == &quot;console_mode&quot;) {
#ifdef VISUALISATION
                    sim_instance-&gt;SimulationConfig().console_mode = static_cast&lt;bool&gt;(val);
#else
                    if (static_cast&lt;bool&gt;(val) == false) {
                        fprintf(stderr, &quot;Warning: Cannot disable &#39;console_mode&#39; with input file &#39;%s&#39;, FLAMEGPU2 library has not been built with visualisation support enabled.\n&quot;, filename.c_str());
                    }
#endif
                } else {
                    THROW RapidJSONError(&quot;Unexpected simulation config item &#39;%s&#39; in input file &#39;%s&#39;.\n&quot;, lastKey.c_str(), filename.c_str());
                }
            }
        } else if (mode.top() == CUDACfg) {
            if (cudamodel_instance) {
                if (lastKey == &quot;device_id&quot;) {
                    cudamodel_instance-&gt;CUDAConfig().device_id = static_cast&lt;unsigned int&gt;(val);
                } else {
                    THROW RapidJSONError(&quot;Unexpected CUDA config item &#39;%s&#39; in input file &#39;%s&#39;.\n&quot;, lastKey.c_str(), filename.c_str());
                }
            }
        }  else {
            // Not useful
            // Everything else is loaded by main handler
        }
        if (isArray == VariableArray) {
            mode.push(isArray);
        }
        return true;
    }
    bool Null() { return true; }
    bool Bool(bool b) { return processValue&lt;bool&gt;(b); }
    bool Int(int i) { return processValue&lt;int32_t&gt;(i); }
    bool Uint(unsigned u) { return processValue&lt;uint32_t&gt;(u); }
    bool Int64(int64_t i) { return processValue&lt;int64_t&gt;(i); }
    bool Uint64(uint64_t u) { return processValue&lt;uint64_t&gt;(u); }
    bool Double(double d) { return processValue&lt;double&gt;(d); }
    bool String(const char*str, rapidjson::SizeType, bool) {
        if (mode.top() == SimCfg) {
            if (sim_instance) {
                if (lastKey == &quot;input_file&quot;) {
                    if (filename != str)
                        printf(&quot;Warning: Input file &#39;%s&#39; refers to second input file &#39;%s&#39;, this will not be loaded.\n&quot;, filename.c_str(), str);
                    // sim_instance-&gt;SimulationConfig().input_file = str;
                }
            }
        }
        return true;
    }
    bool StartObject() {
        if (mode.empty()) {
            mode.push(Root);
        } else if (mode.top() == Root) {
            if (lastKey == &quot;config&quot;) {
                mode.push(Config);
            } else if (lastKey == &quot;stats&quot;) {
                mode.push(Stats);
            } else if (lastKey == &quot;environment&quot;) {
                mode.push(Environment);
            } else if (lastKey == &quot;agents&quot;) {
                mode.push(Agents);
            } else {
                THROW RapidJSONError(&quot;Unexpected object start whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
            }
        } else if (mode.top() == Config) {
            if (lastKey == &quot;simulation&quot;) {
                mode.push(SimCfg);
            } else if (lastKey == &quot;cuda&quot;) {
                mode.push(CUDACfg);
            } else {
                THROW RapidJSONError(&quot;Unexpected object start whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
            }
        }  else if (mode.top() == Agents) {
            current_agent = lastKey;
            mode.push(Agent);
        } else if (mode.top() == State) {
            agentstate_counts[{current_agent, current_state}]++;
            mode.push(AgentInstance);
        } else {
            THROW RapidJSONError(&quot;Unexpected object start whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
        }
        return true;
    }
    bool Key(const char* str, rapidjson::SizeType, bool) {
        lastKey = str;
        return true;
    }
    bool EndObject(rapidjson::SizeType) {
        mode.pop();
        return true;
    }
    bool StartArray() {
        if (currentIndex != 0) {
            THROW RapidJSONError(&quot;Array start when current_variable_array_index !=0, in file &#39;%s&#39;. This should never happen.\n&quot;, filename.c_str());
        }
        if (mode.top() == AgentInstance) {
            mode.push(VariableArray);
        } else if (mode.top() == Environment) {
            mode.push(VariableArray);
        } else if (mode.top() == Agent) {
            current_state = lastKey;
            mode.push(State);
        } else {
            THROW RapidJSONError(&quot;Unexpected array start whilst parsing input file &#39;%s&#39;.\n&quot;, filename.c_str());
        }
        return true;
    }
    bool EndArray(rapidjson::SizeType) {
        if (mode.top() == VariableArray) {
            currentIndex = 0;
        }
        mode.pop();
        return true;
    }
};

int jsonReader::parse() {
    std::ifstream in(inputFile, std::ios::in | std::ios::binary);
    if (!in) {
        THROW RapidJSONError(&quot;Unable to open file &#39;%s&#39; for reading.\n&quot;, inputFile.c_str());
    }
    jsonReader_agentsize_counter agentcounter(inputFile, sim_instance);
    jsonReader_impl handler(inputFile, env_desc, env_init, model_state);
    std::string filestring = std::string((std::istreambuf_iterator&lt;char&gt;(in)), std::istreambuf_iterator&lt;char&gt;());
    rapidjson::StringStream filess(filestring.c_str());
    rapidjson::Reader reader;
    // First parse the file and simply count the size of agent list
    reader.Parse(filess, agentcounter);
    const StringPairUnorderedMap&lt;unsigned int&gt; agentCounts = agentcounter.getAgentCounts();
    // Use this to preallocate the agent statelists
    for (auto &amp;agt : agentCounts) {
        auto f = model_state.find(agt.first);
        if (f!= model_state.end())
            f-&gt;second-&gt;reserve(agt.second);
    }
    // Reset the string stream
    filess = rapidjson::StringStream(filestring.c_str());
    // Read in the file data
    reader.Parse(filess, handler);
    return 0;
}
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, University of Sheffield.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>