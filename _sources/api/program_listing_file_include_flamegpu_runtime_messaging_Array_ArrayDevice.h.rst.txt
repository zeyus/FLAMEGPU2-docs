
.. _program_listing_file_include_flamegpu_runtime_messaging_Array_ArrayDevice.h:

Program Listing for File ArrayDevice.h
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_messaging_Array_ArrayDevice.h>` (``include/flamegpu/runtime/messaging/Array/ArrayDevice.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_ARRAY_ARRAYDEVICE_H_
   #define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_ARRAY_ARRAYDEVICE_H_
   
   #include "flamegpu/runtime/messaging/Array.h"
   #include "flamegpu/runtime/messaging/BruteForce/BruteForceDevice.h"
   
   class MsgArray::In {
       friend class Message;
   
    public:
       class Message {
           const MsgArray::In &_parent;
           size_type index;
   
        public:
           __device__ Message(const MsgArray::In &parent, const size_type &_index) : _parent(parent), index(_index) {}
           __device__ bool operator==(const Message& rhs) const { return  this->index == rhs.index; }
           __device__ bool operator!=(const Message& rhs) const { return  this->index != rhs.index; }
           __device__ size_type getIndex() const { return this->index; }
           template<typename T, unsigned int N>
           __device__ T getVariable(const char(&variable_name)[N]) const;
       };
       class Filter {
           friend class Message;
   
        public:
           class Message {
               const Filter &_parent;
               int relative_cell;
               size_type index_1d = 0;
   
            public:
               __device__ Message(const Filter &parent, const int &relative_x)
                   : _parent(parent) {
                   relative_cell = relative_x;
               }
               __device__ bool operator==(const Message& rhs) const {
                   return this->index_1d == rhs.index_1d
                       && this->_parent.loc == rhs._parent.loc;
               }
               __device__ bool operator!=(const Message& rhs) const { return !(*this == rhs); }
               __device__ inline Message& operator++();
               __device__ size_type getX() const {
                   return (this->_parent.loc + relative_cell + this->_parent.length) % this->_parent.length;
               }
               template<typename T, unsigned int N>
               __device__ T getVariable(const char(&variable_name)[N]) const;
           };
           class iterator {  // public std::iterator <std::random_access_iterator_tag, void, void, void, void> {
               Message _message;
   
            public:
               __device__ iterator(const Filter &parent, const int &relative_x)
                   : _message(parent, relative_x) {
                   // Increment to find first message
                   ++_message;
               }
               __device__ iterator& operator++() { ++_message;  return *this; }
               __device__ iterator operator++(int) {
                   iterator temp = *this;
                   ++*this;
                   return temp;
               }
               __device__ bool operator==(const iterator& rhs) const { return  _message == rhs._message; }
               __device__ bool operator!=(const iterator& rhs) const { return  _message != rhs._message; }
               __device__ Message& operator*() { return _message; }
               __device__ Message* operator->() { return &_message; }
           };
           __device__ inline Filter(const size_type &_length, const Curve::NamespaceHash &_combined_hash, const size_type &x, const size_type &_radius);
           inline __device__ iterator begin(void) const {
               // Bin before initial bin, as the constructor calls increment operator
               return iterator(*this, -static_cast<int>(radius) - 1);
           }
           inline __device__ iterator end(void) const {
               // Final bin, as the constructor calls increment operator
               return iterator(*this, radius);
           }
   
        private:
           size_type loc;
           const size_type radius;
           const size_type length;
           Curve::NamespaceHash combined_hash;
       };
       __device__ In(Curve::NamespaceHash agentfn_hash, Curve::NamespaceHash msg_hash, const void *metadata)
           : combined_hash(agentfn_hash + msg_hash)
           , length(reinterpret_cast<const MetaData*>(metadata)->length)
       { }
       inline __device__ Filter operator() (const size_type &x, const size_type &radius = 1) const {
   #if !defined(SEATBELTS) || SEATBELTS
           if (radius == 0 || radius > length) {
               DTHROW("Invalid radius %llu for accessing array messaglist of length %u\n", radius, length);
           }
   #endif
           return Filter(length, combined_hash, x, radius);
       }
       __device__ size_type size(void) const {
           return length;
       }
       __device__ Message at(const size_type &index) const {
   #if !defined(SEATBELTS) || SEATBELTS
           if (index >= length) {
               DTHROW("Index is out of bounds for Array messagelist (%u >= %u).\n", index, length);
           }
   #endif
           return Message(*this, index);
       }
   
    private:
       Curve::NamespaceHash combined_hash;
       const size_type length;
   };
   class MsgArray::Out {
    public:
       __device__ Out(Curve::NamespaceHash agentfn_hash, Curve::NamespaceHash msg_hash, const void *_metadata, unsigned int *scan_flag_messageOutput)
           : combined_hash(agentfn_hash + msg_hash)
           , scan_flag(scan_flag_messageOutput)
   #if !defined(SEATBELTS) || SEATBELTS
           , metadata(reinterpret_cast<const MetaData*>(_metadata))
   #else
           , metadata(nullptr)
   #endif
       { }
       __device__ inline void setIndex(const size_type &id) const;
       template<typename T, unsigned int N>
       __device__ void setVariable(const char(&variable_name)[N], T value) const;
   
    protected:
       Curve::NamespaceHash combined_hash;
       unsigned int *scan_flag;
       const MetaData * const metadata;
   };
   
   template<typename T, unsigned int N>
   __device__ T MsgArray::In::Message::getVariable(const char(&variable_name)[N]) const {
   #if !defined(SEATBELTS) || SEATBELTS
       // Ensure that the message is within bounds.
       if (index >= this->_parent.length) {
           DTHROW("Invalid Array message, unable to get variable '%s'.\n", variable_name);
           return static_cast<T>(0);
       }
   #endif
       // get the value from curve using the stored hashes and message index.
       return Curve::getMessageVariable<T>(variable_name, this->_parent.combined_hash, index);
   }
   template<typename T, unsigned int N>
   __device__ T MsgArray::In::Filter::Message::getVariable(const char(&variable_name)[N]) const {
   #if !defined(SEATBELTS) || SEATBELTS
       // Ensure that the message is within bounds.
       if (index_1d >= this->_parent.length) {
           DTHROW("Invalid Array message, unable to get variable '%s'.\n", variable_name);
           return static_cast<T>(0);
       }
   #endif
       // get the value from curve using the stored hashes and message index.
       return Curve::getMessageVariable<T>(variable_name, this->_parent.combined_hash, index_1d);
   }
   
   template<typename T, unsigned int N>
   __device__ void MsgArray::Out::setVariable(const char(&variable_name)[N], T value) const {  // message name or variable name
       if (variable_name[0] == '_') {
           return;  // Fail silently
       }
       unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
   
       // set the variable using curve
       Curve::setMessageVariable<T>(variable_name, combined_hash, value, index);
   
       // setIndex() sets the optional msg scan flag
   }
   
   __device__ void MsgArray::Out::setIndex(const size_type &id) const {
       unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
   
   #if !defined(SEATBELTS) || SEATBELTS
       if (id >= metadata->length) {
           DTHROW("MsgArray index [%u] is out of bounds [%u]\n", id, metadata->length);
       }
   #endif
   
       // set the variable using curve
       Curve::setMessageVariable<size_type>("___INDEX", combined_hash, id, index);
   
       // Set scan flag incase the message is optional
       this->scan_flag[index] = 1;
   }
   __device__ MsgArray::In::Filter::Filter(const size_type &_length, const Curve::NamespaceHash &_combined_hash, const size_type &x, const size_type &_radius)
       : radius(_radius)
       , length(_length)
       , combined_hash(_combined_hash) {
       loc = x;
   }
   __device__ MsgArray::In::Filter::Message& MsgArray::In::Filter::Message::operator++() {
       relative_cell++;
       // Skip origin cell
       if (relative_cell == 0) {
           relative_cell++;
       }
       // Wrap over boundaries
       index_1d = (this->_parent.loc + relative_cell + this->_parent.length) % this->_parent.length;
       return *this;
   }
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_ARRAY_ARRAYDEVICE_H_
