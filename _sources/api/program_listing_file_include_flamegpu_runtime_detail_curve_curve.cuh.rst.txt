
.. _program_listing_file_include_flamegpu_runtime_detail_curve_curve.cuh:

Program Listing for File curve.cuh
==================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_detail_curve_curve.cuh>` (``include/flamegpu/runtime/detail/curve/curve.cuh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_DETAIL_CURVE_CURVE_CUH_
   #define INCLUDE_FLAMEGPU_RUNTIME_DETAIL_CURVE_CURVE_CUH_
   
   // #include <cuda_runtime.h>
   
   #include <cstring>
   #include <cstdio>
   #ifndef __CUDACC_RTC__
   #include <mutex>
   #include <shared_mutex>
   #endif
   
   #include "flamegpu/exception/FLAMEGPUDeviceException.cuh"
   
   #ifdef USE_GLM
   #ifdef __CUDACC__
   #ifdef __NVCC_DIAG_PRAGMA_SUPPORT__
   #pragma nv_diag_suppress = esa_on_defaulted_function_ignored
   #else
   #pragma diag_suppress = esa_on_defaulted_function_ignored
   #endif  // __NVCC_DIAG_PRAGMA_SUPPORT__
   #endif  // __CUDACC__
   #include <glm/glm.hpp>
   #endif  // USE_GLM
   
   namespace flamegpu {
   namespace detail {
   namespace curve {
   
   class Curve {
    public:
       static const int UNKNOWN_VARIABLE = -1;              // !< value returned as a Variable if an API function encounters an error
   
       typedef int                      Variable;           // !< Typedef for cuRVE variable handle
       typedef unsigned int             VariableHash;       // !< Typedef for cuRVE variable name string hash
       typedef unsigned int             NamespaceHash;      // !< Typedef for cuRVE variable namespace string hash
   
       __host__ static VariableHash variableRuntimeHash(const char* str);
       __host__ static VariableHash variableRuntimeHash(unsigned int num);
   
       template <unsigned int N>
       __device__ __host__ __forceinline__ static VariableHash variableHash(const char(&str)[N]);
       __host__ Variable getVariableHandle(VariableHash variable_hash);
       __host__ Variable registerVariableByHash(VariableHash variable_hash, void* d_ptr, size_t size, unsigned int length);
       template <unsigned int N, typename T>
       __host__ Variable registerVariable(const char(&variableName)[N], void* d_ptr, unsigned int length);
       __host__ int size() const;
       __host__ void updateDevice();
       __host__ void unregisterVariableByHash(VariableHash variable_hash);
       template <unsigned int N>
       __host__ void unregisterVariable(const char(&variableName)[N]);
   
       __device__ __forceinline__ static Variable getVariable(const VariableHash variable_hash);
       __device__ __forceinline__ static size_t getVariableSize(const VariableHash variable_hash);
       __device__ __forceinline__ static unsigned int getVariableLength(const VariableHash variable_hash);
       __device__ __forceinline__ static void* getVariablePtrByHash(const VariableHash variable_hash, size_t offset);
       template <typename T>
       __device__ __forceinline__ static T getVariableByHash(const VariableHash variable_hash, unsigned int index);
       template <typename T>
       __device__ __forceinline__ static T getVariableByHash_ldg(const VariableHash variable_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getArrayVariableByHash(const VariableHash variable_hash, unsigned int agent_index, unsigned int array_index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getArrayVariableByHash_ldg(const VariableHash variable_hash, unsigned int agent_index, unsigned int array_index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getMessageVariable(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getAgentVariable_ldg(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getMessageVariable_ldg(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getMessageArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getAgentArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getMessageArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T>
       __device__ __forceinline__ static void setVariableByHash(const VariableHash variable_hash, T value, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setArrayVariableByHash(const VariableHash variable_hash, T value, unsigned int agent_index, unsigned int array_index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setMessageVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setNewAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static void setAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static void setMessageArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static void setNewAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int variable_index, unsigned int array_index);
   
       static const int MAX_VARIABLES = 1024;          // !< Default maximum number of cuRVE variables (must be a power of 2)
       static const VariableHash EMPTY_FLAG = 0;
       static const VariableHash DELETED_FLAG = 1;
   
    private:
       __host__ int _size() const;
       __host__ Variable _registerVariableByHash(VariableHash variable_hash, void* d_ptr, size_t size, unsigned int length);
       __host__ void _unregisterVariableByHash(VariableHash variable_hash);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getVariable(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getVariable_ldg(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static void setArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int variable_index, unsigned int array_index);
       VariableHash h_hashes[MAX_VARIABLES];         // Host array of the hash values of registered variables
       void* h_d_variables[MAX_VARIABLES];           // Host array of pointer to device memory addresses for variable storage
       size_t h_sizes[MAX_VARIABLES];                // Host array of the sizes of registered variable types (Note: RTTI not supported in CUDA so this is the best we can do for now)
       unsigned int h_lengths[MAX_VARIABLES];        // Host array of the length of registered variables (i.e: vector length)
       bool deviceInitialised;                       // Flag indicating that curve has/hasn't been initialised yet on a device.
   
   #ifndef __CUDACC_RTC__
   
       mutable std::shared_timed_mutex mutex;
       std::shared_lock<std::shared_timed_mutex> getSharedLock() const { return std::shared_lock<std::shared_timed_mutex>(mutex); }
       std::unique_lock<std::shared_timed_mutex> getUniqueLock() const { return std::unique_lock<std::shared_timed_mutex>(mutex); }
   #endif
   
       void initialiseDevice();
       friend class flamegpu::CUDASimulation;
       __host__ void purge();
   
    protected:
       Curve();
   
    public:
   #ifndef __CUDACC_RTC__
   
       static Curve& getInstance();
       static std::mutex instance_mutex;
   #endif
   };
   
   
   namespace detail {
       extern __constant__ Curve::VariableHash d_hashes[Curve::MAX_VARIABLES];   // Device array of the hash values of registered variables
       extern __device__ char* d_variables[Curve::MAX_VARIABLES];                // Device array of pointer to device memory addresses for variable storage
       extern __constant__ size_t d_sizes[Curve::MAX_VARIABLES];                // Device array of the types of registered variables
       extern __constant__ unsigned int d_lengths[Curve::MAX_VARIABLES];
   }  // namespace detail
   
   
   /* TEMPLATE HASHING FUNCTIONS */
   
   template <unsigned int N, unsigned int I> struct CurveStringHash {
       __device__ __host__ inline static Curve::VariableHash Hash(const char (&str)[N]) {
           return (CurveStringHash<N, I-1>::Hash(str) ^ str[I-1])*16777619u;
       }
   };
   template <unsigned int N> struct CurveStringHash<N, 1> {
       __device__ __host__ inline static Curve::VariableHash Hash(const char (&str)[N]) {
           return (2166136261u ^ str[0])*16777619u;
       }
   };
   
   #ifndef __CUDACC_RTC__
   
   template <unsigned int N, typename T>
   __host__ Curve::Variable Curve::registerVariable(const char(&variableName)[N], void* d_ptr, unsigned int length) {
       auto lock = std::unique_lock<std::shared_timed_mutex>(mutex);
       VariableHash variable_hash = variableHash(variableName);
       size_t size = sizeof(T);
       return _registerVariableByHash(variable_hash, d_ptr, size, length);  // the const func can get const and non const argument (for 3rd argument)
   }
   template <unsigned int N>
   __host__ void Curve::unregisterVariable(const char(&variableName)[N]) {
       auto lock = std::unique_lock<std::shared_timed_mutex>(mutex);
       VariableHash variable_hash = variableHash(variableName);
       _unregisterVariableByHash(variable_hash);
   }
   #endif
   
   /* loop unrolling of hash collision detection */
   __device__ __forceinline__ Curve::Variable Curve::getVariable(const VariableHash variable_hash) {
       for (unsigned int x = 0; x< MAX_VARIABLES; x++) {
           const Variable i = ((variable_hash + x) & (MAX_VARIABLES - 1));
           const VariableHash h = curve::detail::d_hashes[i];
           if (h == variable_hash)
               return i;
       }
       return UNKNOWN_VARIABLE;
   }
   
   
   template <unsigned int N>
   __device__ __host__ __forceinline__ Curve::VariableHash Curve::variableHash(const char(&str)[N]) {
       return CurveStringHash<N, N>::Hash(str);
   }
   __device__ __forceinline__ size_t Curve::getVariableSize(const VariableHash variable_hash) {
       Variable cv;
   
       cv = getVariable(variable_hash);
   
       return curve::detail::d_sizes[cv];
   }
   __device__ __forceinline__ unsigned int Curve::getVariableLength(const VariableHash variable_hash) {
       Variable cv;
   
       cv = getVariable(variable_hash);
   
       return curve::detail::d_lengths[cv];
   }
   __device__ __forceinline__ void* Curve::getVariablePtrByHash(const VariableHash variable_hash, size_t offset) {
       Variable cv;
   
       cv = getVariable(variable_hash);
   #if !defined(SEATBELTS) || SEATBELTS
       // error checking
       if (cv == UNKNOWN_VARIABLE) {
           return nullptr;
       }
   
       // check vector length
       if (offset > curve::detail::d_sizes[cv] * curve::detail::d_lengths[cv]) {  // Note : offset is basicly index * sizeof(T)
           return nullptr;
       }
   #endif
       // return a generic pointer to variable address for given offset (no bounds checking here!)
       return curve::detail::d_variables[cv] + offset;
   }
   template <typename T>
   __device__ __forceinline__ T Curve::getVariableByHash(const VariableHash variable_hash, unsigned int index) {
       size_t offset = index *sizeof(T);
   
   #if !defined(SEATBELTS) || SEATBELTS
       // do a check on the size as otherwise the value_ptr may eb out of bounds.
       size_t size = getVariableSize(variable_hash);
   
       // error checking
       if (size != sizeof(T)) {
           return {};
       }
   #endif
       // get a pointer to the specific variable by offsetting by the provided index
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
   
   #if !defined(SEATBELTS) || SEATBELTS
       if (!value_ptr)
           return {};
   #endif
       return *value_ptr;
   }
   template <typename T>
   __device__ __forceinline__ T Curve::getVariableByHash_ldg(const VariableHash variable_hash, unsigned int index) {
       size_t offset = index *sizeof(T);
   
   #if !defined(SEATBELTS) || SEATBELTS
       // do a check on the size as otherwise the value_ptr may eb out of bounds.
       size_t size = getVariableSize(variable_hash);
   
       // error checking
       if (size != sizeof(T)) {
           return {};
       }
   #endif
       // get a pointer to the specific variable by offsetting by the provided index
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
   
   #if !defined(SEATBELTS) || SEATBELTS
       if (!value_ptr)
           return {};
   #endif
       return __ldg(value_ptr);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getArrayVariableByHash(const VariableHash variable_hash, unsigned int agent_index, unsigned int array_index) {
       // do a check on the size as otherwise the value_ptr may eb out of bounds.
       const size_t var_size = N * sizeof(T);
       // error checking
   #if !defined(SEATBELTS) || SEATBELTS
       const size_t size = getVariableSize(variable_hash);
       if (size != var_size) {
           return NULL;
       }
   #endif
       const size_t offset = (agent_index * var_size) + (array_index * sizeof(T));
       // get a pointer to the specific variable by offsetting by the provided index
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
   
   #if !defined(SEATBELTS) || SEATBELTS
       if (!value_ptr)
           return 0;
   #endif
       return *value_ptr;
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getArrayVariableByHash_ldg(const VariableHash variable_hash, unsigned int agent_index, unsigned int array_index) {
       // do a check on the size as otherwise the value_ptr may eb out of bounds.
       const size_t var_size = N * sizeof(T);
       // error checking
   #if !defined(SEATBELTS) || SEATBELTS
       const size_t size = getVariableSize(variable_hash);
       if (size != var_size) {
           return NULL;
       }
   #endif
       const size_t offset = (agent_index * var_size) + (array_index * sizeof(T));
       // get a pointer to the specific variable by offsetting by the provided index
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
   
   #if !defined(SEATBELTS) || SEATBELTS
       if (!value_ptr)
           return 0;
   #endif
       return __ldg(value_ptr);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getAgentVariable(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       return getVariable<T>(variableName, namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getMessageVariable(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       return getVariable<T>(variableName, namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getVariable(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable with name '%s' was not found.\n", variableName);
               return {};
           } else if (curve::detail::d_sizes[cv] != sizeof(T)) {
               DTHROW("Curve variable with name '%s' type size mismatch %llu != %llu.\n", variableName, curve::detail::d_sizes[cv], sizeof(T));
               return {};
           }
       }
   #endif
       return getVariableByHash<T>(variable_hash+namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getAgentVariable_ldg(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       return getVariable_ldg<T>(variableName, namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getMessageVariable_ldg(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       return getVariable_ldg<T>(variableName, namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getVariable_ldg(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable with name '%s' was not found.\n", variableName);
               return {};
           } else if (curve::detail::d_sizes[cv] != sizeof(T)) {
               DTHROW("Curve variable with name '%s' type size mismatch %llu != %llu.\n", variableName, curve::detail::d_sizes[cv], sizeof(T));
               return {};
           }
       }
   #endif
   #if !defined(USE_GLM)
       return getVariableByHash_ldg<T>(variable_hash+namespace_hash, index);
   #else
       // Some/All glm types (e.g. uvec3) cannot be loaded over _ldg
       return getVariableByHash<T>(variable_hash + namespace_hash, index);
   #endif
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int agent_index, unsigned int array_index) {
       return getArrayVariable<T, N>(variableName, namespace_hash, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getMessageArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int message_index, unsigned int array_index) {
       return getArrayVariable<T, N>(variableName, namespace_hash, message_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int agent_index, unsigned int array_index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable array with name '%s' was not found.\n", variableName);
               return {};
           } else if (curve::detail::d_sizes[cv] != sizeof(T) * N) {
               DTHROW("Curve variable array with name '%s', type size mismatch %llu != %llu.\n", variableName, curve::detail::d_sizes[cv], sizeof(T) * N);
               return {};
           }
       }
       if (array_index >= N) {
           DTHROW("Curve array index %u is out of bounds for variable with name '%s'.\n", array_index, variableName);
           return {};
       }
   #endif
       // Curve currently doesn't store whether a variable is an array
       // Curve stores M * sizeof(T), so this is checked instead
       return getArrayVariableByHash<T, N>(variable_hash + namespace_hash, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getAgentArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int agent_index, unsigned int array_index) {
       return getArrayVariable_ldg<T, N>(variableName, namespace_hash, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getMessageArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int message_index, unsigned int array_index) {
       return getArrayVariable_ldg<T, N>(variableName, namespace_hash, message_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int agent_index, unsigned int array_index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable array with name '%s' was not found.\n", variableName);
               return {};
           } else if (curve::detail::d_sizes[cv] != sizeof(T) * N) {
               DTHROW("Curve variable array with name '%s', type size mismatch %llu != %llu.\n", variableName, curve::detail::d_sizes[cv], sizeof(T) * N);
               return {};
           }
       }
       if (array_index >= N) {
           DTHROW("Curve array index %u is out of bounds for variable with name '%s'.\n", array_index, variableName);
           return {};
       }
   #endif
       // Curve currently doesn't store whether a variable is an array
       // Curve stores M * sizeof(T), so this is checked instead
   #if !defined(USE_GLM)
       return getArrayVariableByHash_ldg<T, N>(variable_hash + namespace_hash, agent_index, array_index);
   #else
       // Some/All glm types (e.g. uvec3) cannot be loaded over _ldg
       return getArrayVariableByHash<T, N>(variable_hash + namespace_hash, agent_index, array_index);
   #endif
   }
   
   template <typename T>
   __device__ __forceinline__ void Curve::setVariableByHash(const VariableHash variable_hash, T variable, unsigned int index) {
   #if !defined(SEATBELTS) || SEATBELTS
       size_t size = getVariableSize(variable_hash);
       if (size != sizeof(T)) {
           return;
       }
   #endif
       size_t offset = index *sizeof(T);
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
       *value_ptr = variable;
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setArrayVariableByHash(const VariableHash variable_hash, T variable, unsigned int agent_index, unsigned int array_index) {
       const size_t var_size = N * sizeof(T);
   #if !defined(SEATBELTS) || SEATBELTS
       const size_t size = getVariableSize(variable_hash);
       if (size != var_size) {
           return;
       }
   #endif
       const size_t offset = (agent_index * var_size) + (array_index * sizeof(T));
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
       *value_ptr = variable;
   }
   
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index) {
       setVariable<T>(variableName, namespace_hash, variable, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setMessageVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index) {
       setVariable<T>(variableName, namespace_hash, variable, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setNewAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index) {
       setVariable<T>(variableName, namespace_hash, variable, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable with name '%s' was not found.\n", variableName);
               return;
           } else if (curve::detail::d_sizes[cv] != sizeof(T)) {
               DTHROW("Curve variable with name '%s', type size mismatch %llu != %llu.\n", variableName, curve::detail::d_sizes[cv], sizeof(T));
               return;
           }
       }
   #endif
       setVariableByHash<T>(variable_hash+namespace_hash, variable, index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ void Curve::setAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int agent_index, unsigned int array_index) {
       setArrayVariable<T, N>(variableName, namespace_hash, variable, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ void Curve::setMessageArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int message_index, unsigned int array_index) {
       setArrayVariable<T, N>(variableName, namespace_hash, variable, message_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ void Curve::setNewAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int agent_index, unsigned int array_index) {
       setArrayVariable<T, N>(variableName, namespace_hash, variable, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ void Curve::setArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int agent_index, unsigned int array_index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable array with name '%s' was not found.\n", variableName);
               return;
           } else if (curve::detail::d_sizes[cv] != sizeof(T) * N) {
               DTHROW("Curve variable array with name '%s', size mismatch %llu != %llu.\n", variableName, curve::detail::d_sizes[cv], sizeof(T) * N);
               return;
           }
       }
       if (array_index >= N) {
           DTHROW("Curve array index %u is out of bounds for variable with name '%s'.\n", array_index, variableName);
           return;
       }
   #endif
       // Curve currently doesn't store whether a variable is an array
       // Curve stores M * sizeof(T), so this is checked instead
       setArrayVariableByHash<T, N>(variable_hash + namespace_hash, variable, agent_index, array_index);
   }
   
   }  // namespace curve
   }  // namespace detail
   }  // namespace flamegpu
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_DETAIL_CURVE_CURVE_CUH_
