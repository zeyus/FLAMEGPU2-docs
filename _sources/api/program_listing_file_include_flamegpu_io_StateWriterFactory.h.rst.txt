
.. _program_listing_file_include_flamegpu_io_StateWriterFactory.h:

Program Listing for File StateWriterFactory.h
=============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_io_StateWriterFactory.h>` (``include/flamegpu/io/StateWriterFactory.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_IO_STATEWRITERFACTORY_H_
   #define INCLUDE_FLAMEGPU_IO_STATEWRITERFACTORY_H_
   
   #include <memory>
   #include <string>
   #include <unordered_map>
   #include <utility>
   #include <algorithm>
   
   #include "flamegpu/io/StateWriter.h"
   #include "flamegpu/io/XMLStateWriter.h"
   #include "flamegpu/io/JSONStateWriter.h"
   #include "flamegpu/io/JSONLogger.h"
   #include "flamegpu/io/XMLLogger.h"
   #include "flamegpu/util/StringPair.h"
   #include "flamegpu/util/detail/filesystem.h"
   
   namespace flamegpu {
   
   class AgentVector;
   
   namespace io {
   
   class StateWriterFactory {
    public:
       static StateWriter* createWriter(
           const std::string& model_name,
           const unsigned int& sim_instance_id,
           const util::StringPairUnorderedMap<std::shared_ptr<AgentVector>>& model_state,
           const unsigned int& iterations,
           const std::string& output_file,
           const Simulation* sim_instance) {
           const std::string extension = util::detail::filesystem::getFileExt(output_file);
   
           if (extension == "xml") {
               return new XMLStateWriter(model_name, sim_instance_id, model_state, iterations, output_file, sim_instance);
           } else if (extension == "json") {
               return new JSONStateWriter(model_name, sim_instance_id, model_state, iterations, output_file, sim_instance);
           }
           THROW exception::UnsupportedFileType("File '%s' is not a type which can be written "
               "by StateWriterFactory::createWriter().",
               output_file.c_str());
       }
       static std::string detectSupportedFileExt(const std::string &user_file_ext) {
           std::string rtn = user_file_ext;
           // Move entire string to lower case
           std::transform(rtn.begin(), rtn.end(), rtn.begin(), [](unsigned char c) { return std::use_facet< std::ctype<char>>(std::locale()).tolower(c); });
           // Strip first character if it is '.'
           if (rtn[0] == '.')
             rtn = rtn.substr(1);
           // Compare against supported formats
           if (rtn == "xml" ||
               rtn == "json") {
               return rtn;
           }
           return "";
       }
   };
   }  // namespace io
   }  // namespace flamegpu
   
   #endif  // INCLUDE_FLAMEGPU_IO_STATEWRITERFACTORY_H_
