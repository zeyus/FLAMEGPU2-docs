
.. _program_listing_file_include_flamegpu_runtime_messaging_BruteForce_BruteForceHost.h:

Program Listing for File BruteForceHost.h
=========================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_messaging_BruteForce_BruteForceHost.h>` (``include/flamegpu/runtime/messaging/BruteForce/BruteForceHost.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_BRUTEFORCE_BRUTEFORCEHOST_H_
   #define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_BRUTEFORCE_BRUTEFORCEHOST_H_
   
   // TODO: This should *not* be required in a .h file. Need to separate concerns between c++ and CUDA.
   #include <device_launch_parameters.h>
   
   #include <typeindex>
   #include <memory>
   #include <unordered_map>
   #include <string>
   
   #include "flamegpu/model/Variable.h"
   #include "flamegpu/gpu/CUDAErrorChecking.h"
   #include "flamegpu/gpu/CUDAScanCompaction.h"
   #include "flamegpu/util/nvtx.h"
   #include "flamegpu/runtime/cuRVE/curve.h"
   
   #include "flamegpu/runtime/messaging/None/NoneHost.h"
   #include "flamegpu/runtime/messaging/BruteForce.h"
   
   
   class MsgBruteForce::CUDAModelHandler : public MsgSpecialisationHandler {
    public:
       explicit CUDAModelHandler(CUDAMessage &a)
           : MsgSpecialisationHandler()
           , d_metadata(nullptr)
           , sim_message(a) { }
   
       ~CUDAModelHandler() { }
       void init(CUDAScatter &scatter, const unsigned int &streamId) override;
       void buildIndex(CUDAScatter &scatter, const unsigned int &streamId, const cudaStream_t &stream) override;
       void allocateMetaDataDevicePtr() override;
       void freeMetaDataDevicePtr() override;
       const void *getMetaDataDevicePtr() const override { return d_metadata; }
   
    private:
       MetaData hd_metadata;
       MetaData *d_metadata;
       CUDAMessage &sim_message;
   };
   
   struct MsgBruteForce::Data {
       friend class ModelDescription;
       friend struct ModelData;
   
       virtual ~Data();
   
       VariableMap variables;
       std::unique_ptr<Description> description;
       std::string name;
       unsigned int optional_outputs;
       bool operator==(const Data& rhs) const;
       bool operator!=(const Data& rhs) const;
       Data(const Data &other) = delete;
   
       virtual std::unique_ptr<MsgSpecialisationHandler> getSpecialisationHander(CUDAMessage &owner) const;
   
       virtual std::type_index getType() const;
   
    protected:
       virtual Data *clone(const std::shared_ptr<const ModelData> &newParent);
       Data(const std::shared_ptr<const ModelData> &, const Data &other);
       Data(const std::shared_ptr<const ModelData> &, const std::string &message_name);
   };
   
   class MsgBruteForce::Description {
       friend struct Data;
       friend class AgentFunctionDescription;
       // friend void AgentFunctionDescription::setMessageOutput(MsgBruteForce::Description&);
       // friend void AgentFunctionDescription::setMessageInput(MsgBruteForce::Description&);
   
    protected:
       Description(const std::shared_ptr<const ModelData> &_model, Data *const data);
       Description(const Description &other_message) = delete;
       Description(Description &&other_message) noexcept = delete;
       Description& operator=(const Description &other_message) = delete;
       Description& operator=(Description &&other_message) noexcept = delete;
   
    public:
       bool operator==(const Description& rhs) const;
       bool operator!=(const Description& rhs) const;
   
       template<typename T>
       void newVariable(const std::string &variable_name);
   
       std::string getName() const;
       const std::type_index& getVariableType(const std::string &variable_name) const;
       size_t getVariableSize(const std::string &variable_name) const;
       size_type getVariablesCount() const;
       bool hasVariable(const std::string &variable_name) const;
   
    protected:
       const std::weak_ptr<const ModelData> model;
       Data *const message;
   };
   template<typename T>
   void MsgBruteForce::Description::newVariable(const std::string &variable_name) {
       if (!variable_name.empty() && variable_name[0] == '_') {
           THROW ReservedName("Message variable names cannot begin with '_', this is reserved for internal usage, "
               "in MsgBruteForce::Description::newVariable().");
       }
       if (message->variables.find(variable_name) == message->variables.end()) {
           message->variables.emplace(variable_name, Variable(1, T()));
           return;
       }
       THROW InvalidMessageVar("Message ('%s') already contains variable '%s', "
           "in MessageDescription::newVariable().",
           message->name.c_str(), variable_name.c_str());
   }
   
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_BRUTEFORCE_BRUTEFORCEHOST_H_
