

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Program Listing for File FGPUDeviceException.cu &mdash; FLAME GPU 2 0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: black" >
          

          
            <a href="../index.html" class="icon icon-home"> FLAME GPU 2
          

          
            
            <img src="../_static/flamegpu2-icon-notext-128.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
<li class="toctree-l1"><a class="reference internal" href="class_view_hierarchy.html">Class Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_view_hierarchy.html">File Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="unabridged_api.html">Full API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FLAME GPU 2</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File FGPUDeviceException.cu</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/program_listing_file_src_flamegpu_exception_FGPUDeviceException.cu.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="program-listing-for-file-fgpudeviceexception-cu">
<span id="program-listing-file-src-flamegpu-exception-fgpudeviceexception-cu"></span><h1>Program Listing for File FGPUDeviceException.cu<a class="headerlink" href="#program-listing-for-file-fgpudeviceexception-cu" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_flamegpu_exception_FGPUDeviceException.cu.html#file-src-flamegpu-exception-fgpudeviceexception-cu"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/flamegpu/exception/FGPUDeviceException.cu</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>// This define forces the header to include the DeviceException::subformat() template specialisation for const char *
// It needs to be in the header so that RTC can also use it
#define FGPUDEVICEEXCEPTION_CU
#include &quot;flamegpu/exception/FGPUDeviceException.h&quot;

#include &quot;flamegpu/gpu/CUDAErrorChecking.h&quot;
#if !defined(SEATBELTS) || SEATBELTS

DeviceExceptionManager::DeviceExceptionManager()
    : d_buffer()
    , hd_buffer() {
    memset (&amp;d_buffer, 0, sizeof(d_buffer));
    memset (&amp;hd_buffer, 0, sizeof(hd_buffer));
}
DeviceExceptionManager::~DeviceExceptionManager() {
    for (auto &amp;i : d_buffer) {
        gpuErrchk(cudaFree(i));
    }
}
DeviceExceptionBuffer *DeviceExceptionManager::getDevicePtr(const unsigned int &amp;streamId, const cudaStream_t &amp;stream) {
    if (streamId &gt;= CUDAScanCompaction::MAX_STREAMS) {
        THROW OutOfBoundsException(&quot;Stream id %u is out of bounds, %u &gt;= %u, &quot;
        &quot;in FGPUDeviceException::getDevicePtr()\n&quot;, streamId, streamId, CUDAScanCompaction::MAX_STREAMS);
    }
    // It may be better to move this (and the memsets) out to a separate up-front reset call in the future.
    if (!d_buffer[streamId]) {
        gpuErrchk(cudaMalloc(&amp;d_buffer[streamId], sizeof(DeviceExceptionBuffer)));
    }
    // @todo - We might need a sync here in some cases? Tests all pass without it.
    // gpuErrchk(cudaDeviceSynchronize());

    // Memset and return buffer
    gpuErrchk(cudaMemsetAsync(d_buffer[streamId], 0, sizeof(DeviceExceptionBuffer), stream));
    memset(&amp;hd_buffer[streamId], 0, sizeof(DeviceExceptionBuffer));
    return d_buffer[streamId];
}
void DeviceExceptionManager::checkError(const std::string &amp;function, const unsigned int &amp;streamId, const cudaStream_t &amp;stream) {
    if (streamId &gt;= CUDAScanCompaction::MAX_STREAMS) {
        THROW OutOfBoundsException(&quot;Stream id %u is out of bounds, %u &gt;= %u, &quot;
        &quot;in FGPUDeviceException::checkError()\n&quot;, streamId, streamId, CUDAScanCompaction::MAX_STREAMS);
    }
    if (d_buffer[streamId]) {
        // Grab buffer from device
        gpuErrchk(cudaMemcpyAsync(&amp;hd_buffer[streamId], d_buffer[streamId], sizeof(DeviceExceptionBuffer), cudaMemcpyDeviceToHost, stream));
        gpuErrchk(cudaStreamSynchronize(stream));
        // If there is a reported error count
        if (hd_buffer[streamId].error_count) {
            std::string location_string = getLocationString(hd_buffer[streamId]);
            std::string error_string = getErrorString(hd_buffer[streamId]);
            throw DeviceError(
            &quot;Device function &#39;%s&#39; reported %u errors.\nFirst error:\n%s:\n%s&quot;,
            function.c_str(), hd_buffer[streamId].error_count, location_string.c_str(), error_string.c_str());
        }
    } else {
        THROW OutOfBoundsException(&quot;FGPUDeviceExceptionBuffer for stream %u has not been allocated, &quot;
        &quot;in FGPUDeviceException::checkError()\n&quot;, streamId, streamId, CUDAScanCompaction::MAX_STREAMS);
    }
}
std::string DeviceExceptionManager::getLocationString(const DeviceExceptionBuffer &amp;b) {
    char buff[DeviceExceptionBuffer::OUT_STRING_LEN];
    snprintf(buff, DeviceExceptionBuffer::OUT_STRING_LEN, &quot;%s(%u)[%u,%u,%u][%u,%u,%u]&quot;,
        b.file_path, b.line_no,
        b.block_id[0], b.block_id[1], b.block_id[2],
        b.thread_id[0], b.thread_id[1], b.thread_id[2]);
    return buff;
}
std::string DeviceExceptionManager::getErrorString(const DeviceExceptionBuffer &amp;b) {
    char temp_buffer[DeviceExceptionBuffer::FORMAT_BUFF_LEN];
    char out_buffer[DeviceExceptionBuffer::OUT_STRING_LEN];
    memset(out_buffer, 0, DeviceExceptionBuffer::FORMAT_BUFF_LEN);
    // Progress through b.format_string
    unsigned int format_buffer_index = 0;
    // Progress through out_buffer
    unsigned int out_index = 0;
    // Progress through b.format_args_sizes
    unsigned int arg_no = 0;
    // Progress through b.format_args
    unsigned int arg_offset = 0;
    // Whilst there is still work to be done, we are still in range of format string and all other structures used
    while (b.format_string[format_buffer_index] != &#39;\0&#39; &amp;&amp;
           format_buffer_index &lt; DeviceExceptionBuffer::FORMAT_BUFF_LEN &amp;&amp;
           out_index &lt; DeviceExceptionBuffer::FORMAT_BUFF_LEN &amp;&amp;
           arg_no &lt; DeviceExceptionBuffer::MAX_ARGS) {
        // If we find the start of a sub format string
        if (b.format_string[format_buffer_index] == &#39;%&#39;) {
            // Find the next sub format start, or end of entire format string
            unsigned int format_end = format_buffer_index + 1;
            char format_type = &#39;\0&#39;;
            while (b.format_string[format_end] != &#39;%&#39; &amp;&amp;
                  b.format_string[format_end] != &#39;\0&#39; &amp;&amp;
                  format_end &lt; DeviceExceptionBuffer::FORMAT_BUFF_LEN) {
                // Detect the format type, we will use this later
                if (format_type == &#39;\0&#39;) {
                    switch (b.format_string[format_end]) {
                        // This is every format specifier supported by the printf family of functions
                        case &#39;d&#39;:
                        case &#39;i&#39;:
                        case &#39;u&#39;:
                        case &#39;o&#39;:
                        case &#39;x&#39;:
                        case &#39;X&#39;:
                        case &#39;f&#39;:
                        case &#39;e&#39;:
                        case &#39;g&#39;:
                        case &#39;G&#39;:
                        case &#39;a&#39;:
                        case &#39;A&#39;:
                        case &#39;c&#39;:
                        case &#39;s&#39;:
                        case &#39;p&#39;:
                        case &#39;n&#39;:
                            format_type = b.format_string[format_end];
                            break;
                    }
                }
                ++format_end;
            }
            // Sub format string bounds have been found
            // Copy the sub format string into a temporary buffer
            memset(temp_buffer, 0, DeviceExceptionBuffer::FORMAT_BUFF_LEN);
            memcpy(temp_buffer, b.format_string + format_buffer_index, format_end - format_buffer_index);
            // Now send this substring to the formatter to process
            // Cast it to the correct type first
            // (This assumes snprintf never returns negative)
            switch (format_type) {
                case &#39;d&#39;:
                case &#39;i&#39;: {
                    // Signed integer
                    if (b.format_args_sizes[arg_no] == 4) {
                        out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, *reinterpret_cast&lt;const int32_t*&gt;(b.format_args+arg_offset));
                    } else {
                        out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, *reinterpret_cast&lt;const int64_t*&gt;(b.format_args+arg_offset));
                    }
                    break;
                }
                case &#39;u&#39;:
                case &#39;o&#39;:
                case &#39;x&#39;:
                case &#39;X&#39;: {
                    // Unsigned integer
                    if (b.format_args_sizes[arg_no] == 4) {
                        out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, *reinterpret_cast&lt;const uint32_t*&gt;(b.format_args+arg_offset));
                    } else {
                        out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, *reinterpret_cast&lt;const uint64_t*&gt;(b.format_args+arg_offset));
                    }
                    break;
                }
                case &#39;f&#39;:
                case &#39;e&#39;:
                case &#39;g&#39;:
                case &#39;G&#39;:
                case &#39;a&#39;:
                case &#39;A&#39;: {
                    // Floating point
                    if (b.format_args_sizes[arg_no] == 4) {
                        out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, *reinterpret_cast&lt;const float*&gt;(b.format_args+arg_offset));
                    } else {
                        out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, *reinterpret_cast&lt;const double*&gt;(b.format_args+arg_offset));
                    }
                    break;
                }
                case &#39;c&#39;: {
                    // Char
                    out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, *reinterpret_cast&lt;const char*&gt;(b.format_args+arg_offset));
                    break;
                }
                case &#39;s&#39;: {
                    // Char string
                    out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, reinterpret_cast&lt;const char*&gt;(b.format_args+arg_offset));
                    break;
                }
                case &#39;p&#39;: {
                    // Pointer
                    out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, reinterpret_cast&lt;const void*&gt;(b.format_args+arg_offset));
                    break;
                }
                case &#39;n&#39;: {
                    // No of chars written (signed pointer to have value written back to)
                    if (b.format_args_sizes[arg_no] == 4) {
                        out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, reinterpret_cast&lt;const int32_t*&gt;(b.format_args+arg_offset));
                    } else {
                        out_index += snprintf(out_buffer + out_index, DeviceExceptionBuffer::OUT_STRING_LEN - out_index, temp_buffer, reinterpret_cast&lt;const int64_t*&gt;(b.format_args+arg_offset));
                    }
                    break;
                }
            }
            // Update arg counters
            arg_offset += b.format_args_sizes[arg_no];
            ++arg_no;
            // Update pointer into main format string and continue loop
            format_buffer_index = format_end;
        } else {
            // Copy the single char
            // This will only happen until we hit first sub format string
            out_buffer[out_index] = b.format_string[format_buffer_index];
            ++out_index;
            ++format_buffer_index;
        }
    }
    return out_buffer;
}

#endif  // SEATBELTS are off
</pre></div>
</div>
</section>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, University of Sheffield.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>