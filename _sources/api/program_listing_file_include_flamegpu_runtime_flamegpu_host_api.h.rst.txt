
.. _program_listing_file_include_flamegpu_runtime_flamegpu_host_api.h:

Program Listing for File flamegpu_host_api.h
============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_flamegpu_host_api.h>` (``include/flamegpu/runtime/flamegpu_host_api.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_FLAMEGPU_HOST_API_H_
   #define INCLUDE_FLAMEGPU_RUNTIME_FLAMEGPU_HOST_API_H_
   
   #include <cuda_runtime_api.h>
   #include <string>
   #include <utility>
   #include <functional>
   #include <unordered_map>
   #include <vector>
   
   #include "flamegpu/gpu/CUDAErrorChecking.h"
   #include "flamegpu/runtime/utility/HostRandom.cuh"
   #include "flamegpu/runtime/utility/HostEnvironment.cuh"
   #include "flamegpu/runtime/flamegpu_host_api_macros.h"
   #include "flamegpu/runtime/flamegpu_host_new_agent_api.h"
   
   class CUDASimulation;
   class HostAgentInstance;
   
   class FLAMEGPU_HOST_API {
       friend class HostAgentInstance;
   
    public:
       // Typedefs repeated from CUDASimulation
       typedef std::vector<NewAgentStorage> AgentDataBuffer;
       typedef std::unordered_map<std::string, AgentDataBuffer> AgentDataBufferStateMap;
       typedef std::unordered_map<std::string, VarOffsetStruct> AgentOffsetMap;
       typedef std::unordered_map<std::string, AgentDataBufferStateMap> AgentDataMap;
   
        explicit FLAMEGPU_HOST_API(CUDASimulation&_agentModel,
           RandomManager &rng,
            const AgentOffsetMap &agentOffsets,
            AgentDataMap &agentData);
        ~FLAMEGPU_HOST_API();
       HostAgentInstance agent(const std::string &agent_name, const std::string &stateName = ModelData::DEFAULT_STATE);
       FLAMEGPU_HOST_NEW_AGENT_API newAgent(const std::string &agent_name);
       FLAMEGPU_HOST_NEW_AGENT_API newAgent(const std::string &agent_name, const std::string &state);
       const HostRandom random;
       const HostEnvironment environment;
   
       unsigned int getStepCounter() const;
   
    private:
       enum CUB_Operation {
           MIN,
           MAX,
           SUM,
           CUSTOM_REDUCE,
           HISTOGRAM_EVEN,
           SORT
       };
       // Can't put type_info in map, deleted constructors, so we use it's hash code
       // Histogram always has type int, so we use number of bins instead
       typedef std::pair<CUB_Operation, size_t> CUB_Config;
       struct key_hash : public std::unary_function<CUB_Config, std::size_t> {
           std::size_t operator()(const CUB_Config& k) const {
               return static_cast<size_t>(std::get<0>(k)) ^ std::get<1>(k);
           }
       };
       std::unordered_map<CUB_Config, unsigned int, key_hash> cub_largestAllocatedOp;
       bool tempStorageRequiresResize(const CUB_Config &cc, const unsigned int &items);
       void resizeTempStorage(const CUB_Config &cc, const unsigned int &items, const size_t &newSize);
       template<typename T>
       void resizeOutputSpace(const unsigned int &items = 1);
       CUDASimulation &agentModel;
       void *d_cub_temp;
       size_t d_cub_temp_size;
       void *d_output_space;
       size_t d_output_space_size;
       /*
        * Owned by CUDASimulation, this provides memory offsets for agent variables
        * Used for host agent creationg
        */
       const AgentOffsetMap &agentOffsets;
       /*
        * Owned by CUDASimulation, this provides storage for new agents
        * Used for host agent creation, this should be emptied end of each step 
        * when new agents are copied to device.
        */
       AgentDataMap &agentData;
   };
   
   template<typename T>
   void FLAMEGPU_HOST_API::resizeOutputSpace(const unsigned int &items) {
       if (sizeof(T) * items > d_output_space_size) {
           if (d_output_space_size) {
               gpuErrchk(cudaFree(d_output_space));
           }
           gpuErrchk(cudaMalloc(&d_output_space, sizeof(T) * items));
           d_output_space_size = sizeof(T) * items;
       }
   }
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_FLAMEGPU_HOST_API_H_
