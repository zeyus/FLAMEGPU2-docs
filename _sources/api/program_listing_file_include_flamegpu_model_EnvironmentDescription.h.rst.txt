
.. _program_listing_file_include_flamegpu_model_EnvironmentDescription.h:

Program Listing for File EnvironmentDescription.h
=================================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_model_EnvironmentDescription.h>` (``include/flamegpu/model/EnvironmentDescription.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_MODEL_ENVIRONMENTDESCRIPTION_H_
   #define INCLUDE_FLAMEGPU_MODEL_ENVIRONMENTDESCRIPTION_H_
   
   #include <unordered_map>
   #include <string>
   #include <typeinfo>
   #include <typeindex>
   #include <array>
   #include <vector>
   #include <utility>
   
   #include "flamegpu/exception/FLAMEGPUException.h"
   #include "flamegpu/runtime/utility/HostEnvironment.cuh"
   #include "flamegpu/util/Any.h"
   #include "flamegpu/gpu/CUDAEnsemble.h"
   
   namespace flamegpu {
   
   class EnvironmentDescription {
       friend class EnvironmentManager;
       friend class SubEnvironmentDescription;
       friend class CUDASimulation;
   
       friend class SimRunner;
       friend void CUDAEnsemble::simulate(const RunPlanVector &plans);
   
    public:
       struct PropData {
           PropData(const bool &_is_const, const util::Any &_data)
               : isConst(_is_const)
               , data(_data) { }
           bool isConst;
           const util::Any data;
           bool operator==(const PropData &rhs) const {
               if (this->isConst != rhs.isConst
                  || this->data.elements != rhs.data.elements
                  || this->data.length != rhs.data.length
                  || this->data.type != rhs.data.type)
                   return false;
               for (size_t i = 0; i < this->data.length; ++i) {
                   if (static_cast<const char *>(this->data.ptr)[i] != static_cast<const char *>(rhs.data.ptr)[i])
                       return false;
               }
               return true;
           }
       };
       EnvironmentDescription();
   
       bool operator==(const EnvironmentDescription& rhs) const;
       bool operator!=(const EnvironmentDescription& rhs) const;
       template<typename T>
       void newProperty(const std::string &name, const T &value, const bool &isConst = false);
       template<typename T, EnvironmentManager::size_type N>
       void newProperty(const std::string &name, const std::array<T, N> &value, const bool &isConst = false);
   #ifdef SWIG
   
       template<typename T>
       void newPropertyArray(const std::string &name, const EnvironmentManager::size_type &length, const std::vector<T> &value, const bool &isConst = false);
   #endif
   
       template<typename T>
       T getProperty(const std::string &name) const;
       template<typename T, EnvironmentManager::size_type N>
       std::array<T, N> getProperty(const std::string &name) const;
       template<typename T>
       T getProperty(const std::string &name, const EnvironmentManager::size_type &index) const;
   #ifdef SWIG
   
       template<typename T>
       std::vector<T> getPropertyArray(const std::string &name) const;
   #endif
   
       bool getConst(const std::string &name);
       template<typename T>
       T setProperty(const std::string &name, const T &value);
       template<typename T, EnvironmentManager::size_type N>
       std::array<T, N> setProperty(const std::string &name, const std::array<T, N> &value);
       template<typename T>
       T setProperty(const std::string &name, const EnvironmentManager::size_type &index, const T &value);
   #ifdef SWIG
   
       template<typename T>
       std::vector<T> setPropertyArray(const std::string &name, const std::vector<T> &value);
   #endif
   
       const std::unordered_map<std::string, PropData> getPropertiesMap() const;
   
    private:
       void newProperty(const std::string &name, const char *ptr, const size_t &len, const bool &isConst, const EnvironmentManager::size_type &elements, const std::type_index &type);
       std::unordered_map<std::string, PropData> properties{};
   };
   
   
   template<typename T>
   void EnvironmentDescription::newProperty(const std::string &name, const T &value, const bool &isConst) {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in EnvironmentDescription::add().");
       }
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       if (properties.find(name) != properties.end()) {
           THROW exception::DuplicateEnvProperty("Environmental property with name '%s' already exists, "
               "in EnvironmentDescription::add().",
               name.c_str());
       }
       newProperty(name, reinterpret_cast<const char*>(&value), sizeof(T), isConst, 1, typeid(T));
   }
   template<typename T, EnvironmentManager::size_type N>
   void EnvironmentDescription::newProperty(const std::string &name, const std::array<T, N> &value, const bool &isConst) {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in EnvironmentDescription::add().");
       }
       static_assert(N > 0, "Environment property arrays must have a length greater than 0.");
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       if (properties.find(name) != properties.end()) {
           THROW exception::DuplicateEnvProperty("Environmental property with name '%s' already exists, "
               "in EnvironmentDescription::add().",
               name.c_str());
       }
       newProperty(name, reinterpret_cast<const char*>(value.data()), N * sizeof(T), isConst, N, typeid(T));
   }
   #ifdef SWIG
   template<typename T>
   void EnvironmentDescription::newPropertyArray(const std::string &name, const EnvironmentManager::size_type &N, const std::vector<T> &value, const bool& isConst) {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in EnvironmentDescription::addArray().");
       }
       if (value.size() != N) {
           THROW exception::InvalidEnvProperty("Environment property array length does not match the value provided, %u != %llu,"
               "in EnvironmentDescription::addArray().", N, value.size());
       }
       if (N == 0) {
           THROW exception::InvalidEnvProperty("Environment property arrays must have a length greater than 0."
               "in EnvironmentDescription::addArray().");
       }
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       if (properties.find(name) != properties.end()) {
           THROW exception::DuplicateEnvProperty("Environmental property with name '%s' already exists, "
               "in EnvironmentDescription::addArray().",
               name.c_str());
       }
       newProperty(name, reinterpret_cast<const char*>(value.data()), N * sizeof(T), isConst, N, typeid(T));
   }
   #endif
   
   template<typename T>
   T EnvironmentDescription::getProperty(const std::string &name) const {
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       auto &&i = properties.find(name);
       if (i != properties.end()) {
           if (i->second.data.type != std::type_index(typeid(T))) {
               THROW exception::InvalidEnvPropertyType("Environmental property ('%s') type (%s) does not match template argument T (%s), "
                   "in EnvironmentDescription::get().",
                   name.c_str(), i->second.data.type.name(), typeid(T).name());
           }
           return *reinterpret_cast<T*>(i->second.data.ptr);
       }
       THROW exception::InvalidEnvProperty("Environmental property with name '%s' does not exist, "
           "in EnvironmentDescription::get().",
           name.c_str());
   }
   template<typename T, EnvironmentManager::size_type N>
   std::array<T, N> EnvironmentDescription::getProperty(const std::string &name) const {
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       auto &&i = properties.find(name);
       if (i != properties.end()) {
           if (i->second.data.type != std::type_index(typeid(T))) {
               THROW exception::InvalidEnvPropertyType("Environmental property array ('%s') type (%s) does not match template argument T (%s), "
                   "in EnvironmentDescription::get().",
                   name.c_str(), i->second.data.type.name(), typeid(T).name());
           }
           if (i->second.data.elements != N) {
               THROW exception::OutOfBoundsException("Length of named environmental property array (%u) does not match template argument N (%u), "
                   "in EnvironmentDescription::get().",
                   i->second.data.elements, N);
           }
           // Copy old data to return
           std::array<T, N> rtn;
           memcpy(rtn.data(), reinterpret_cast<T*>(i->second.data.ptr), N * sizeof(T));
           return rtn;
       }
       THROW exception::InvalidEnvProperty("Environmental property with name '%s' does not exist, "
           "in EnvironmentDescription::get().",
           name.c_str());
   }
   template<typename T>
   T EnvironmentDescription::getProperty(const std::string &name, const EnvironmentManager::size_type &index) const {
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       auto &&i = properties.find(name);
       if (i != properties.end()) {
           if (i->second.data.type != std::type_index(typeid(T))) {
               THROW exception::InvalidEnvPropertyType("Environmental property array ('%s') type (%s) does not match template argument T (%s), "
                   "in EnvironmentDescription::get().",
                   name.c_str(), i->second.data.type.name(), typeid(T).name());
           }
           if (i->second.data.elements <= index) {
               THROW exception::OutOfBoundsException("Index (%u) exceeds named environmental property array's length (%u), "
                   "in EnvironmentDescription::get().",
                   index, i->second.data.elements);
           }
           // Copy old data to return
           return *(reinterpret_cast<T*>(i->second.data.ptr) + index);
       }
       THROW exception::InvalidEnvProperty("Environmental property with name '%s' does not exist, "
           "in EnvironmentDescription::get().",
           name.c_str());
   }
   #ifdef SWIG
   template<typename T>
   std::vector<T> EnvironmentDescription::getPropertyArray(const std::string& name) const {
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       auto &&i = properties.find(name);
       if (i != properties.end()) {
           if (i->second.data.type != std::type_index(typeid(T))) {
               THROW exception::InvalidEnvPropertyType("Environmental property array ('%s') type (%s) does not match template argument T (%s), "
                   "in EnvironmentDescription::getArray().",
                   name.c_str(), i->second.data.type.name(), typeid(T).name());
           }
           // Copy old data to return
           std::vector<T> rtn(i->second.data.elements);
           memcpy(rtn.data(), reinterpret_cast<T*>(i->second.data.ptr), i->second.data.elements * sizeof(T));
           return rtn;
       }
       THROW exception::InvalidEnvProperty("Environmental property with name '%s' does not exist, "
           "in EnvironmentDescription::getArray().",
           name.c_str());
   }
   #endif
   
   template<typename T>
   T EnvironmentDescription::setProperty(const std::string &name, const T &value) {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in EnvironmentDescription::set().");
       }
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       auto &&i = properties.find(name);
       if (i != properties.end()) {
           if (i->second.data.type != std::type_index(typeid(T))) {
               THROW exception::InvalidEnvPropertyType("Environmental property ('%s') type (%s) does not match template argument T (%s), "
                   "in EnvironmentDescription::set().",
                   name.c_str(), i->second.data.type.name(), typeid(T).name());
           }
           // Copy old data to return
           T rtn = *reinterpret_cast<T*>(i->second.data.ptr);
           // Store data
           memcpy(i->second.data.ptr, &value, sizeof(T));
           return rtn;
       }
       THROW exception::InvalidEnvProperty("Environmental property with name '%s' does not exist, "
           "in EnvironmentDescription::set().",
           name.c_str());
   }
   template<typename T, EnvironmentManager::size_type N>
   std::array<T, N> EnvironmentDescription::setProperty(const std::string &name, const std::array<T, N> &value) {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in EnvironmentDescription::set().");
       }
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       auto &&i = properties.find(name);
       if (i != properties.end()) {
           if (i->second.data.type != std::type_index(typeid(T))) {
               THROW exception::InvalidEnvPropertyType("Environmental property array ('%s') type (%s) does not match template argument T (%s), "
                   "in EnvironmentDescription::set().",
                   name.c_str(), i->second.data.type.name(), typeid(T).name());
           }
           if (i->second.data.elements != N) {
               THROW exception::OutOfBoundsException("Length of named environmental property array (%u) does not match template argument N (%u), "
                   "in EnvironmentDescription::set().",
                   i->second.data.elements, N);
           }
           // Copy old data to return
           std::array<T, N> rtn;
           memcpy(rtn.data(), reinterpret_cast<T*>(i->second.data.ptr), N * sizeof(T));
           // Store data
           memcpy(reinterpret_cast<T*>(i->second.data.ptr), value.data(), N * sizeof(T));
           return rtn;
       }
       THROW exception::InvalidEnvProperty("Environmental property with name '%s' does not exist, "
           "in EnvironmentDescription::set().",
           name.c_str());
   }
   template<typename T>
   T EnvironmentDescription::setProperty(const std::string &name, const EnvironmentManager::size_type &index, const T &value) {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in EnvironmentDescription::set().");
       }
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       auto &&i = properties.find(name);
       if (i != properties.end()) {
           if (i->second.data.type != std::type_index(typeid(T))) {
               THROW exception::InvalidEnvPropertyType("Environmental property array ('%s') type (%s) does not match template argument T (%s), "
                   "in EnvironmentDescription::set().",
                   name.c_str(), i->second.data.type.name(), typeid(T).name());
           }
           if (i->second.data.elements <= index) {
               THROW exception::OutOfBoundsException("Index (%u) exceeds named environmental property array's length (%u), "
                   "in EnvironmentDescription::set().",
                   index, i->second.data.elements);
           }
           // Copy old data to return
           T rtn = *(reinterpret_cast<T*>(i->second.data.ptr) + index);
           // Store data
           memcpy(reinterpret_cast<T*>(i->second.data.ptr) + index, &value, sizeof(T));
           return rtn;
       }
       THROW exception::InvalidEnvProperty("Environmental property with name '%s' does not exist, "
           "in EnvironmentDescription::set().",
           name.c_str());
   }
   #ifdef SWIG
   template<typename T>
   std::vector<T> EnvironmentDescription::setPropertyArray(const std::string& name, const std::vector<T>& value) {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in EnvironmentDescription::set().");
       }
       // Limited to Arithmetic types
       // Compound types would allow host pointers inside structs to be passed
       static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value,
           "Only arithmetic types can be used as environmental properties");
       auto &&i = properties.find(name);
       if (i != properties.end()) {
           if (i->second.data.type != std::type_index(typeid(T))) {
               THROW exception::InvalidEnvPropertyType("Environmental property array ('%s') type (%s) does not match template argument T (%s), "
                   "in EnvironmentDescription::set().",
                   name.c_str(), i->second.data.type.name(), typeid(T).name());
           }
           if (i->second.data.elements != value.size()) {
               THROW exception::OutOfBoundsException("Length of named environmental property array (%u) does not match length of provided vector (%llu), "
                   "in EnvironmentDescription::set().",
                   i->second.data.elements, value.size());
           }
           // Copy old data to return
           std::vector<T> rtn(i->second.data.elements);
           memcpy(rtn.data(), reinterpret_cast<T*>(i->second.data.ptr), i->second.data.elements * sizeof(T));
           // Store data
           memcpy(reinterpret_cast<T*>(i->second.data.ptr), value.data(), i->second.data.elements * sizeof(T));
           return rtn;
       }
       THROW exception::InvalidEnvProperty("Environmental property with name '%s' does not exist, "
           "in EnvironmentDescription::set().",
           name.c_str());
   }
   #endif
   }  // namespace flamegpu
   
   #endif  // INCLUDE_FLAMEGPU_MODEL_ENVIRONMENTDESCRIPTION_H_
