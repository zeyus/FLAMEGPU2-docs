

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Program Listing for File xmlReader.cpp &mdash; FLAME GPU 2 0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: black" >
          

          
            <a href="../index.html" class="icon icon-home"> FLAME GPU 2
          

          
            
            <img src="../_static/flamegpu2-icon-notext-128.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
<li class="toctree-l1"><a class="reference internal" href="class_view_hierarchy.html">Class Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_view_hierarchy.html">File Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="unabridged_api.html">Full API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FLAME GPU 2</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File xmlReader.cpp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/program_listing_file_src_flamegpu_io_xmlReader.cpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="program-listing-for-file-xmlreader-cpp">
<span id="program-listing-file-src-flamegpu-io-xmlreader-cpp"></span><h1>Program Listing for File xmlReader.cpp<a class="headerlink" href="#program-listing-for-file-xmlreader-cpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_flamegpu_io_xmlReader.cpp.html#file-src-flamegpu-io-xmlreader-cpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/flamegpu/io/xmlReader.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#include &quot;flamegpu/io/xmlReader.h&quot;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;tuple&gt;
#include &quot;tinyxml2/tinyxml2.h&quot;              // downloaded from https:// github.com/leethomason/tinyxml2, the list of xml parsers : http:// lars.ruoff.free.fr/xmlcpp/
#include &quot;flamegpu/exception/FGPUException.h&quot;
#include &quot;flamegpu/pop/AgentVector.h&quot;
#include &quot;flamegpu/model/AgentDescription.h&quot;
#include &quot;flamegpu/gpu/CUDASimulation.h&quot;

#ifndef XMLCheckResult
#define XMLCheckResult(a_eResult) if (a_eResult != tinyxml2::XML_SUCCESS) { FGPUException::setLocation(__FILE__, __LINE__);\
    switch (a_eResult) { \
    case tinyxml2::XML_ERROR_FILE_NOT_FOUND : \
    case tinyxml2::XML_ERROR_FILE_COULD_NOT_BE_OPENED : \
        throw InvalidInputFile(&quot;TinyXML error: File could not be opened.\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_ERROR_FILE_READ_ERROR : \
        throw InvalidInputFile(&quot;TinyXML error: File could not be read.\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_ERROR_PARSING_ELEMENT : \
    case tinyxml2::XML_ERROR_PARSING_ATTRIBUTE : \
    case tinyxml2::XML_ERROR_PARSING_TEXT : \
    case tinyxml2::XML_ERROR_PARSING_CDATA : \
    case tinyxml2::XML_ERROR_PARSING_COMMENT : \
    case tinyxml2::XML_ERROR_PARSING_DECLARATION : \
    case tinyxml2::XML_ERROR_PARSING_UNKNOWN : \
    case tinyxml2::XML_ERROR_PARSING : \
        throw TinyXMLError(&quot;TinyXML error: Error parsing file.\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_ERROR_EMPTY_DOCUMENT : \
        throw TinyXMLError(&quot;TinyXML error: XML_ERROR_EMPTY_DOCUMENT\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_ERROR_MISMATCHED_ELEMENT : \
        throw TinyXMLError(&quot;TinyXML error: XML_ERROR_MISMATCHED_ELEMENT\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_CAN_NOT_CONVERT_TEXT : \
        throw TinyXMLError(&quot;TinyXML error: XML_CAN_NOT_CONVERT_TEXT\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_NO_TEXT_NODE : \
        throw TinyXMLError(&quot;TinyXML error: XML_NO_TEXT_NODE\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_ELEMENT_DEPTH_EXCEEDED : \
        throw TinyXMLError(&quot;TinyXML error: XML_ELEMENT_DEPTH_EXCEEDED\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_ERROR_COUNT : \
        throw TinyXMLError(&quot;TinyXML error: XML_ERROR_COUNT\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_NO_ATTRIBUTE: \
        throw TinyXMLError(&quot;TinyXML error: XML_NO_ATTRIBUTE\n Error code: %d&quot;, a_eResult); \
    case tinyxml2::XML_WRONG_ATTRIBUTE_TYPE : \
        throw TinyXMLError(&quot;TinyXML error: XML_WRONG_ATTRIBUTE_TYPE\n Error code: %d&quot;, a_eResult); \
    default: \
        throw TinyXMLError(&quot;TinyXML error: Unrecognised error code\n Error code: %d&quot;, a_eResult); \
    } \
}
#endif

xmlReader::xmlReader(
    const std::string &amp;model_name,
    const std::unordered_map&lt;std::string, EnvironmentDescription::PropData&gt; &amp;env_desc,
    std::unordered_map&lt;std::pair&lt;std::string, unsigned int&gt;, Any&gt; &amp;env_init,
    StringPairUnorderedMap&lt;std::shared_ptr&lt;AgentVector&gt;&gt; &amp;model_state,
    const std::string &amp;input,
    Simulation *sim_instance)
    : StateReader(model_name, env_desc, env_init, model_state, input, sim_instance) {}

std::string xmlReader::getInitialState(const std::string &amp;agent_name) const {
    for (const auto &amp;i : model_state) {
        if (agent_name == i.first.first)
            return i.second-&gt;getInitialState();
    }
    return ModelData::DEFAULT_STATE;
}
int xmlReader::parse() {
    tinyxml2::XMLDocument doc;

    tinyxml2::XMLError errorId = doc.LoadFile(inputFile.c_str());
    XMLCheckResult(errorId);

    tinyxml2::XMLNode* pRoot = doc.FirstChild();
    if (pRoot == nullptr) {
        THROW TinyXMLError(&quot;TinyXML error: Error parsing doc %s.&quot;, inputFile.c_str());
    }

    tinyxml2::XMLElement * pElement = pRoot-&gt;FirstChildElement(&quot;itno&quot;);
    if (pElement == nullptr) {
        THROW TinyXMLError(&quot;TinyXML error: Error parsing element %s.&quot;, inputFile.c_str());
    }

    int error;
    errorId = pElement-&gt;QueryIntText(&amp;error);
    XMLCheckResult(errorId);

    // Read config data
    pElement = pRoot-&gt;FirstChildElement(&quot;config&quot;);
    if (pElement) {
        // Sim config
        if (sim_instance) {
            tinyxml2::XMLElement *pSimCfgBlock = pElement-&gt;FirstChildElement(&quot;simulation&quot;);
            for (auto simCfgElement = pSimCfgBlock-&gt;FirstChildElement(); simCfgElement; simCfgElement = simCfgElement-&gt;NextSiblingElement()) {
                std::string key = simCfgElement-&gt;Value();
                std::string val = simCfgElement-&gt;GetText();
                if (key == &quot;input_file&quot;) {
                    if (inputFile != val)
                        printf(&quot;Warning: Input file &#39;%s&#39; refers to second input file &#39;%s&#39;, this will not be loaded.\n&quot;, inputFile.c_str(), val.c_str());
                    // sim_instance-&gt;SimulationConfig().input_file = val;
                } else if (key == &quot;steps&quot;) {
                    sim_instance-&gt;SimulationConfig().steps = static_cast&lt;unsigned int&gt;(stoull(val));
                } else if (key == &quot;timing&quot;) {
                    for (auto&amp; c : val)
                        c = static_cast&lt;char&gt;(::tolower(c));
                    if (val == &quot;true&quot;) {
                        sim_instance-&gt;SimulationConfig().timing = true;
                    } else if (val == &quot;false&quot;) {
                        sim_instance-&gt;SimulationConfig().timing = false;
                    } else {
                        sim_instance-&gt;SimulationConfig().timing = static_cast&lt;bool&gt;(stoll(val));
                    }
                } else if (key == &quot;random_seed&quot;) {
                    sim_instance-&gt;SimulationConfig().random_seed = static_cast&lt;unsigned int&gt;(stoull(val));
                } else if (key == &quot;verbose&quot;) {
                    for (auto&amp; c : val)
                        c = static_cast&lt;char&gt;(::tolower(c));
                    if (val == &quot;true&quot;) {
                        sim_instance-&gt;SimulationConfig().verbose = true;
                    } else if (val == &quot;false&quot;) {
                        sim_instance-&gt;SimulationConfig().verbose = false;
                    } else {
                        sim_instance-&gt;SimulationConfig().verbose = static_cast&lt;bool&gt;(stoll(val));
                    }
                } else if (key == &quot;console_mode&quot;) {
#ifdef VISUALISATION
                    for (auto&amp; c : val)
                        c = static_cast&lt;char&gt;(::tolower(c));
                    if (val == &quot;true&quot;) {
                        sim_instance-&gt;SimulationConfig().console_mode = true;
                    } else if (val == &quot;false&quot;) {
                        sim_instance-&gt;SimulationConfig().console_mode = false;
                    } else {
                        sim_instance-&gt;SimulationConfig().console_mode = static_cast&lt;bool&gt;(stoll(val));
                    }
#else
                    if (val == &quot;false&quot;) {
                        fprintf(stderr, &quot;Warning: Cannot disable &#39;console_mode&#39; with input file &#39;%s&#39;, FLAMEGPU2 library has not been built with visualisation support enabled.\n&quot;, inputFile.c_str());
                    }
#endif
                }  else {
                    fprintf(stderr, &quot;Warning: Input file &#39;%s&#39; contains unexpected simulation config property &#39;%s&#39;.\n&quot;, inputFile.c_str(), key.c_str());
                }
            }
        }
        // CUDA config
        CUDASimulation *cudamodel_instance = dynamic_cast&lt;CUDASimulation*&gt;(sim_instance);
        if (cudamodel_instance) {
            tinyxml2::XMLElement *pCUDACfgBlock = pElement-&gt;FirstChildElement(&quot;cuda&quot;);
            for (auto cudaCfgElement = pCUDACfgBlock-&gt;FirstChildElement(); cudaCfgElement; cudaCfgElement = cudaCfgElement-&gt;NextSiblingElement()) {
                std::string key = cudaCfgElement-&gt;Value();
                std::string val = cudaCfgElement-&gt;GetText();
                if (key == &quot;device_id&quot;) {
                    cudamodel_instance-&gt;CUDAConfig().device_id = static_cast&lt;unsigned int&gt;(stoull(val));
                }  else {
                    fprintf(stderr, &quot;Warning: Input file &#39;%s&#39; contains unexpected cuda config property &#39;%s&#39;.\n&quot;, inputFile.c_str(), key.c_str());
                }
            }
        }
    } else {
        // No warning, environment node is not mandatory
    }

    // Read environment data
    pElement = pRoot-&gt;FirstChildElement(&quot;environment&quot;);
    if (pElement) {
        for (auto envElement = pElement-&gt;FirstChildElement(); envElement; envElement = envElement-&gt;NextSiblingElement()) {
            const char *key = envElement-&gt;Value();
            std::stringstream ss(envElement-&gt;GetText());
            std::string token;
            const auto it = env_desc.find(std::string(key));
            if (it == env_desc.end()) {
                THROW TinyXMLError(&quot;Input file contains unrecognised environment property &#39;%s&#39;,&quot;
                    &quot;in xmlReader::parse()\n&quot;, key);
            }
            const std::type_index val_type = it-&gt;second.data.type;
            const auto elements = it-&gt;second.data.elements;
            unsigned int el = 0;
            while (getline(ss, token, &#39;,&#39;)) {
                if (env_init.find(make_pair(std::string(key), el)) != env_init.end()) {
                    THROW TinyXMLError(&quot;Input file contains environment property &#39;%s&#39; multiple times, &quot;
                        &quot;in xmlReader::parse()\n&quot;, key);
                }
                if (val_type == std::type_index(typeid(float))) {
                    const float t = stof(token);
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(float), val_type, 1));
                } else if (val_type == std::type_index(typeid(double))) {
                    const double t = stod(token);
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(double), val_type, 1));
                } else if (val_type == std::type_index(typeid(int64_t))) {
                    const int64_t t = stoll(token);
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(int64_t), val_type, 1));
                } else if (val_type == std::type_index(typeid(uint64_t))) {
                    const uint64_t t = stoull(token);
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(uint64_t), val_type, 1));
                } else if (val_type == std::type_index(typeid(int32_t))) {
                    const int32_t t = static_cast&lt;int32_t&gt;(stoll(token));
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(int32_t), val_type, 1));
                } else if (val_type == std::type_index(typeid(uint32_t))) {
                    const uint32_t t = static_cast&lt;uint32_t&gt;(stoull(token));
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(uint32_t), val_type, 1));
                } else if (val_type == std::type_index(typeid(int16_t))) {
                    const int16_t t = static_cast&lt;int16_t&gt;(stoll(token));
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(int16_t), val_type, 1));
                } else if (val_type == std::type_index(typeid(uint16_t))) {
                    const uint16_t t = static_cast&lt;uint16_t&gt;(stoull(token));
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(uint16_t), val_type, 1));
                } else if (val_type == std::type_index(typeid(int8_t))) {
                    const int8_t t = static_cast&lt;int8_t&gt;(stoll(token));
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(int8_t), val_type, 1));
                } else if (val_type == std::type_index(typeid(uint8_t))) {
                    const uint8_t t = static_cast&lt;uint8_t&gt;(stoull(token));
                    env_init.emplace(make_pair(std::string(key), el++), Any(&amp;t, sizeof(uint8_t), val_type, 1));
                } else {
                    THROW TinyXMLError(&quot;Model contains environment property &#39;%s&#39; of unsupported type &#39;%s&#39;, &quot;
                        &quot;in xmlReader::parse()\n&quot;, key, val_type.name());
                }
            }
            if (el != elements) {
                fprintf(stderr, &quot;Warning: Environment array property &#39;%s&#39; expects &#39;%u&#39; elements, input file &#39;%s&#39; contains &#39;%u&#39; elements.\n&quot;,
                    key, elements, inputFile.c_str(), el);
            }
        }
    } else {
        fprintf(stderr, &quot;Warning: Input file &#39;%s&#39; does not contain environment node.\n&quot;, inputFile.c_str());
    }

    // Count how many of each agent are in the file and resize state lists
    StringPairUnorderedMap&lt;unsigned int&gt; cts;
    for (pElement = pRoot-&gt;FirstChildElement(&quot;xagent&quot;); pElement != nullptr; pElement = pElement-&gt;NextSiblingElement(&quot;xagent&quot;)) {
        std::string agent_name = pElement-&gt;FirstChildElement(&quot;name&quot;)-&gt;GetText();
        tinyxml2::XMLElement *state_element = pElement-&gt;FirstChildElement(&quot;state&quot;);
        std::string state_name = state_element ? state_element-&gt;GetText() : getInitialState(agent_name);
        cts[{agent_name, state_name}]++;
    }
    // Resize state lists (greedy, all lists are resized to max size of state)
    for (auto&amp; it : model_state) {
        auto f = cts.find(it.first);
        if (f != cts.end())
          it.second-&gt;reserve(f-&gt;second);
    }

    // Read in agent data
    for (pElement = pRoot-&gt;FirstChildElement(&quot;xagent&quot;); pElement != nullptr; pElement = pElement-&gt;NextSiblingElement(&quot;xagent&quot;)) {
        // Find agent name
        tinyxml2::XMLElement* pNameElement = pElement-&gt;FirstChildElement(&quot;name&quot;);
        const char* agentName = pNameElement-&gt;GetText();
        // Find agent state, use initial state if not set (means its old fgpu1 input file)
        tinyxml2::XMLElement* pStateElement = pElement-&gt;FirstChildElement(&quot;state&quot;);
        const std::string agentState = pStateElement ? std::string(pStateElement-&gt;GetText()) : getInitialState(agentName);
        std::shared_ptr&lt;AgentVector&gt; &amp;agentVec = model_state.at({agentName, agentState });
        const VariableMap&amp; agentVariables = agentVec-&gt;getVariableMetaData();
        // Create instance to store variable data in
        agentVec-&gt;push_back();
        AgentVector::Agent instance = agentVec-&gt;back();
        bool hasWarnedElements = false;
        bool hasWarnedMissingVar = false;
        // Iterate agent variables
        for (auto iter = agentVariables.begin(); iter != agentVariables.end(); ++iter) {
            const std::string variable_name = iter-&gt;first;
            const auto &amp;var_data = iter-&gt;second;
            tinyxml2::XMLElement* pVarElement = pElement-&gt;FirstChildElement(variable_name.c_str());
            if (pVarElement) {
                // Put string for the variable into a string stream
                std::stringstream ss(pVarElement-&gt;GetText());
                std::string token;
                // Iterate elements of the stringstream
                unsigned int el = 0;
                while (getline(ss, token, &#39;,&#39;)) {
                    if (var_data.type == std::type_index(typeid(float))) {
                        instance.setVariable&lt;float&gt;(variable_name, el++, stof(token));
                    } else if (var_data.type == std::type_index(typeid(double))) {
                        instance.setVariable&lt;double&gt;(variable_name, el++, stod(token));
                    } else if (var_data.type == std::type_index(typeid(int64_t))) {
                        instance.setVariable&lt;int64_t&gt;(variable_name, el++, stoll(token));
                    } else if (var_data.type == std::type_index(typeid(uint64_t))) {
                        instance.setVariable&lt;uint64_t&gt;(variable_name, el++, stoull(token));
                    } else if (var_data.type == std::type_index(typeid(int32_t))) {
                        instance.setVariable&lt;int32_t&gt;(variable_name, el++, static_cast&lt;int32_t&gt;(stoll(token)));
                    } else if (var_data.type == std::type_index(typeid(uint32_t))) {
                        instance.setVariable&lt;uint32_t&gt;(variable_name, el++, static_cast&lt;uint32_t&gt;(stoull(token)));
                    } else if (var_data.type == std::type_index(typeid(int16_t))) {
                        instance.setVariable&lt;int16_t&gt;(variable_name, el++, static_cast&lt;int16_t&gt;(stoll(token)));
                    } else if (var_data.type == std::type_index(typeid(uint16_t))) {
                        instance.setVariable&lt;uint16_t&gt;(variable_name, el++, static_cast&lt;uint16_t&gt;(stoull(token)));
                    } else if (var_data.type == std::type_index(typeid(int8_t))) {
                        instance.setVariable&lt;int8_t&gt;(variable_name, el++, static_cast&lt;int8_t&gt;(stoll(token)));
                    } else if (var_data.type == std::type_index(typeid(uint8_t))) {
                        instance.setVariable&lt;uint8_t&gt;(variable_name, el++, static_cast&lt;uint8_t&gt;(stoull(token)));
                    } else {
                        THROW TinyXMLError(&quot;Agent &#39;%s&#39; contains variable &#39;%s&#39; of unsupported type &#39;%s&#39;, &quot;
                            &quot;in xmlReader::parse()\n&quot;, agentName, variable_name.c_str(), var_data.type.name());
                    }
                }
                // Warn if var is wrong length
                if (el != var_data.elements &amp;&amp; !hasWarnedElements) {
                    fprintf(stderr, &quot;Warning: Agent &#39;%s&#39; variable &#39;%s&#39; expects &#39;%u&#39; elements, input file &#39;%s&#39; contains &#39;%u&#39; elements.\n&quot;,
                        agentName, variable_name.c_str(), var_data.elements, inputFile.c_str(), el);
                    hasWarnedElements = true;
                }
            } else if (!hasWarnedMissingVar) {
                fprintf(stderr, &quot;Warning: Agent &#39;%s&#39; variable &#39;%s&#39; is missing from, input file &#39;%s&#39;.\n&quot;,
                    agentName, variable_name.c_str(), inputFile.c_str());
                hasWarnedMissingVar = true;
            }
        }
    }

    return tinyxml2::XML_SUCCESS;
}
</pre></div>
</div>
</section>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, University of Sheffield.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>