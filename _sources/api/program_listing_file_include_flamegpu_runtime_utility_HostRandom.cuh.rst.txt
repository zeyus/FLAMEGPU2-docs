
.. _program_listing_file_include_flamegpu_runtime_utility_HostRandom.cuh:

Program Listing for File HostRandom.cuh
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_utility_HostRandom.cuh>` (``include/flamegpu/runtime/utility/HostRandom.cuh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_UTILITY_HOSTRANDOM_CUH_
   #define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_HOSTRANDOM_CUH_
   
   #include <random>
   
   #include "flamegpu/util/detail/StaticAssert.h"
   #include "flamegpu/runtime/utility/RandomManager.cuh"
   
   namespace flamegpu {
   
   class HostRandom {
       friend class HostAPI;
    public:
       template<typename T>
       inline T uniform() const;
       template<typename T>
       inline T normal() const;
       template<typename T>
       inline T logNormal(const T& mean, const T& stddev) const;
       template<typename T>
       inline T uniform(const T& min, const T& max) const;
       void setSeed(const uint64_t &seed);
       uint64_t getSeed() const;
   
    private:
       explicit HostRandom(RandomManager &_rng) : rng(_rng) { }
       RandomManager &rng;
   };
   
   
   
   template<typename T>
   inline T HostRandom::uniform() const {
       static_assert(util::detail::StaticAssert::_Is_RealType<T>::value, "Invalid template argument for HostRandom::uniform()");
       std::uniform_real_distribution<T> dist(0, 1);
       return rng.getDistribution<T>(dist);
   }
   
   template<typename T>
   inline T HostRandom::normal() const {
       static_assert(util::detail::StaticAssert::_Is_RealType<T>::value, "Invalid template argument for HostRandom::normal()");
       std::normal_distribution<T> dist(0, 1);
       return rng.getDistribution<T>(dist);
   }
   
   template<typename T>
   inline T HostRandom::logNormal(const T& mean, const T& stddev) const {
       static_assert(util::detail::StaticAssert::_Is_RealType<T>::value, "Invalid template argument for HostRandom::logNormal(const T& mean, const T& stddev)");
       std::lognormal_distribution<T> dist(mean, stddev);
       return rng.getDistribution<T>(dist);
   }
   
   template<typename T>
   inline T HostRandom::uniform(const T& min, const T& max) const {
       static_assert(util::detail::StaticAssert::_Is_IntType<T>::value, "Invalid template argument for HostRandom::uniform(const T& lowerBound, const T& max)");
       std::uniform_int_distribution<T> dist(min, max);
       return rng.getDistribution<T>(dist);
   }
   
   template<>
   inline char HostRandom::uniform(const char& min, const char& max) const {
       std::uniform_int_distribution<int16_t> dist(min, max);
       return static_cast<char>(rng.getDistribution<int16_t>(dist));
   }
   
   template<>
   inline unsigned char HostRandom::uniform(const unsigned char& min, const unsigned char& max) const {
       std::uniform_int_distribution<uint16_t> dist(min, max);
       return static_cast<unsigned char>(rng.getDistribution<uint16_t>(dist));
   }
   
   template<>
   inline signed char HostRandom::uniform(const signed char& min, const signed char& max) const {
       std::uniform_int_distribution<int16_t> dist(min, max);
       return static_cast<signed char>(rng.getDistribution<int16_t>(dist));
   }
   template<>
   inline float HostRandom::uniform(const float& min, const float& max) const {
       std::uniform_real_distribution<float> dist(min, max);
       return rng.getDistribution<float>(dist);
   }
   template<>
   inline double HostRandom::uniform(const double& min, const double& max) const {
       std::uniform_real_distribution<double> dist(min, max);
       return rng.getDistribution<double>(dist);
   }
   
   }  // namespace flamegpu
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_UTILITY_HOSTRANDOM_CUH_
