
.. _program_listing_file_include_flamegpu_model_LayerDescription.h:

Program Listing for File LayerDescription.h
===========================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_model_LayerDescription.h>` (``include/flamegpu/model/LayerDescription.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_MODEL_LAYERDESCRIPTION_H_
   #define INCLUDE_FLAMEGPU_MODEL_LAYERDESCRIPTION_H_
   
   #include <string>
   #include <memory>
   
   #include "flamegpu/model/ModelDescription.h"
   #include "flamegpu/model/AgentDescription.h"
   #include "flamegpu/model/ModelData.h"
   #include "flamegpu/model/LayerData.h"
   #include "flamegpu/runtime/AgentFunction.h"
   #include "flamegpu/model/AgentFunctionData.h"
   
   class LayerDescription {
       friend struct LayerData;
       LayerDescription(const std::shared_ptr<const ModelData> &_model, LayerData *const data);
       LayerDescription(const LayerDescription &other_layer) = delete;
       LayerDescription(LayerDescription &&other_layer) noexcept = delete;
       LayerDescription& operator=(const LayerDescription &other_layer) = delete;
       LayerDescription& operator=(LayerDescription &&other_layer) noexcept = delete;
   
    public:
       bool operator==(const LayerDescription& rhs) const;
       bool operator!=(const LayerDescription& rhs) const;
   
       template<typename AgentFunction>
       void addAgentFunction(AgentFunction a = AgentFunction());
       void addAgentFunction(const AgentFunctionDescription &afd);
       void addAgentFunction(const std::string &agentName, const std::string &functionName);
       void addAgentFunction(const char *agentName, const char *functionName);
       void addHostFunction(FLAMEGPU_HOST_FUNCTION_POINTER func_p);
       void addSubModel(const std::string &name);
       void addSubModel(const SubModelDescription &submodel);
   #ifdef SWIG
   
       inline void addHostFunctionCallback(HostFunctionCallback *func_callback);
   #endif
   
       std::string getName() const;
       ModelData::size_type getIndex() const;
       ModelData::size_type getAgentFunctionsCount() const;
       ModelData::size_type getHostFunctionsCount() const;
   #ifdef SWIG
   
       inline ModelData::size_type getHostFunctionCallbackCount() const;
   #endif
   
       const AgentFunctionDescription &getAgentFunction(unsigned int index) const;
       FLAMEGPU_HOST_FUNCTION_POINTER getHostFunction(unsigned int index) const;
   #ifdef SWIG
   
       inline HostFunctionCallback* getHostFunctionCallback(unsigned int index) const;
   #endif
   
    private:
       std::weak_ptr<const ModelData> model;
       LayerData *const layer;
   };
   
   
   template<typename AgentFunction>
   void LayerDescription::addAgentFunction(AgentFunction /*af*/) {
       AgentFunctionWrapper * func_compare = AgentFunction::fnPtr();
       // Find the matching agent function in model hierarchy
       auto mdl = model.lock();
       if (!mdl) {
           THROW ExpiredWeakPtr();
       }
       for (auto a : mdl->agents) {
           for (auto f : a.second->functions) {
               if (f.second->func == func_compare) {
                   // Check that layer does not already contain function with same agent + states
                   for (const auto &b : layer->agent_functions) {
                       if (auto parent = b->parent.lock()) {
                           // If agent matches
                           if (parent->name == a.second->name) {
                               // If they share a state
                               if (b->initial_state == f.second->initial_state ||
                                   b->initial_state == f.second->end_state ||
                                   b->end_state == f.second->initial_state ||
                                   b->end_state == f.second->end_state) {
                                   THROW InvalidAgentFunc("Agent functions '%s' cannot be added to this layer as agent function '%s' "
                                       "within the layer shares an input or output state, this is not permitted, "
                                       "in LayerDescription::addAgentFunction().",
                                       f.second->name.c_str(), b->name.c_str());
                               }
                           }
                       }
                   }
                   // Add it and check it succeeded
                   if (layer->agent_functions.emplace(f.second).second)
                       return;
                   THROW InvalidAgentFunc("Attempted to add same agent function to same layer twice, "
                       "in LayerDescription::addAgentFunction().");
               }
           }
       }
       THROW InvalidAgentFunc("Agent function was not found, "
           "in LayerDescription::addAgentFunction().");
   }
   
   #ifdef SWIG
   void LayerDescription::addHostFunctionCallback(HostFunctionCallback* func_callback) {
       if (!layer->host_functions_callbacks.insert(func_callback).second) {
               THROW InvalidHostFunc("Attempted to add same host function callback twice,"
                   "in LayerDescription::addHostFunctionCallback()");
           }
   }
   ModelData::size_type LayerDescription::getHostFunctionCallbackCount() const {
       // Safe down-cast
       return static_cast<ModelData::size_type>(layer->host_functions_callbacks.size());
   }
   HostFunctionCallback* LayerDescription::getHostFunctionCallback(unsigned int index) const {
       if (index < layer->host_functions_callbacks.size()) {
           auto it = layer->host_functions_callbacks.begin();
           for (unsigned int i = 0; i < index; ++i)
               ++it;
           return *it;
       }
       THROW OutOfBoundsException("Index %d is out of bounds (only %d items exist) "
           "in LayerDescription.getHostFunctionCallback()\n",
           index, layer->host_functions_callbacks.size());
   }
   #endif
   
   #endif  // INCLUDE_FLAMEGPU_MODEL_LAYERDESCRIPTION_H_
