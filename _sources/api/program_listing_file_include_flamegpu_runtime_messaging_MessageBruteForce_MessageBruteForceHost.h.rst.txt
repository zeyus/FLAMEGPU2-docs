
.. _program_listing_file_include_flamegpu_runtime_messaging_MessageBruteForce_MessageBruteForceHost.h:

Program Listing for File MessageBruteForceHost.h
================================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_messaging_MessageBruteForce_MessageBruteForceHost.h>` (``include/flamegpu/runtime/messaging/MessageBruteForce/MessageBruteForceHost.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEBRUTEFORCE_MESSAGEBRUTEFORCEHOST_H_
   #define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEBRUTEFORCE_MESSAGEBRUTEFORCEHOST_H_
   
   #include <typeindex>
   #include <memory>
   #include <unordered_map>
   #include <string>
   #include <vector>
   
   #include "flamegpu/model/Variable.h"
   #include "flamegpu/gpu/detail/CUDAErrorChecking.cuh"
   #include "flamegpu/runtime/detail/curve/curve.cuh"
   
   #include "flamegpu/runtime/messaging/MessageNone/MessageNoneHost.h"
   #include "flamegpu/runtime/messaging/MessageBruteForce.h"
   
   
   namespace flamegpu {
   
   class MessageBruteForce::CUDAModelHandler : public MessageSpecialisationHandler {
    public:
       explicit CUDAModelHandler(CUDAMessage &a)
           : MessageSpecialisationHandler()
           , d_metadata(nullptr)
           , sim_message(a) { }
   
       ~CUDAModelHandler() { }
       void init(CUDAScatter &scatter, const unsigned int &streamId) override;
       void buildIndex(CUDAScatter &scatter, const unsigned int &streamId, const cudaStream_t &stream) override;
       void allocateMetaDataDevicePtr() override;
       void freeMetaDataDevicePtr() override;
       const void *getMetaDataDevicePtr() const override { return d_metadata; }
   
    private:
       MetaData hd_metadata;
       MetaData *d_metadata;
       CUDAMessage &sim_message;
   };
   
   struct MessageBruteForce::Data {
       friend class ModelDescription;
       friend struct ModelData;
   
       virtual ~Data();
   
       VariableMap variables;
       std::unique_ptr<Description> description;
       std::string name;
       unsigned int optional_outputs;
       bool operator==(const Data& rhs) const;
       bool operator!=(const Data& rhs) const;
       Data(const Data &other) = delete;
   
       virtual std::unique_ptr<MessageSpecialisationHandler> getSpecialisationHander(CUDAMessage &owner) const;
   
       virtual std::type_index getType() const;
   
    protected:
       virtual Data *clone(const std::shared_ptr<const ModelData> &newParent);
       Data(const std::shared_ptr<const ModelData> &, const Data &other);
       Data(const std::shared_ptr<const ModelData> &, const std::string &message_name);
   };
   
   class MessageBruteForce::Description {
       friend struct Data;
       friend class AgentFunctionDescription;
       // friend void AgentFunctionDescription::setMessageOutput(MessageBruteForce::Description&);
       // friend void AgentFunctionDescription::setMessageInput(MessageBruteForce::Description&);
   
    protected:
       Description(const std::shared_ptr<const ModelData> &_model, Data *const data);
       Description(const Description &other_message) = delete;
       Description(Description &&other_message) noexcept = delete;
       Description& operator=(const Description &other_message) = delete;
       Description& operator=(Description &&other_message) noexcept = delete;
   
    public:
       bool operator==(const Description& rhs) const;
       bool operator!=(const Description& rhs) const;
   
       template<typename T>
       void newVariable(const std::string &variable_name);
       template<typename T, MessageNone::size_type N>
       void newVariable(const std::string& variable_name);
   #ifdef SWIG
   
       template<typename T>
       void newVariableArray(const std::string& variable_name, const size_type& length);
   #endif
   
       std::string getName() const;
       const std::type_index& getVariableType(const std::string &variable_name) const;
       size_t getVariableSize(const std::string &variable_name) const;
       size_type getVariablesCount() const;
       bool hasVariable(const std::string &variable_name) const;
   
    protected:
       const std::weak_ptr<const ModelData> model;
       Data *const message;
   };
   template<typename T>
   void MessageBruteForce::Description::newVariable(const std::string &variable_name) {
       newVariable<T, 1>(variable_name);
   }
   template<typename T, MessageNone::size_type N>
   void MessageBruteForce::Description::newVariable(const std::string& variable_name) {
       if (!variable_name.empty() && variable_name[0] == '_') {
           THROW exception::ReservedName("Message variable names cannot begin with '_', this is reserved for internal usage, "
               "in MessageDescription::newVariable().");
       }
       // Array length 0 makes no sense
       static_assert(N > 0, "A variable cannot have 0 elements.");
       if (message->variables.find(variable_name) == message->variables.end()) {
           message->variables.emplace(variable_name, Variable(std::array<T, N>{}));
           return;
       }
       THROW exception::InvalidMessageVar("Message ('%s') already contains variable '%s', "
           "in MessageDescription::newVariable().",
           message->name.c_str(), variable_name.c_str());
   }
   #ifdef SWIG
   template<typename T>
   void MessageBruteForce::Description::newVariableArray(const std::string& variable_name, const size_type& length) {
       if (!variable_name.empty() && variable_name[0] == '_') {
           THROW exception::ReservedName("Message variable names cannot begin with '_', this is reserved for internal usage, "
               "in MessageDescription::newVariable().");
       }
       if (length == 0) {
           THROW exception::InvalidMessageVar("Message variable arrays must have a length greater than 0."
               "in MessageDescription::newVariable().");
       }
       if (message->variables.find(variable_name) == message->variables.end()) {
           std::vector<T> temp(static_cast<size_t>(length));
           message->variables.emplace(variable_name, Variable(length, temp));
           return;
       }
       THROW exception::InvalidMessageVar("Message ('%s') already contains variable '%s', "
           "in MessageDescription::newVariable().",
           message->name.c_str(), variable_name.c_str());
   }
   #endif
   
   }  // namespace flamegpu
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEBRUTEFORCE_MESSAGEBRUTEFORCEHOST_H_
