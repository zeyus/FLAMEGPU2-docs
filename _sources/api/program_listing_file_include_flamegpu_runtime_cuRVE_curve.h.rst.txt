
.. _program_listing_file_include_flamegpu_runtime_cuRVE_curve.h:

Program Listing for File curve.h
================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_cuRVE_curve.h>` (``include/flamegpu/runtime/cuRVE/curve.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_CURVE_CURVE_H_
   #define INCLUDE_FLAMEGPU_RUNTIME_CURVE_CURVE_H_
   
   // #include <cuda_runtime.h>
   
   #include <cstring>
   #include <cstdio>
   #ifndef __CUDACC_RTC__
   #include <mutex>
   #include <shared_mutex>
   #endif
   
   #include "flamegpu/exception/FGPUDeviceException.h"
   
   
   class Curve {
    public:
       static const int UNKNOWN_VARIABLE = -1;              // !< value returned as a Variable if an API function encounters an error
   
       typedef int                      Variable;           // !< Typedef for cuRVE variable handle
       typedef unsigned int             VariableHash;       // !< Typedef for cuRVE variable name string hash
       typedef unsigned int             NamespaceHash;      // !< Typedef for cuRVE variable namespace string hash
   
       enum DeviceError {
           DEVICE_ERROR_NO_ERRORS,                // !< No errors raised on the device
           DEVICE_ERROR_UNKNOWN_VARIABLE,         // !< A function has requested an unknown variable or a variable not registered in the current namespace
           DEVICE_ERROR_VARIABLE_DISABLED,        // !< A function has requested a variable which is disabled
           DEVICE_ERROR_UNKNOWN_TYPE,             // !< A function has requested an unknown type or a type not registered in the current namespace
           DEVICE_ERROR_UNKNOWN_LENGTH            // !< A function has requested an unknown vector length or the length not registered in the current namespace
       };
   
       enum HostError {
           ERROR_NO_ERRORS,                       // !< No errors raised by host API functions
           ERROR_UNKNOWN_VARIABLE,                // !< A host API function has requested an unknown variable or a variable not registered in the current namespace
           ERROR_TOO_MANY_VARIABLES               // !< The maximum number of curve variables has been reached
       };
   
       __host__ static VariableHash variableRuntimeHash(const char* str);
       __host__ static VariableHash variableRuntimeHash(unsigned int num);
   
       template <unsigned int N>
       __device__ __host__ __forceinline__ static VariableHash variableHash(const char(&str)[N]);
       __host__ Variable getVariableHandle(VariableHash variable_hash);
       __host__ Variable registerVariableByHash(VariableHash variable_hash, void* d_ptr, size_t size, unsigned int length);
       template <unsigned int N, typename T>
       __host__ Variable registerVariable(const char(&variableName)[N], void* d_ptr, unsigned int length);
       __host__ int size() const;
       __host__ void updateDevice();
       __host__ void unregisterVariableByHash(VariableHash variable_hash);
       template <unsigned int N>
       __host__ void unregisterVariable(const char(&variableName)[N]);
   
       __device__ __forceinline__ static Variable getVariable(const VariableHash variable_hash);
       __device__ __forceinline__ static size_t getVariableSize(const VariableHash variable_hash);
       __device__ __forceinline__ static unsigned int getVariableLength(const VariableHash variable_hash);
       __device__ __forceinline__ static void* getVariablePtrByHash(const VariableHash variable_hash, size_t offset);
       template <typename T>
       __device__ __forceinline__ static T getVariableByHash(const VariableHash variable_hash, unsigned int index);
       template <typename T>
       __device__ __forceinline__ static T getVariableByHash_ldg(const VariableHash variable_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getArrayVariableByHash(const VariableHash variable_hash, unsigned int agent_index, unsigned int array_index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getArrayVariableByHash_ldg(const VariableHash variable_hash, unsigned int agent_index, unsigned int array_index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getMessageVariable(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getAgentVariable_ldg(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getMessageVariable_ldg(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getAgentArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T>
       __device__ __forceinline__ static void setVariableByHash(const VariableHash variable_hash, T value, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setArrayVariableByHash(const VariableHash variable_hash, T value, unsigned int agent_index, unsigned int array_index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setMessageVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setNewAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static void setAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static void setNewAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int variable_index, unsigned int array_index);
   
       /* ERROR CHECKING API FUNCTIONS */
   
       __device__ __forceinline__ static void printLastDeviceError(const char* file, const char* function, const int line);
       void __host__ printLastHostError(const char* file, const char* function, const int line);
   
       void __host__ printErrors(const char* file, const char* function, const int line);
       __device__ __host__ __forceinline__ static const char*  getDeviceErrorString(DeviceError error_code);
       __host__ const char*  getHostErrorString(HostError error_code);
       __device__ __forceinline__ static DeviceError getLastDeviceError();
   
       __host__ HostError getLastHostError();
       __host__ void clearErrors();
       __host__ unsigned int checkHowManyMappedItems();
       static const int MAX_VARIABLES = 1024;          // !< Default maximum number of cuRVE variables (must be a power of 2)
       static const VariableHash EMPTY_FLAG = 0;
       static const VariableHash DELETED_FLAG = 1;
   
    private:
       __host__ int _size() const;
       __host__ Variable _registerVariableByHash(VariableHash variable_hash, void* d_ptr, size_t size, unsigned int length);
       __host__ void _unregisterVariableByHash(VariableHash variable_hash);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static void setVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getVariable(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N>
       __device__ __forceinline__ static T getVariable_ldg(const char(&variableName)[N], VariableHash namespace_hash, unsigned int index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static T getArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int variable_index, unsigned int array_index);
       template <typename T, unsigned int N, unsigned int M>
       __device__ __forceinline__ static void setArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int variable_index, unsigned int array_index);
       VariableHash h_hashes[MAX_VARIABLES];         // Host array of the hash values of registered variables
       void* h_d_variables[MAX_VARIABLES];           // Host array of pointer to device memory addresses for variable storage
       size_t h_sizes[MAX_VARIABLES];                // Host array of the sizes of registered variable types (Note: RTTI not supported in CUDA so this is the best we can do for now)
       unsigned int h_lengths[MAX_VARIABLES];        // Host array of the length of registered variables (i.e: vector length)
       bool deviceInitialised;                       // Flag indicating that curve has/hasn't been initialised yet on a device.
   
   #ifndef __CUDACC_RTC__
   
       mutable std::shared_timed_mutex mutex;
       std::shared_lock<std::shared_timed_mutex> getSharedLock() const { return std::shared_lock<std::shared_timed_mutex>(mutex); }
       std::unique_lock<std::shared_timed_mutex> getUniqueLock() const { return std::unique_lock<std::shared_timed_mutex>(mutex); }
   #endif
   
       void initialiseDevice();
       friend class CUDASimulation;
       __host__ void purge();
   
    protected:
       Curve();
   
    public:
   #ifndef __CUDACC_RTC__
   
       static Curve& getInstance();
       static std::mutex instance_mutex;
   #endif
   };
   
   
   namespace curve_internal {
       extern __constant__ Curve::VariableHash d_hashes[Curve::MAX_VARIABLES];   // Device array of the hash values of registered variables
       extern __device__ char* d_variables[Curve::MAX_VARIABLES];                // Device array of pointer to device memory addresses for variable storage
       extern __constant__ size_t d_sizes[Curve::MAX_VARIABLES];                // Device array of the types of registered variables
       extern __constant__ unsigned int d_lengths[Curve::MAX_VARIABLES];
   
       extern __device__ Curve::DeviceError d_curve_error;
       extern Curve::HostError h_curve_error;
   }  // namespace curve_internal
   
   
   /* TEMPLATE HASHING FUNCTIONS */
   
   template <unsigned int N, unsigned int I> struct CurveStringHash {
       __device__ __host__ inline static Curve::VariableHash Hash(const char (&str)[N]) {
           return (CurveStringHash<N, I-1>::Hash(str) ^ str[I-1])*16777619u;
       }
   };
   template <unsigned int N> struct CurveStringHash<N, 1> {
       __device__ __host__ inline static Curve::VariableHash Hash(const char (&str)[N]) {
           return (2166136261u ^ str[0])*16777619u;
       }
   };
   
   #ifndef __CUDACC_RTC__
   
   template <unsigned int N, typename T>
   __host__ Curve::Variable Curve::registerVariable(const char(&variableName)[N], void* d_ptr, unsigned int length) {
       auto lock = std::unique_lock<std::shared_timed_mutex>(mutex);
       VariableHash variable_hash = variableHash(variableName);
       size_t size = sizeof(T);
       return _registerVariableByHash(variable_hash, d_ptr, size, length);  // the const func can get const and non const argument (for 3rd argument)
   }
   template <unsigned int N>
   __host__ void Curve::unregisterVariable(const char(&variableName)[N]) {
       auto lock = std::unique_lock<std::shared_timed_mutex>(mutex);
       VariableHash variable_hash = variableHash(variableName);
       _unregisterVariableByHash(variable_hash);
   }
   #endif
   
   /* loop unrolling of hash collision detection */
   __device__ __forceinline__ Curve::Variable Curve::getVariable(const VariableHash variable_hash) {
       for (unsigned int x = 0; x< MAX_VARIABLES; x++) {
           const Variable i = ((variable_hash + x) & (MAX_VARIABLES - 1));
           const VariableHash h = curve_internal::d_hashes[i];
           if (h == variable_hash)
               return i;
       }
       return UNKNOWN_VARIABLE;
   }
   
   
   template <unsigned int N>
   __device__ __host__ __forceinline__ Curve::VariableHash Curve::variableHash(const char(&str)[N]) {
       return CurveStringHash<N, N>::Hash(str);
   }
   __device__ __forceinline__ size_t Curve::getVariableSize(const VariableHash variable_hash) {
       Variable cv;
   
       cv = getVariable(variable_hash);
   
       return curve_internal::d_sizes[cv];
   }
   __device__ __forceinline__ unsigned int Curve::getVariableLength(const VariableHash variable_hash) {
       Variable cv;
   
       cv = getVariable(variable_hash);
   
       return curve_internal::d_lengths[cv];
   }
   __device__ __forceinline__ void* Curve::getVariablePtrByHash(const VariableHash variable_hash, size_t offset) {
       Variable cv;
   
       cv = getVariable(variable_hash);
   #if !defined(SEATBELTS) || SEATBELTS
       // error checking
       if (cv == UNKNOWN_VARIABLE) {
           curve_internal::d_curve_error = DEVICE_ERROR_UNKNOWN_VARIABLE;
           return nullptr;
       }
   
       // check vector length
       if (offset > curve_internal::d_sizes[cv] * curve_internal::d_lengths[cv]) {  // Note : offset is basicly index * sizeof(T)
           curve_internal::d_curve_error = DEVICE_ERROR_UNKNOWN_LENGTH;
           return nullptr;
       }
   #endif
       // return a generic pointer to variable address for given offset (no bounds checking here!)
       return curve_internal::d_variables[cv] + offset;
   }
   template <typename T>
   __device__ __forceinline__ T Curve::getVariableByHash(const VariableHash variable_hash, unsigned int index) {
       size_t offset = index *sizeof(T);
   
   #if !defined(SEATBELTS) || SEATBELTS
       // do a check on the size as otherwise the value_ptr may eb out of bounds.
       size_t size = getVariableSize(variable_hash);
   
       // error checking
       if (size != sizeof(T)) {
           curve_internal::d_curve_error = DEVICE_ERROR_UNKNOWN_TYPE;
           return 0;
       }
   #endif
       // get a pointer to the specific variable by offsetting by the provided index
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
   
   #if !defined(SEATBELTS) || SEATBELTS
       if (!value_ptr)
           return 0;
   #endif
       return *value_ptr;
   }
   template <typename T>
   __device__ __forceinline__ T Curve::getVariableByHash_ldg(const VariableHash variable_hash, unsigned int index) {
       size_t offset = index *sizeof(T);
   
   #if !defined(SEATBELTS) || SEATBELTS
       // do a check on the size as otherwise the value_ptr may eb out of bounds.
       size_t size = getVariableSize(variable_hash);
   
       // error checking
       if (size != sizeof(T)) {
           curve_internal::d_curve_error = DEVICE_ERROR_UNKNOWN_TYPE;
           return NULL;
       }
   #endif
       // get a pointer to the specific variable by offsetting by the provided index
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
   
   #if !defined(SEATBELTS) || SEATBELTS
       if (!value_ptr)
           return 0;
   #endif
       return __ldg(value_ptr);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getArrayVariableByHash(const VariableHash variable_hash, unsigned int agent_index, unsigned int array_index) {
       // do a check on the size as otherwise the value_ptr may eb out of bounds.
       const size_t var_size = N * sizeof(T);
       // error checking
   #if !defined(SEATBELTS) || SEATBELTS
       const size_t size = getVariableSize(variable_hash);
       if (size != var_size) {
           curve_internal::d_curve_error = DEVICE_ERROR_UNKNOWN_TYPE;
           return NULL;
       }
   #endif
       const size_t offset = (agent_index * var_size) + (array_index * sizeof(T));
       // get a pointer to the specific variable by offsetting by the provided index
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
   
   #if !defined(SEATBELTS) || SEATBELTS
       if (!value_ptr)
           return 0;
   #endif
       return *value_ptr;
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getArrayVariableByHash_ldg(const VariableHash variable_hash, unsigned int agent_index, unsigned int array_index) {
       // do a check on the size as otherwise the value_ptr may eb out of bounds.
       const size_t var_size = N * sizeof(T);
       // error checking
   #if !defined(SEATBELTS) || SEATBELTS
       const size_t size = getVariableSize(variable_hash);
       if (size != var_size) {
           curve_internal::d_curve_error = DEVICE_ERROR_UNKNOWN_TYPE;
           return NULL;
       }
   #endif
       const size_t offset = (agent_index * var_size) + (array_index * sizeof(T));
       // get a pointer to the specific variable by offsetting by the provided index
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
   
   #if !defined(SEATBELTS) || SEATBELTS
       if (!value_ptr)
           return 0;
   #endif
       return __ldg(value_ptr);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getAgentVariable(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       return getVariable<T>(variableName, namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getMessageVariable(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       return getVariable<T>(variableName, namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getVariable(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable with name '%s' was not found.\n", variableName);
           } else if (curve_internal::d_sizes[cv] != sizeof(T)) {
               DTHROW("Curve variable with name '%s' type size mismatch %llu != %llu.\n", variableName, curve_internal::d_sizes[cv], sizeof(T));
           }
       }
   #endif
       return getVariableByHash<T>(variable_hash+namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getAgentVariable_ldg(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       return getVariable_ldg<T>(variableName, namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getMessageVariable_ldg(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       return getVariable_ldg<T>(variableName, namespace_hash, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ T Curve::getVariable_ldg(const char (&variableName)[N], VariableHash namespace_hash, unsigned int index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable with name '%s' was not found.\n", variableName);
           } else if (curve_internal::d_sizes[cv] != sizeof(T)) {
               DTHROW("Curve variable with name '%s' type size mismatch %llu != %llu.\n", variableName, curve_internal::d_sizes[cv], sizeof(T));
           }
       }
   #endif
       return getVariableByHash_ldg<T>(variable_hash+namespace_hash, index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int agent_index, unsigned int array_index) {
       return getArrayVariable<T, N>(variableName, namespace_hash, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, unsigned int agent_index, unsigned int array_index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable array with name '%s' was not found.\n", variableName);
           } else if (curve_internal::d_sizes[cv] != sizeof(T) * N) {
               DTHROW("Curve variable array with name '%s', type size mismatch %llu != %llu.\n", variableName, curve_internal::d_sizes[cv], sizeof(T) * N);
           }
       }
       if (array_index >= N) {
           DTHROW("Curve array index %u is out of bounds for variable with name '%s'.\n", array_index, variableName);
           return 0;
       }
   #endif
       // Curve currently doesn't store whether a variable is an array
       // Curve stores M * sizeof(T), so this is checked instead
       return getArrayVariableByHash<T, N>(variable_hash + namespace_hash, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getAgentArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int agent_index, unsigned int array_index) {
       return getArrayVariable_ldg<T, N>(variableName, namespace_hash, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ T Curve::getArrayVariable_ldg(const char(&variableName)[M], VariableHash namespace_hash, unsigned int agent_index, unsigned int array_index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable array with name '%s' was not found.\n", variableName);
           } else if (curve_internal::d_sizes[cv] != sizeof(T) * N) {
               DTHROW("Curve variable array with name '%s', type size mismatch %llu != %llu.\n", variableName, curve_internal::d_sizes[cv], sizeof(T) * N);
           }
       }
       if (array_index >= N) {
           DTHROW("Curve array index %u is out of bounds for variable with name '%s'.\n", array_index, variableName);
           return 0;
       }
   #endif
       // Curve currently doesn't store whether a variable is an array
       // Curve stores M * sizeof(T), so this is checked instead
       return getArrayVariableByHash_ldg<T, N>(variable_hash + namespace_hash, agent_index, array_index);
   }
   
   template <typename T>
   __device__ __forceinline__ void Curve::setVariableByHash(const VariableHash variable_hash, T variable, unsigned int index) {
   #if !defined(SEATBELTS) || SEATBELTS
       size_t size = getVariableSize(variable_hash);
       if (size != sizeof(T)) {
           curve_internal::d_curve_error = DEVICE_ERROR_UNKNOWN_TYPE;
           return;
       }
   #endif
       size_t offset = index *sizeof(T);
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
       *value_ptr = variable;
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setArrayVariableByHash(const VariableHash variable_hash, T variable, unsigned int agent_index, unsigned int array_index) {
       const size_t var_size = N * sizeof(T);
   #if !defined(SEATBELTS) || SEATBELTS
       const size_t size = getVariableSize(variable_hash);
       if (size != var_size) {
           curve_internal::d_curve_error = DEVICE_ERROR_UNKNOWN_TYPE;
           return;
       }
   #endif
       const size_t offset = (agent_index * var_size) + (array_index * sizeof(T));
       T *value_ptr = reinterpret_cast<T*>(getVariablePtrByHash(variable_hash, offset));
       *value_ptr = variable;
   }
   
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index) {
       setVariable<T>(variableName, namespace_hash, variable, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setMessageVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index) {
       setVariable<T>(variableName, namespace_hash, variable, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setNewAgentVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index) {
       setVariable<T>(variableName, namespace_hash, variable, index);
   }
   template <typename T, unsigned int N>
   __device__ __forceinline__ void Curve::setVariable(const char(&variableName)[N], VariableHash namespace_hash, T variable, unsigned int index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable with name '%s' was not found.\n", variableName);
           } else if (curve_internal::d_sizes[cv] != sizeof(T)) {
               DTHROW("Curve variable with name '%s', type size mismatch %llu != %llu.\n", variableName, curve_internal::d_sizes[cv], sizeof(T));
           }
       }
   #endif
       setVariableByHash<T>(variable_hash+namespace_hash, variable, index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ void Curve::setAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int agent_index, unsigned int array_index) {
       setArrayVariable<T, N>(variableName, namespace_hash, variable, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ void Curve::setNewAgentArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int agent_index, unsigned int array_index) {
       setArrayVariable<T, N>(variableName, namespace_hash, variable, agent_index, array_index);
   }
   template <typename T, unsigned int N, unsigned int M>
   __device__ __forceinline__ void Curve::setArrayVariable(const char(&variableName)[M], VariableHash namespace_hash, T variable, unsigned int agent_index, unsigned int array_index) {
       VariableHash variable_hash = variableHash(variableName);
   #if !defined(SEATBELTS) || SEATBELTS
       {
           const auto cv = getVariable(variable_hash+namespace_hash);
           if (cv ==  UNKNOWN_VARIABLE) {
               DTHROW("Curve variable array with name '%s' was not found.\n", variableName);
           } else if (curve_internal::d_sizes[cv] != sizeof(T) * N) {
               DTHROW("Curve variable array with name '%s', size mismatch %llu != %llu.\n", variableName, curve_internal::d_sizes[cv], sizeof(T) * N);
           }
       }
       if (array_index >= N) {
           DTHROW("Curve array index %u is out of bounds for variable with name '%s'.\n", array_index, variableName);
           return;
       }
   #endif
       // Curve currently doesn't store whether a variable is an array
       // Curve stores M * sizeof(T), so this is checked instead
       return setArrayVariableByHash<T, N>(variable_hash + namespace_hash, variable, agent_index, array_index);
   }
   
   /* ERROR CHECKING API FUNCTIONS */
   #define curveReportLastDeviceError() { Curve::curvePrintLastDeviceError(__FILE__, __FUNCTION__, __LINE__); }    // ! Prints the last reported device error using the file, function and line number of the call to this macro
   #define curveReportLastHostError() { curvePrintLastHostError(__FILE__, __FUNCTION__, __LINE__); }        // ! Prints the last reported host API error using the file, function and line number of the call to this macro
   #define curveReportErrors() { curvePrintErrors(__FILE__, __FUNCTION__, __LINE__); }  // ! Prints the last reported device or host API error using the file, function and line number of the call to this macro
   
   __device__ __forceinline__ void Curve::printLastDeviceError(const char* file, const char* function, const int line) {
       if (curve_internal::d_curve_error != DEVICE_ERROR_NO_ERRORS) {
           printf("%s.%s.%d: cuRVE Device Error %d (%s)\n", file, function, line, (unsigned int)curve_internal::d_curve_error, getDeviceErrorString(curve_internal::d_curve_error));
       }
   }
   __device__ __host__ __forceinline__ const char* Curve::getDeviceErrorString(DeviceError e) {
       switch (e) {
       case(DEVICE_ERROR_NO_ERRORS):
           return "No cuRVE errors";
       case(DEVICE_ERROR_UNKNOWN_VARIABLE):
           return "Unknown cuRVE variable in current namespace";
       case(DEVICE_ERROR_VARIABLE_DISABLED):
           return "cuRVE variable is disabled";
       default:
           return "Unspecified cuRVE error";
       }
   }
   __device__ __forceinline__ Curve::DeviceError Curve::getLastDeviceError() {
       return curve_internal::d_curve_error;
   }
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_CURVE_CURVE_H_
