
.. _program_listing_file_include_flamegpu_pop_MemoryVector.h:

Program Listing for File MemoryVector.h
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_pop_MemoryVector.h>` (``include/flamegpu/pop/MemoryVector.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   * MemoryVector.h
   *
   */
   
   #ifndef INCLUDE_FLAMEGPU_POP_MEMORYVECTOR_H_
   #define INCLUDE_FLAMEGPU_POP_MEMORYVECTOR_H_
   
   #include <vector>
   #include <typeindex>
   #include <map>
   #include <memory>
   #include <utility>
   #include <string>
   
   #include "flamegpu/exception/FGPUException.h"
   
   class GenericMemoryVector{
    public:
       virtual ~GenericMemoryVector() { }
   
       virtual const std::type_index& getType() const = 0;
   
       virtual unsigned int getElements() const = 0;
   
       virtual size_t getTypeSize() const = 0;
   
       virtual size_t getVariableSize() const = 0;
   
       virtual void* getDataPtr() = 0;
   
       virtual const void* getReadOnlyDataPtr() const = 0;
   
       virtual void* getVectorPtr() = 0;
   
       virtual GenericMemoryVector* clone() const = 0;
   
       virtual void resize(unsigned int) = 0;
   };
   
   template <typename T>
   class MemoryVector : public GenericMemoryVector {
    public:
       explicit MemoryVector(unsigned int _elements = 1)
       : GenericMemoryVector()
       , elements(_elements)
       , type(typeid(T))
       , type_size(sizeof(T)) { }
   
       virtual ~MemoryVector() { ; }
   
       const std::type_index& getType() const override {
           return type;
       }
       unsigned int getElements() const {
           return elements;
       }
       size_t getTypeSize() const {
           return type_size;
       }
       size_t getVariableSize() const {
           return type_size * elements;
       }
   
       void* getDataPtr() override {
           if (vec.empty())
               return nullptr;
           else
               return &(vec.front());
       }
   
       const void* getReadOnlyDataPtr() const override {
           if (vec.empty())
               return nullptr;
           else
               return &(vec.front());
       }
   
       virtual void* getVectorPtr() {
           return static_cast<void*>(&vec);
       }
   
       virtual MemoryVector<T>* clone() const {
           return (new MemoryVector<T>(elements));
       }
   
       void resize(unsigned int s) override {
           vec.resize(s * elements);
       }
   
    protected:
       const unsigned int elements;
       std::vector<T> vec;
       const std::type_index type;
       const size_t type_size;
   };
   
   // use this to store default values for a population, must be here to register the correct types at compile time
   typedef std::map<const std::string, std::unique_ptr<GenericMemoryVector>> StateMemoryMap;
   
   typedef std::pair<const std::string, std::unique_ptr<GenericMemoryVector>> StateMemoryMapPair;
   
   #endif  // INCLUDE_FLAMEGPU_POP_MEMORYVECTOR_H_
