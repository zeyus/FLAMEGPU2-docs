<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File CUDASimulation.cu &mdash; FLAME GPU 2 0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/flamegpu.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #4d4d4d" >
            <a href="../index.html" class="icon icon-home"> FLAME GPU 2
            <img src="../_static/flamegpu2-icon-notext-128.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart/index.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../quickstart/index.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quickstart/index.html#cuda-c">CUDA C++</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../quickstart/index.html#installation">Installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../quickstart/index.html#creating-a-new-project">Creating a new project</a></li>
<li class="toctree-l3"><a class="reference internal" href="../quickstart/index.html#compiling-your-project">Compiling your project</a></li>
<li class="toctree-l3"><a class="reference internal" href="../quickstart/index.html#running-your-project">Running your project</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../quickstart/index.html#python-3">Python 3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../quickstart/index.html#q-python-installation">Installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../quickstart/index.html#building-from-source">Building from source</a></li>
<li class="toctree-l3"><a class="reference internal" href="../quickstart/index.html#id2">Creating a new project</a></li>
<li class="toctree-l3"><a class="reference internal" href="../quickstart/index.html#id3">Running your project</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../guide/index.html">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../guide/1-meta/index.html">First Steps</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/1-meta/1-philosophy.html">FLAMEGPU2 Design Philosophy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../guide/1-meta/2-creating-project.html">Creating a Project</a></li>
<li class="toctree-l3"><a class="reference internal" href="../guide/1-meta/3-structure.html">Structure of a FLAMEGPU2 Program</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/1-meta/3-structure.html#agent-host-function-definitions">Agent/Host Function Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/1-meta/3-structure.html#model-declaration">Model Declaration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/1-meta/3-structure.html#initialisation">Initialisation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/1-meta/3-structure.html#execution">Execution</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/2-model-definition/index.html">Defining a Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/2-model-definition/1-model.html">Creating a Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/1-model.html#what-is-a-model">What is a Model?</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/1-model.html#creating-a-modeldescription-object">Creating a ModelDescription Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/1-model.html#more-info">More Info</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/2-model-definition/2-environment.html">Adding Environmental Properties</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/2-environment.html#what-is-an-environment">What is an Environment?</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/2-environment.html#creating-an-environmentdescription-object">Creating an EnvironmentDescription Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/2-environment.html#defining-environmental-properties">Defining Environmental Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/2-environment.html#macro-environmental-properties">Macro Environmental Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/2-environment.html#full-example-code-from-this-page">Full Example Code From This Page</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/2-environment.html#more-info">More Info</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/2-model-definition/3-agent.html">Defining Agents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/3-agent.html#defining-a-new-agent-type">Defining a New Agent Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/3-agent.html#agent-variables">Agent Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/3-agent.html#agent-array-variables">Agent Array Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/3-agent.html#agent-states">Agent States</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/3-agent.html#full-example-code-from-this-page">Full Example Code From This Page</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/2-model-definition/3-agent.html#more-info">More Info</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/3-behaviour-definition/index.html">Defining Behaviours</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/3-behaviour-definition/1-defining-agent-functions.html">Defining Agent Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/1-defining-agent-functions.html#what-is-an-agent-function">What is an Agent Function?</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/1-defining-agent-functions.html#defining-an-agent-function">Defining an Agent Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/1-defining-agent-functions.html#flamegpu-device-functions">FLAMEGPU Device Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/1-defining-agent-functions.html#flamegpu-host-device-functions">FLAMEGPU Host Device Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/1-defining-agent-functions.html#full-example-code-from-this-page">Full Example Code From This Page</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/1-defining-agent-functions.html#more-info">More Info</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/3-behaviour-definition/2-modifying-agent-variables.html">Modifying Agent Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../guide/3-behaviour-definition/3-interacting-with-environment.html">Interacting with the Environment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/3-interacting-with-environment.html#environment-properties">Environment Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/3-interacting-with-environment.html#environment-macro-properties">Environment Macro Properties</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/3-behaviour-definition/4-agent-communication.html">Agent Communication</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/4-agent-communication.html#defining-messages">Defining Messages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/4-agent-communication.html#sending-messages">Sending Messages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/4-agent-communication.html#reading-messages">Reading Messages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/3-behaviour-definition/5-conditional-behaviours.html">Conditional Behaviours</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/5-conditional-behaviours.html#agent-function-conditions">Agent Function Conditions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/3-behaviour-definition/6-host-functions.html">Host Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/6-host-functions.html#defining-host-functions">Defining Host Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/6-host-functions.html#adding-host-functions-to-a-model">Adding Host Functions to a Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/3-behaviour-definition/6-host-functions.html#writing-host-functions">Writing Host Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/4-initial-conditions/index.html">Initial Conditions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/4-initial-conditions/1-agent-populations.html">Agent Populations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/4-initial-conditions/1-agent-populations.html#creating-an-agent-population">Creating an Agent Population</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/4-initial-conditions/2-initial-properties.html">Initialising Agent Variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/4-initial-conditions/2-initial-properties.html#initialising-a-population">Initialising a Population</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/4-initial-conditions/2-initial-properties.html#accessing-a-single-agent">Accessing a Single Agent</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/4-initial-conditions/4-rng-seeds.html">Random Number Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../guide/4-initial-conditions/5-from-disk.html">Initialisation from Disk</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/5-running-a-sim/index.html">Running a Simulation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/5-running-a-sim/1-defining-execution-order.html">Defining Execution Order</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/1-defining-execution-order.html#specifying-dependencies">Specifying Dependencies</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/1-defining-execution-order.html#accessing-the-dependencygraph">Accessing the DependencyGraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/1-defining-execution-order.html#specifying-roots">Specifying Roots</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/1-defining-execution-order.html#generating-layers">Generating Layers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/1-defining-execution-order.html#visualising-the-dependencies">Visualising the Dependencies</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/1-defining-execution-order.html#manual-layer-specification">Manual Layer Specification</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/5-running-a-sim/2-launching-a-sim.html">Launching a Simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../guide/5-running-a-sim/3-end-conditions.html">Simulation Exit Conditions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/3-end-conditions.html#max-steps">Max Steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/3-end-conditions.html#conditional-exit">Conditional Exit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/5-running-a-sim/4-collecting-data.html">Collecting Data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/4-collecting-data.html#configuring-data-to-be-collected">Configuring Data to be Collected</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/4-collecting-data.html#accessing-collected-data">Accessing Collected Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/4-collecting-data.html#writing-collected-data-to-file">Writing Collected Data to File</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/4-collecting-data.html#accessing-the-complete-agent-state">Accessing the Complete Agent State</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/5-running-a-sim/4-collecting-data.html#additional-notes">Additional Notes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/6-agent-birth-death/index.html">Agent Birth/Death</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/6-agent-birth-death/1-agent-birth-device.html">Agent Birth from Agent Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/6-agent-birth-death/1-agent-birth-device.html#agent-creation-overview">Agent Creation Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/6-agent-birth-death/1-agent-birth-device.html#enabling-agent-creation">Enabling Agent Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/6-agent-birth-death/1-agent-birth-device.html#creating-the-new-agent">Creating the New Agent</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/6-agent-birth-death/1-agent-birth-device.html#conditional-agent-creation">Conditional Agent Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/6-agent-birth-death/1-agent-birth-device.html#full-example-code-from-this-page">Full Example Code From This Page</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/6-agent-birth-death/1-agent-birth-device.html#more-info">More Info</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/6-agent-birth-death/2-agent-birth-host.html">Agent Birth from Host Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../guide/6-agent-birth-death/3-agent-death.html">Agent Death</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/6-agent-birth-death/3-agent-death.html#enabling-agent-death">Enabling Agent Death</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/6-agent-birth-death/3-agent-death.html#id1">Agent Death</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/6-agent-birth-death/3-agent-death.html#more-info">More Info</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/7-submodels/index.html">Submodels</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/7-submodels/1-defining-a-submodel.html">Defining a Submodel</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/7-submodels/1-defining-a-submodel.html#submodel-definition">Submodel Definition</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/8-running-multiple-sims/index.html">Running Multiple Simulations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/8-running-multiple-sims/4-multiple-sims.html">Launching Ensembles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/9-visualisation/index.html">Visualisation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/9-visualisation/1-building-with-vis.html">Building with Visualisation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/1-building-with-vis.html#default-visualisation">Default Visualisation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/9-visualisation/2-setting-up-vis.html">Configuring a Visualisation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/2-setting-up-vis.html#visualisation-options">Visualisation Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/2-setting-up-vis.html#visualising-after-simulation-exit">Visualising After Simulation Exit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/9-visualisation/3-visualising-agents.html">Visualising Agents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/3-visualising-agents.html#agent-model">Agent Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/3-visualising-agents.html#agent-position">Agent Position</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/3-visualising-agents.html#agent-direction">Agent Direction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/3-visualising-agents.html#agent-scale">Agent Scale</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/3-visualising-agents.html#agent-color">Agent Color</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/3-visualising-agents.html#agent-states">Agent States</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/9-visualisation/4-adding-details.html">Visualising Additional Details</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/4-adding-details.html#lines">Lines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/9-visualisation/4-adding-details.html#models">Models</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../guide/9-visualisation/5-visualisation-controls.html">Visualisation Controls</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/10-performance-troubleshooting/index.html">Performance Troubleshooting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/10-performance-troubleshooting/1-perf.html">Performance Troubleshooting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide/11-flamegpu2-source/index.html">Building or Modifying the FLAMEGPU Source</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../guide/11-flamegpu2-source/1-build-from-source.html">Building FLAME GPU from Source</a></li>
<li class="toctree-l3"><a class="reference internal" href="../guide/11-flamegpu2-source/2-request-a-new-feature.html">Requesting Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../guide/11-flamegpu2-source/3-contribute.html">Contributing to FLAMEGPU2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../guide/11-flamegpu2-source/3-contribute.html#reporting-bugs">Reporting Bugs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/11-flamegpu2-source/3-contribute.html#submitting-pull-requests">Submitting Pull Requests</a></li>
<li class="toctree-l4"><a class="reference internal" href="../guide/11-flamegpu2-source/3-contribute.html#license">License</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="library_root.html#page-hierarchy">Page Hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="library_root.html#class-hierarchy">Class Hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="library_root.html#file-hierarchy">File Hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="library_root.html#full-api">Full API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#namespaces">Namespaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu.html">Namespace flamegpu</a></li>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu__%40154.html">Namespace flamegpu::&#64;154</a></li>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu__exception.html">Namespace flamegpu::exception</a></li>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu__io.html">Namespace flamegpu::io</a></li>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu__util.html">Namespace flamegpu::util</a></li>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu__util__nvtx.html">Namespace flamegpu::util::nvtx</a></li>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu__visualiser.html">Namespace flamegpu::visualiser</a></li>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu__visualiser__Stock.html">Namespace flamegpu::visualiser::Stock</a></li>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu__visualiser__Stock__Colors.html">Namespace flamegpu::visualiser::Stock::Colors</a></li>
<li class="toctree-l4"><a class="reference internal" href="namespace_flamegpu__visualiser__Stock__Palettes.html">Namespace flamegpu::visualiser::Stock::Palettes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#classes-and-structs">Classes and Structs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1AgentData.html">Struct AgentData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1AgentFunctionData.html">Struct AgentFunctionData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1AgentLogFrame.html">Struct AgentLogFrame</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1AgentVariable.html">Struct AgentVariable</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1AgentVariableHash.html">Struct AgentVariableHash</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAEnsemble_1_1EnsembleConfig.html">Struct CUDAEnsemble::EnsembleConfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAFatAgent_1_1AgentState.html">Struct CUDAFatAgent::AgentState</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAFatAgent_1_1AgentState__hash.html">Struct CUDAFatAgent::AgentState_hash</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAFatAgent_1_1NewBuffer.html">Struct CUDAFatAgent::NewBuffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAMacroEnvironment_1_1MacroEnvProp.html">Struct CUDAMacroEnvironment::MacroEnvProp</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAScanCompactionConfig.html">Struct CUDAScanCompactionConfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAScanCompactionPtrs.html">Struct CUDAScanCompactionPtrs</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAScatter_1_1InversionIterator.html">Struct CUDAScatter::InversionIterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAScatter_1_1ScatterData.html">Struct CUDAScatter::ScatterData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDAScatter_1_1StreamData.html">Struct CUDAScatter::StreamData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDASimulation_1_1Config.html">Struct CUDASimulation::Config</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1CUDASimulation_1_1Singletons.html">Struct CUDASimulation::Singletons</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1DeviceAgentVector__impl_1_1VariableBufferPair.html">Struct DeviceAgentVector_impl::VariableBufferPair</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1EnvironmentDescription_1_1MacroPropData.html">Struct EnvironmentDescription::MacroPropData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1EnvironmentDescription_1_1PropData.html">Struct EnvironmentDescription::PropData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1EnvironmentManager_1_1DefragProp.html">Struct EnvironmentManager::DefragProp</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1EnvironmentManager_1_1EnvProp.html">Struct EnvironmentManager::EnvProp</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1EnvironmentManager_1_1EnvUpdateFlags.html">Struct EnvironmentManager::EnvUpdateFlags</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1EnvironmentManager_1_1MappedProp.html">Struct EnvironmentManager::MappedProp</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1EnvironmentManager_1_1NamePairHash.html">Struct EnvironmentManager::NamePairHash</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1EnvironmentManager_1_1RTCEnvPropCache.html">Struct EnvironmentManager::RTCEnvPropCache</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1exception_1_1DeviceExceptionBuffer.html">Struct DeviceExceptionBuffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1HostAPI_1_1key__hash.html">Struct HostAPI::key_hash</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1HostMacroProperty__MetaData.html">Struct HostMacroProperty_MetaData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1LayerData.html">Struct LayerData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1LogFrame.html">Struct LogFrame</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1LoggingConfig_1_1NameReductionFn.html">Struct LoggingConfig::NameReductionFn</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageArray2D_1_1Data.html">Struct MessageArray2D::Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageArray2D_1_1MetaData.html">Struct MessageArray2D::MetaData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageArray3D_1_1Data.html">Struct MessageArray3D::Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageArray3D_1_1MetaData.html">Struct MessageArray3D::MetaData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageArray_1_1Data.html">Struct MessageArray::Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageArray_1_1MetaData.html">Struct MessageArray::MetaData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageBruteForce_1_1Data.html">Struct MessageBruteForce::Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageBruteForce_1_1MetaData.html">Struct MessageBruteForce::MetaData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageBucket_1_1Data.html">Struct MessageBucket::Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageBucket_1_1MetaData.html">Struct MessageBucket::MetaData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageSpatial2D_1_1Data.html">Struct MessageSpatial2D::Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageSpatial2D_1_1GridPos2D.html">Struct MessageSpatial2D::GridPos2D</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageSpatial2D_1_1MetaData.html">Struct MessageSpatial2D::MetaData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageSpatial3D_1_1Data.html">Struct MessageSpatial3D::Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageSpatial3D_1_1GridPos3D.html">Struct MessageSpatial3D::GridPos3D</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1MessageSpatial3D_1_1MetaData.html">Struct MessageSpatial3D::MetaData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1ModelData.html">Struct ModelData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1NewAgentStorage.html">Struct NewAgentStorage</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1RunLog.html">Struct RunLog</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1Simulation_1_1Config.html">Struct Simulation::Config</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1SubAgentData.html">Struct SubAgentData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1SubEnvironmentData.html">Struct SubEnvironmentData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1SubModelData.html">Struct SubModelData</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t.html">Template Struct sum_input_t</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01char_01_4.html">Template Struct sum_input_t&lt; char &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01double_01_4.html">Template Struct sum_input_t&lt; double &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01float_01_4.html">Template Struct sum_input_t&lt; float &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01int16__t_01_4.html">Template Struct sum_input_t&lt; int16_t &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01int32__t_01_4.html">Template Struct sum_input_t&lt; int32_t &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01int64__t_01_4.html">Template Struct sum_input_t&lt; int64_t &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01int8__t_01_4.html">Template Struct sum_input_t&lt; int8_t &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01uint16__t_01_4.html">Template Struct sum_input_t&lt; uint16_t &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01uint32__t_01_4.html">Template Struct sum_input_t&lt; uint32_t &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01uint64__t_01_4.html">Template Struct sum_input_t&lt; uint64_t &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1sum__input__t_3_01uint8__t_01_4.html">Template Struct sum_input_t&lt; uint8_t &gt;</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1util_1_1Any.html">Struct Any</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1util_1_1StringPairHash.html">Struct StringPairHash</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1util_1_1StringUint32PairHash.html">Struct StringUint32PairHash</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1Variable.html">Struct Variable</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1VariableBuffer.html">Struct VariableBuffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1VarOffsetStruct.html">Struct VarOffsetStruct</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1VarOffsetStruct_1_1OffsetLen.html">Struct VarOffsetStruct::OffsetLen</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Color.html">Struct Color</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Palette.html">Struct Palette</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1Dark2.html">Struct Dark2</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1Greys.html">Struct Greys</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1Pastel.html">Struct Pastel</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1PiYG.html">Struct PiYG</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1RdYlBu.html">Struct RdYlBu</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1Set1.html">Struct Set1</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1Set2.html">Struct Set2</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1Viridis.html">Struct Viridis</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1YlGn.html">Struct YlGn</a></li>
<li class="toctree-l4"><a class="reference internal" href="structflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1_1YlOrRd.html">Struct YlOrRd</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentDescription.html">Class AgentDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentFunctionDescription.html">Class AgentFunctionDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentInstance.html">Class AgentInstance</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentInterface.html">Class AgentInterface</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentLoggingConfig.html">Class AgentLoggingConfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentRandom.html">Class AgentRandom</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentVector.html">Class AgentVector</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentVector_1_1const__iterator.html">Class AgentVector::const_iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentVector_1_1const__reverse__iterator.html">Class AgentVector::const_reverse_iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentVector_1_1iterator.html">Class AgentVector::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentVector_1_1reverse__iterator.html">Class AgentVector::reverse_iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentVector__Agent.html">Class AgentVector_Agent</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1AgentVector__CAgent.html">Class AgentVector_CAgent</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAAgent.html">Class CUDAAgent</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAAgentStateList.html">Class CUDAAgentStateList</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAEnsemble.html">Class CUDAEnsemble</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAFatAgent.html">Class CUDAFatAgent</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAFatAgentStateList.html">Class CUDAFatAgentStateList</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAMacroEnvironment.html">Class CUDAMacroEnvironment</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAMessage.html">Class CUDAMessage</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAMessageList.html">Class CUDAMessageList</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAScanCompaction.html">Class CUDAScanCompaction</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDAScatter.html">Class CUDAScatter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1CUDASimulation.html">Class CUDASimulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1DependencyGraph.html">Class DependencyGraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1DependencyNode.html">Class DependencyNode</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1DeviceAgentVector__impl.html">Class DeviceAgentVector_impl</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1DeviceAPI.html">Template Class DeviceAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1DeviceAPI_1_1AgentOut.html">Class DeviceAPI::AgentOut</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1DeviceEnvironment.html">Class DeviceEnvironment</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1DeviceMacroProperty.html">Template Class DeviceMacroProperty</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1EnvironmentDescription.html">Class EnvironmentDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1EnvironmentManager.html">Class EnvironmentManager</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1AgentIDCollision.html">Class AgentIDCollision</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1ArrayMessageWriteConflict.html">Class ArrayMessageWriteConflict</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1CUDAError.html">Class CUDAError</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1CurveException.html">Class CurveException</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1DeviceError.html">Class DeviceError</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1DeviceException.html">Class DeviceException</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1DeviceExceptionManager.html">Class DeviceExceptionManager</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1DifferentModel.html">Class DifferentModel</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1DuplicateEnvProperty.html">Class DuplicateEnvProperty</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1EnvDescriptionAlreadyLoaded.html">Class EnvDescriptionAlreadyLoaded</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1ExpiredWeakPtr.html">Class ExpiredWeakPtr</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1FLAMEGPUException.html">Class FLAMEGPUException</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidAgent.html">Class InvalidAgent</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidAgentFunc.html">Class InvalidAgentFunc</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidAgentName.html">Class InvalidAgentName</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidAgentState.html">Class InvalidAgentState</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidAgentVar.html">Class InvalidAgentVar</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidArgument.html">Class InvalidArgument</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidCudaAgent.html">Class InvalidCudaAgent</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidCudaAgentDesc.html">Class InvalidCudaAgentDesc</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidCudaAgentMapSize.html">Class InvalidCudaAgentMapSize</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidCudaAgentState.html">Class InvalidCudaAgentState</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidCUDAComputeCapability.html">Class InvalidCUDAComputeCapability</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidCUDAdevice.html">Class InvalidCUDAdevice</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidCudaMessage.html">Class InvalidCudaMessage</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidDependencyGraph.html">Class InvalidDependencyGraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidEnvProperty.html">Class InvalidEnvProperty</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidEnvPropertyType.html">Class InvalidEnvPropertyType</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidFilePath.html">Class InvalidFilePath</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidFuncLayerIndx.html">Class InvalidFuncLayerIndx</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidHostFunc.html">Class InvalidHostFunc</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidInputFile.html">Class InvalidInputFile</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidLayerMember.html">Class InvalidLayerMember</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidMemoryCapacity.html">Class InvalidMemoryCapacity</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidMessage.html">Class InvalidMessage</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidMessageData.html">Class InvalidMessageData</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidMessageName.html">Class InvalidMessageName</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidMessageType.html">Class InvalidMessageType</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidMessageVar.html">Class InvalidMessageVar</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidOperation.html">Class InvalidOperation</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidParent.html">Class InvalidParent</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidStateName.html">Class InvalidStateName</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidSubAgentName.html">Class InvalidSubAgentName</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidSubModel.html">Class InvalidSubModel</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidSubModelName.html">Class InvalidSubModelName</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidVarArrayLen.html">Class InvalidVarArrayLen</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1InvalidVarType.html">Class InvalidVarType</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1OutOfBoundsException.html">Class OutOfBoundsException</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1OutOfMemory.html">Class OutOfMemory</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1OutOfRangeVarArray.html">Class OutOfRangeVarArray</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1RapidJSONError.html">Class RapidJSONError</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1ReadOnlyEnvProperty.html">Class ReadOnlyEnvProperty</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1ReservedName.html">Class ReservedName</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1TimerException.html">Class TimerException</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1TinyXMLError.html">Class TinyXMLError</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1UnknownError.html">Class UnknownError</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1UnknownInternalError.html">Class UnknownInternalError</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1UnsupportedFileType.html">Class UnsupportedFileType</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1UnsupportedVarType.html">Class UnsupportedVarType</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1VersionMismatch.html">Class VersionMismatch</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1exception_1_1VisualisationException.html">Class VisualisationException</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1HostAgentAPI.html">Class HostAgentAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1HostAPI.html">Class HostAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1HostEnvironment.html">Class HostEnvironment</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1HostFunctionCallback.html">Class HostFunctionCallback</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1HostFunctionConditionCallback.html">Class HostFunctionConditionCallback</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1HostFunctionDescription.html">Class HostFunctionDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1HostMacroProperty.html">Template Class HostMacroProperty</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1HostNewAgentAPI.html">Class HostNewAgentAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1HostRandom.html">Class HostRandom</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1JSONLogger.html">Class JSONLogger</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1JSONStateReader.html">Class JSONStateReader</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1JSONStateReader__agentsize__counter.html">Class JSONStateReader_agentsize_counter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1JSONStateReader__impl.html">Class JSONStateReader_impl</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1JSONStateWriter.html">Class JSONStateWriter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1Logger.html">Class Logger</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1LoggerFactory.html">Class LoggerFactory</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1StateReader.html">Class StateReader</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1StateReaderFactory.html">Class StateReaderFactory</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1StateWriter.html">Class StateWriter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1StateWriterFactory.html">Class StateWriterFactory</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1XMLLogger.html">Class XMLLogger</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1XMLStateReader.html">Class XMLStateReader</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1io_1_1XMLStateWriter.html">Class XMLStateWriter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1LayerDescription.html">Class LayerDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1LoggingConfig.html">Class LoggingConfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray.html">Class MessageArray</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D.html">Class MessageArray2D</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1CUDAModelHandler.html">Class MessageArray2D::CUDAModelHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1Description.html">Class MessageArray2D::Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1In.html">Class MessageArray2D::In</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1In_1_1Filter.html">Class In::Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1In_1_1Filter_1_1iterator.html">Class Filter::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1In_1_1Filter_1_1Message.html">Class Filter::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1In_1_1Message.html">Class In::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1In_1_1WrapFilter.html">Class In::WrapFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1In_1_1WrapFilter_1_1iterator.html">Class WrapFilter::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1In_1_1WrapFilter_1_1Message.html">Class WrapFilter::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray2D_1_1Out.html">Class MessageArray2D::Out</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D.html">Class MessageArray3D</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1CUDAModelHandler.html">Class MessageArray3D::CUDAModelHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1Description.html">Class MessageArray3D::Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1In.html">Class MessageArray3D::In</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1In_1_1Filter.html">Class In::Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1In_1_1Filter_1_1iterator.html">Class Filter::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1In_1_1Filter_1_1Message.html">Class Filter::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1In_1_1Message.html">Class In::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1In_1_1WrapFilter.html">Class In::WrapFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1In_1_1WrapFilter_1_1iterator.html">Class WrapFilter::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1In_1_1WrapFilter_1_1Message.html">Class WrapFilter::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray3D_1_1Out.html">Class MessageArray3D::Out</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1CUDAModelHandler.html">Class MessageArray::CUDAModelHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1Description.html">Class MessageArray::Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1In.html">Class MessageArray::In</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1In_1_1Filter.html">Class In::Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1In_1_1Filter_1_1iterator.html">Class Filter::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1In_1_1Filter_1_1Message.html">Class Filter::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1In_1_1Message.html">Class In::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1In_1_1WrapFilter.html">Class In::WrapFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1In_1_1WrapFilter_1_1iterator.html">Class WrapFilter::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1In_1_1WrapFilter_1_1Message.html">Class WrapFilter::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageArray_1_1Out.html">Class MessageArray::Out</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBruteForce.html">Class MessageBruteForce</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBruteForce_1_1CUDAModelHandler.html">Class MessageBruteForce::CUDAModelHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBruteForce_1_1Description.html">Class MessageBruteForce::Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBruteForce_1_1In.html">Class MessageBruteForce::In</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBruteForce_1_1In_1_1iterator.html">Class In::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBruteForce_1_1In_1_1Message.html">Class In::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBruteForce_1_1Out.html">Class MessageBruteForce::Out</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBucket.html">Class MessageBucket</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBucket_1_1CUDAModelHandler.html">Class MessageBucket::CUDAModelHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBucket_1_1Description.html">Class MessageBucket::Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBucket_1_1In.html">Class MessageBucket::In</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBucket_1_1In_1_1Filter.html">Class In::Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBucket_1_1In_1_1Filter_1_1iterator.html">Class Filter::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBucket_1_1In_1_1Filter_1_1Message.html">Class Filter::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageBucket_1_1Out.html">Class MessageBucket::Out</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageNone.html">Class MessageNone</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageNone_1_1CUDAModelHandler.html">Class MessageNone::CUDAModelHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageNone_1_1In.html">Class MessageNone::In</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageNone_1_1Out.html">Class MessageNone::Out</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial2D.html">Class MessageSpatial2D</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial2D_1_1CUDAModelHandler.html">Class MessageSpatial2D::CUDAModelHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial2D_1_1Description.html">Class MessageSpatial2D::Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial2D_1_1In.html">Class MessageSpatial2D::In</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial2D_1_1In_1_1Filter.html">Class In::Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial2D_1_1In_1_1Filter_1_1iterator.html">Class Filter::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial2D_1_1In_1_1Filter_1_1Message.html">Class Filter::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial2D_1_1Out.html">Class MessageSpatial2D::Out</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial3D.html">Class MessageSpatial3D</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial3D_1_1CUDAModelHandler.html">Class MessageSpatial3D::CUDAModelHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial3D_1_1Description.html">Class MessageSpatial3D::Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial3D_1_1In.html">Class MessageSpatial3D::In</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial3D_1_1In_1_1Filter.html">Class In::Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial3D_1_1In_1_1Filter_1_1iterator.html">Class Filter::iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial3D_1_1In_1_1Filter_1_1Message.html">Class Filter::Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpatial3D_1_1Out.html">Class MessageSpatial3D::Out</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1MessageSpecialisationHandler.html">Class MessageSpecialisationHandler</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1ModelDescription.html">Class ModelDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1RandomManager.html">Class RandomManager</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1ReadOnlyDeviceAPI.html">Class ReadOnlyDeviceAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1ReadOnlyDeviceEnvironment.html">Class ReadOnlyDeviceEnvironment</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1ReadOnlyDeviceMacroProperty.html">Template Class ReadOnlyDeviceMacroProperty</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1RunPlan.html">Class RunPlan</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1RunPlanVector.html">Class RunPlanVector</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1SimLogger.html">Class SimLogger</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1SimRunner.html">Class SimRunner</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1Simulation.html">Class Simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1StepLoggingConfig.html">Class StepLoggingConfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1SubAgentDescription.html">Class SubAgentDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1SubEnvironmentDescription.html">Class SubEnvironmentDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1SubModelDescription.html">Class SubModelDescription</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1util_1_1nvtx_1_1NVTXRange.html">Class NVTXRange</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1AgentStateVis.html">Class AgentStateVis</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1AgentVis.html">Class AgentVis</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1AutoPalette.html">Class AutoPalette</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1ColorFunction.html">Class ColorFunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1DiscreteColor.html">Template Class DiscreteColor</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1HSVInterpolation.html">Class HSVInterpolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1LineVis.html">Class LineVis</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1ModelVis.html">Class ModelVis</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1Palette_1_1const__iterator.html">Class Palette::const_iterator</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1StaticColor.html">Class StaticColor</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1StaticModelVis.html">Class StaticModelVis</a></li>
<li class="toctree-l4"><a class="reference internal" href="classflamegpu_1_1visualiser_1_1ViridisInterpolation.html">Class ViridisInterpolation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#enums">Enums</a><ul>
<li class="toctree-l4"><a class="reference internal" href="enum_namespaceflamegpu_1a1adc39b89f4a6045c011c55a91339e4c.html">Enum AGENT_STATUS</a></li>
<li class="toctree-l4"><a class="reference internal" href="enum_namespaceflamegpu_1a2f06e5efd2a057b11a2fb53e711c443a.html">Enum CONDITION_RESULT</a></li>
<li class="toctree-l4"><a class="reference internal" href="enum_namespaceflamegpu_1a167df7c66e4cd9ff9a0fbc124d6a4825.html">Enum MessageSortingType</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1ad0783b09357d94b0e6164fe7047ca661.html">Template Function flamegpu::agent_function_condition_wrapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a643b1b7d842763420a871b5ad01cde07.html">Template Function flamegpu::agent_function_wrapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a5fa1624859f6fef19656f12c5cf23124.html">Function flamegpu::allocateIDs</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a0e9933d8e92fc85b481c5ffcec96e4c5.html">Function flamegpu::atomicHistogram1D</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a62702550faacab131476f2f0fd42b15d.html">Function flamegpu::atomicHistogram2D</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1ab142b7f3311b4d53df2ec36802361c18.html">Function flamegpu::atomicHistogram3D</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a372e103ba46c067bc0f68a2a103b90b1.html">Function flamegpu::broadcastInitKernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1ab6b7cc2d61ad5fc6ef4f30962f0e1c0c.html">Function flamegpu::calculateSpatialHash</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a8e4c805fb1a16187e4a86a8dc7ced84d.html">Function flamegpu::generateCollisionFlags</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a5b21b0ec7c8afea544e7fee29d2a0e7f.html">Template Function flamegpu::getAgentVariableMaxFunc</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a451011c85abe5de4e9497e29ccf8ffdb.html">Template Function flamegpu::getAgentVariableMeanFunc</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a083ca13c3f24c050c137312fbd4ef6a8.html">Template Function flamegpu::getAgentVariableMinFunc</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1aaefedcfe801f1afde9d49fda31de4bfc.html">Template Function flamegpu::getAgentVariableStandardDevFunc</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a0cdae124d116e9ae414cf82e168aa147.html">Template Function flamegpu::getAgentVariableSumFunc</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1aef3737bc73df02c3cacdfe023e540fda.html">Function flamegpu::getGridPosition2D</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1af8bd0c23b13150691a8075e10e315df8.html">Function flamegpu::getGridPosition3D</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1ac19244e95de615218572437593f6f366.html">Function flamegpu::getHash2D</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1aecff32308539a40d36081f141c5bcee3.html">Function flamegpu::getHash3D</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1ae83605c416211185d6408b08d3758ea6.html">Function flamegpu::init_curand</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a7a197dc32a2a7d5896c0e6f7159dd065.html">Function flamegpu::initToThreadIndex</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a580dd14f3e500d19284a204cc56cb96e.html">Function flamegpu::pbm_reorder_generic</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a529cbc02e5f6ba21c809fc4f858fe082.html">Function flamegpu::reorder_array_messages</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a728cd4b44037b620e529e3a548ea5494.html">Function flamegpu::scatter_all_generic</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a844df115c40ca91356e95f37b37f5072.html">Template Function flamegpu::scatter_generic</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a234b5ec14c0009cdce8001a6bc08bf85.html">Function flamegpu::scatter_new_agents</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1aca5e4a678eafc6ca26d5ff6e3239503c.html">Function flamegpu::scatter_position_generic</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a39c5c7fb5befdc5ea64afdb4e97f0e60.html">Function flamegpu::sortBuffer_kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1a44d39ffe8c5917018e1090545cf6cbf9.html">Function flamegpu::spatialSortInitToThreadIndex</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1_1util_1_1nvtx_1af0b150530f56beedbdd1b0dff603f869.html">Function flamegpu::util::nvtx::pop</a></li>
<li class="toctree-l4"><a class="reference internal" href="function_namespaceflamegpu_1_1util_1_1nvtx_1ae4d84b8b9f557577d74b2545dc8213f1.html">Function flamegpu::util::nvtx::push</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#variables">Variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1ae222c3a1e48085efbe98bf734bf18c47.html">Variable flamegpu::ID_NOT_SET</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1ae2461128afe905a603afcb7877188f29.html">Variable flamegpu::ID_VARIABLE_NAME</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1util_1_1nvtx_1af78944ce056f56e9d4c1df7d773792bf.html">Variable flamegpu::util::nvtx::colourCount</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1util_1_1nvtx_1a0302736e3c60407a5ba2aeeee9415a6f.html">Variable flamegpu::util::nvtx::palette</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1afe3afceec4bb90c840ea5482d7b07a97.html">Variable flamegpu::VERSION</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1abf99fff85270c03559c6846ce15c254f.html">Variable flamegpu::VERSION_BUILDMETADATA</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1ab2825ce1960a77bc8afbbd98b6305a44.html">Variable flamegpu::VERSION_FULL</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1ac29d48311f0cba829d4603734ba14450.html">Variable flamegpu::VERSION_MAJOR</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1abeeb7b039bde639c7627990c5f62e83d.html">Variable flamegpu::VERSION_MINOR</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1a6c1bfc357e2e82b0e575ec2b5b6a33f5.html">Variable flamegpu::VERSION_PATCH</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1a069e154449fb7dd97a34bc531ed9298c.html">Variable flamegpu::VERSION_PRERELEASE</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1a3afacc122b436ea9ab35959b1a8eff0f.html">Variable flamegpu::VERSION_STRING</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Colors_1a591a2e09088968ef4e9549ade22b5333.html">Variable flamegpu::visualiser::Stock::Colors::BLACK</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Colors_1a00e6f044ffe65490ec534820dc711801.html">Variable flamegpu::visualiser::Stock::Colors::BLUE</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Colors_1aad8474812ca5c495e3d427bac61c1065.html">Variable flamegpu::visualiser::Stock::Colors::GREEN</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Colors_1a5c18952ccee1c554960d0591212508e4.html">Variable flamegpu::visualiser::Stock::Colors::RED</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Colors_1a6a178b4824a681a995f9e4ff131af19a.html">Variable flamegpu::visualiser::Stock::Colors::WHITE</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1a20fa45b16191b081045ab552e8b2d642.html">Variable flamegpu::visualiser::Stock::Palettes::DARK2</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1a88eb71e0f17b9303a07ea89aa64bc1a2.html">Variable flamegpu::visualiser::Stock::Palettes::GREYS</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1a30cc45821bb2d273b8d88cc52ca569ca.html">Variable flamegpu::visualiser::Stock::Palettes::PASTEL</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1afe0ee1ad329fd208faffa923fc0cb07f.html">Variable flamegpu::visualiser::Stock::Palettes::PIYG</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1ae976b044a8dd59d5fae4b28dcff4c07b.html">Variable flamegpu::visualiser::Stock::Palettes::RDYLBU</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1a3bb28bea63506f9eb15100d55c68fa7e.html">Variable flamegpu::visualiser::Stock::Palettes::SET1</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1a1bd3aa65da115e2a07b9118fa6952e82.html">Variable flamegpu::visualiser::Stock::Palettes::SET2</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1a852a3b927ba4d6fd38f3be0b1c915c30.html">Variable flamegpu::visualiser::Stock::Palettes::YLGN</a></li>
<li class="toctree-l4"><a class="reference internal" href="variable_namespaceflamegpu_1_1visualiser_1_1Stock_1_1Palettes_1a0cfc07ba486999d845c4db0e8b74f152.html">Variable flamegpu::visualiser::Stock::Palettes::YLORRD</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#defines">Defines</a><ul>
<li class="toctree-l4"><a class="reference internal" href="define_filesystem_8h_1aab6af62131aad81d17d3b4afd9db334f.html">Define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_CUDAAgent_8cu_1aab6af62131aad81d17d3b4afd9db334f.html">Define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_SimLogger_8cu_1aab6af62131aad81d17d3b4afd9db334f.html">Define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_JitifyCache_8cu_1aab6af62131aad81d17d3b4afd9db334f.html">Define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_FLAMEGPUException_8h_1a3782b4c58365dfbff74733193c5b886e.html">Define DERIVED_FLAMEGPUException</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_FLAMEGPUDeviceException__device_8cuh_1a6fa64d3ebe64a9559b967c5aed92ca0d.html">Define DTHROW</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentFunction__shim_8cuh_1a1c067606a392fd111d240d55377e79a9.html">Define FLAMEGPU_AGENT_FUNCTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentFunctionCondition__shim_8cuh_1a18080498fb1ee3218b8b0ff14d7ec1af.html">Define FLAMEGPU_AGENT_FUNCTION_CONDITION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostAgentAPI_8cuh_1ad9d5573357effdcf7430c6c2024becc4.html">Define FLAMEGPU_CUSTOM_REDUCTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostAgentAPI_8cuh_1a64629b6c7aa246731d1657c3ad70996a.html">Define FLAMEGPU_CUSTOM_TRANSFORM</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentFunction__shim_8cuh_1a76f5ec2c762f0289e11d150131b80ef9.html">Define FLAMEGPU_DEVICE_FUNCTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostAPI__macros_8h_1a4a4750514dd45f70b587b29543fe7a27.html">Define FLAMEGPU_EXIT_CONDITION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostAPI__macros_8h_1a1c604c9eb863599998429b48b31fe671.html">Define FLAMEGPU_EXIT_FUNCTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostAPI__macros_8h_1a1682b3b663340523820b7b1dc35ef180.html">Define FLAMEGPU_HOST_CONDITION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentFunction__shim_8cuh_1a92ddd2311e736cc418e2ed1092485ca1.html">Define FLAMEGPU_HOST_DEVICE_FUNCTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostAPI__macros_8h_1afd0f16608253df0496b74c78500282c5.html">Define FLAMEGPU_HOST_FUNCTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostAPI__macros_8h_1a45ad84203a419b7833ef1f21484648c8.html">Define FLAMEGPU_INIT_FUNCTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostAPI__macros_8h_1a779541ca72e6a0019460ace6d0a9d1ab.html">Define FLAMEGPU_STEP_FUNCTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_version_8h_1a3721686dc87c2ab44fd82ad98ffc21db.html">Define FLAMEGPU_VERSION</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_FLAMEGPUDeviceException_8cu_1a5d707cf1db843b2f26d81f0c518b72d0.html">Define FLAMEGPUDeviceException_CU</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_CUDAErrorChecking_8cuh_1a3f6ea8e9ef58125936d50d7e1181aa7a.html">Define gpuErrchk</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_CUDAErrorChecking_8cuh_1a05a1b794ed7313e0763388e626530d99.html">Define gpuErrchkDriverAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_CUDAErrorChecking_8cuh_1aab94d05ca41ffb1aec281d2fee3014a5.html">Define gpuErrchkLaunch</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_FLAMEGPUDeviceException_8cuh_1a1a757b8c1e833b86bfca9a577aed08c8.html">Define INCLUDE_FLAMEGPU_EXCEPTION_FLAMEGPUDEVICEEXCEPTION_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_FLAMEGPUDeviceException__device_8cuh_1a8970b890bde138df77fa8531f6166660.html">Define INCLUDE_FLAMEGPU_EXCEPTION_FLAMEGPUDEVICEEXCEPTION_DEVICE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_CUDAScatter_8cuh_1a95124ede6afa81fd979fd65cd77b4b95.html">Define INCLUDE_FLAMEGPU_GPU_CUDASCATTER_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_CUDAErrorChecking_8cuh_1a57686b7f62e6545a194aa078947f020c.html">Define INCLUDE_FLAMEGPU_GPU_DETAIL_CUDAERRORCHECKING_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentFunctionData_8cuh_1abcd20b720bdde9dae536097d9b59ce83.html">Define INCLUDE_FLAMEGPU_MODEL_AGENTFUNCTIONDATA_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentFunction_8cuh_1affe4f5c251678f8cb6a9da167dabbcb4.html">Define INCLUDE_FLAMEGPU_RUNTIME_AGENTFUNCTION_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentFunction__shim_8cuh_1ab99977b2d12596d8e7eb69f86fd2c0f7.html">Define INCLUDE_FLAMEGPU_RUNTIME_AGENTFUNCTION_SHIM_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentFunctionCondition_8cuh_1a574cefe207a9b2a90e1b48ecbac1bfed.html">Define INCLUDE_FLAMEGPU_RUNTIME_AGENTFUNCTIONCONDITION_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentFunctionCondition__shim_8cuh_1a4fade0adcfca1c63f63301ef0f4618cd.html">Define INCLUDE_FLAMEGPU_RUNTIME_AGENTFUNCTIONCONDITION_SHIM_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_curve_8cuh_1a05ee33eb8cc0ac9d4f74b4bb3142e251.html">Define INCLUDE_FLAMEGPU_RUNTIME_DETAIL_CURVE_CURVE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_curve__rtc_8cuh_1a4af8369376d2fad37ccada340646f766.html">Define INCLUDE_FLAMEGPU_RUNTIME_DETAIL_CURVE_CURVE_RTC_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_DeviceAPI_8cuh_1ae19bcc534bdbb83776e9b23350a073d8.html">Define INCLUDE_FLAMEGPU_RUNTIME_DEVICEAPI_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostAgentAPI_8cuh_1a1bb5d48469df1669da757724c8d6bc49.html">Define INCLUDE_FLAMEGPU_RUNTIME_HOSTAGENTAPI_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_MessageArray2DDevice_8cuh_1a2d970be19925286658ef10612418323d.html">Define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEARRAY2D_MESSAGEARRAY2DDEVICE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_MessageArray3DDevice_8cuh_1a1eac92a18d97d668a467428697f02f45.html">Define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEARRAY3D_MESSAGEARRAY3DDEVICE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_MessageArrayDevice_8cuh_1af8e2891480b9423ea605c599f3c7ed78.html">Define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEARRAY_MESSAGEARRAYDEVICE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_MessageBruteForceDevice_8cuh_1a908163ddb9bfbb81c3eabd54007c7d04.html">Define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEBRUTEFORCE_MESSAGEBRUTEFORCEDEVICE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_MessageBucketDevice_8cuh_1a55f537869b8e489d0323140c49f550c7.html">Define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEBUCKET_MESSAGEBUCKETDEVICE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_MessageNoneDevice_8cuh_1af35d3304468392badb3a3c3f490ed543.html">Define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGENONE_MESSAGENONEDEVICE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_MessageSpatial2DDevice_8cuh_1a64a87e1d070382b34fd7106f97b4dad9.html">Define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGESPATIAL2D_MESSAGESPATIAL2DDEVICE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_MessageSpatial3DDevice_8cuh_1a2e44a936ef72b228e1b4022d142c6d39.html">Define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGESPATIAL3D_MESSAGESPATIAL3DDEVICE_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentRandom_8cuh_1acd7f782648ca5a41ae070fcd10411190.html">Define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_AGENTRANDOM_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_DeviceEnvironment_8cuh_1a70778256e5045fe5a8a73595d04ce1db.html">Define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_DEVICEENVIRONMENT_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_DeviceMacroProperty_8cuh_1a061e18ea0c5e08a909ac3b5e9b6e7d29.html">Define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_DEVICEMACROPROPERTY_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_EnvironmentManager_8cuh_1a35e4d0576f837bbd5d6ae21c4024f9eb.html">Define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_ENVIRONMENTMANAGER_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostEnvironment_8cuh_1a3e67960203739446d72ad966a9f0d710.html">Define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_HOSTENVIRONMENT_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostMacroProperty_8cuh_1a46f00be2ac5b3fd3461d430c8fbf6f1a.html">Define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_HOSTMACROPROPERTY_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_HostRandom_8cuh_1a057dabfe55bd607fde69100834c1a29c.html">Define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_HOSTRANDOM_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_RandomManager_8cuh_1abdc3446320e64bb468b1c7d563ce0521.html">Define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_RANDOMMANAGER_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_AgentLoggingConfig__Reductions_8cuh_1a7f05530c5c7a13f8de36eb4cd1271788.html">Define INCLUDE_FLAMEGPU_SIM_AGENTLOGGINGCONFIG_REDUCTIONS_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_compute__capability_8cuh_1a4bad8946cebb8e427cdf878597032be5.html">Define INCLUDE_FLAMEGPU_UTIL_DETAIL_COMPUTE_CAPABILITY_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_CUDAEventTimer_8cuh_1a906db513b7e58dbad67f053deb4d830f.html">Define INCLUDE_FLAMEGPU_UTIL_DETAIL_CUDAEVENTTIMER_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_wddm_8cuh_1a6bd3f6bafd8d04201ccb2e8e21972bb4.html">Define INCLUDE_FLAMEGPU_UTIL_DETAIL_WDDM_CUH_</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_nvtx_8h_1a27e6e9154344b5ec41e9b55b177d8e17.html">Define NVTX_POP</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_nvtx_8h_1ad9715a7b8d8ac1584097a1d664dba054.html">Define NVTX_PUSH</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_nvtx_8h_1af9a6ff0a3f4236d36762228e06b84c51.html">Define NVTX_RANGE</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_FLAMEGPUException_8h_1ac900f7f4cbb8ade051915b56180eb89d.html">Define THROW</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_XMLLogger_8cu_1afa12b43d02fbd77db41a70be0733552a.html">Define XMLCheckResult</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_XMLStateReader_8cpp_1afa12b43d02fbd77db41a70be0733552a.html">Define XMLCheckResult</a></li>
<li class="toctree-l4"><a class="reference internal" href="define_XMLStateWriter_8cpp_1afa12b43d02fbd77db41a70be0733552a.html">Define XMLCheckResult</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#typedefs">Typedefs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a1526f45009388246e8fa90b51961ffc1.html">Typedef flamegpu::AgentFunctionConditionWrapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a321a8cd9cb3fc96929c7c378b38dc55b.html">Typedef flamegpu::AgentFunctionWrapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a63d0d158d88f589b144c183925cf6ac4.html">Typedef flamegpu::CUDAMessageMap</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1ac8e9e6ebf91151e28403d28a1cf51288.html">Typedef flamegpu::CUDAMessageMapPair</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1afe2ca90ee1ba3f7638e0a640dda346b3.html">Typedef flamegpu::DeviceAgentVector</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a5607538d6f1b97ef411a40c9d52f71b1.html">Typedef flamegpu::FLAMEGPU_EXIT_CONDITION_POINTER</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a677d0646677414a5fe34a580891c1296.html">Typedef flamegpu::FLAMEGPU_EXIT_FUNCTION_POINTER</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a13e4b64ac18db61a5da0c453baf89b1d.html">Typedef flamegpu::FLAMEGPU_HOST_CONDITION_POINTER</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a9bfe18618d31195e57596fba50d28af9.html">Typedef flamegpu::FLAMEGPU_HOST_FUNCTION_POINTER</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a49027ae818bd10917878571d0aab9eae.html">Typedef flamegpu::FLAMEGPU_INIT_FUNCTION_POINTER</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a327d7686ae940faa86f0119b6c7da377.html">Typedef flamegpu::FLAMEGPU_STEP_FUNCTION_POINTER</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1aa38504d5d161ede66606cf62524fb9e2.html">Typedef flamegpu::id_t</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1a83d0ff667b27ea2b2ec5677bf0c24253.html">Typedef flamegpu::IntT</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1_1util_1aa7b566b0594a93a119a5514350637c4c.html">Typedef flamegpu::util::StringPair</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1_1util_1aecb766a8c1523feef0016f93a23fcc05.html">Typedef flamegpu::util::StringPairMap</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1_1util_1afbbdc01d25d7a25770ebe2dda9327653.html">Typedef flamegpu::util::StringPairUnorderedMap</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1_1util_1a72a7e160df1621db15bbc9959be7fec0.html">Typedef flamegpu::util::StringUint32Pair</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1_1util_1aa4471b1ad6fc994261e936035243c21f.html">Typedef flamegpu::util::StringUint32PairMap</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1_1util_1a66f226b533f3e6710fb78c7e7b801dd1.html">Typedef flamegpu::util::StringUint32PairUnorderedMap</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1aebf720d85bdb918165592c59575fe998.html">Typedef flamegpu::VariableMap</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1_1visualiser_1af8b0a3c3a081bb0366b9867e22af0d99.html">Typedef flamegpu::visualiser::iDiscreteColor</a></li>
<li class="toctree-l4"><a class="reference internal" href="typedef_namespaceflamegpu_1_1visualiser_1ae4a92f51d0b0c323285c6df3f97b5910.html">Typedef flamegpu::visualiser::uDiscreteColor</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/FLAMEGPU/FLAMEGPU2/discussions">Forum</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #4d4d4d" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FLAME GPU 2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Program Listing for File CUDASimulation.cu</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/program_listing_file_src_flamegpu_gpu_CUDASimulation.cu.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="program-listing-for-file-cudasimulation-cu">
<span id="program-listing-file-src-flamegpu-gpu-cudasimulation-cu"></span><h1>Program Listing for File CUDASimulation.cu<a class="headerlink" href="#program-listing-for-file-cudasimulation-cu" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file_src_flamegpu_gpu_CUDASimulation.cu.html#file-src-flamegpu-gpu-cudasimulation-cu"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/flamegpu/gpu/CUDASimulation.cu</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#include &quot;flamegpu/gpu/CUDASimulation.h&quot;

#include &lt;curand_kernel.h&gt;

#include &lt;algorithm&gt;
#include &lt;string&gt;

#include &quot;flamegpu/model/AgentFunctionData.cuh&quot;
#include &quot;flamegpu/model/LayerData.h&quot;
#include &quot;flamegpu/model/AgentDescription.h&quot;
#include &quot;flamegpu/model/SubModelData.h&quot;
#include &quot;flamegpu/model/SubAgentData.h&quot;
#include &quot;flamegpu/runtime/HostAPI.h&quot;
#include &quot;flamegpu/gpu/CUDAScanCompaction.h&quot;
#include &quot;flamegpu/util/nvtx.h&quot;
#include &quot;flamegpu/util/detail/compute_capability.cuh&quot;
#include &quot;flamegpu/util/detail/SignalHandlers.h&quot;
#include &quot;flamegpu/util/detail/wddm.cuh&quot;
#include &quot;flamegpu/util/detail/SteadyClockTimer.h&quot;
#include &quot;flamegpu/util/detail/CUDAEventTimer.cuh&quot;
#include &quot;flamegpu/runtime/detail/curve/curve_rtc.cuh&quot;
#include &quot;flamegpu/runtime/HostFunctionCallback.h&quot;
#include &quot;flamegpu/runtime/messaging.h&quot;
#include &quot;flamegpu/gpu/CUDAAgent.h&quot;
#include &quot;flamegpu/gpu/CUDAMessage.h&quot;
#include &quot;flamegpu/sim/LoggingConfig.h&quot;
#include &quot;flamegpu/sim/LogFrame.h&quot;
#ifdef VISUALISATION
#include &quot;flamegpu/visualiser/FLAMEGPU_Visualisation.h&quot;
#endif

namespace flamegpu {

namespace {
    // file-scope only variable used to cache the driver mode
    bool deviceUsingWDDM = false;
    // Inlined method in the anonymous namespace to create a new timer, subject to the driver model.
    std::unique_ptr&lt;util::detail::Timer&gt; getDriverAppropriateTimer() {
        if (!deviceUsingWDDM) {
            return std::unique_ptr&lt;util::detail::Timer&gt;(new util::detail::CUDAEventTimer());
        } else {
            return std::unique_ptr&lt;util::detail::Timer&gt;(new util::detail::SteadyClockTimer());
        }
    }
}  // anonymous namespace

std::map&lt;int, std::atomic&lt;int&gt;&gt; CUDASimulation::active_device_instances;
std::map&lt;int, std::shared_timed_mutex&gt; CUDASimulation::active_device_mutex;
std::shared_timed_mutex CUDASimulation::active_device_maps_mutex;
std::atomic&lt;int&gt; CUDASimulation::active_instances = {0};
bool CUDASimulation::AUTO_CUDA_DEVICE_RESET = true;

CUDASimulation::CUDASimulation(const ModelDescription&amp; _model, int argc, const char** argv)
    : CUDASimulation(_model.model) {
    if (argc &amp;&amp; argv) {
        initialise(argc, argv);
    }
}
CUDASimulation::CUDASimulation(const std::shared_ptr&lt;const ModelData&gt; &amp;_model)
    : Simulation(_model)
    , step_count(0)
    , elapsedSecondsSimulation(0.)
    , elapsedSecondsInitFunctions(0.)
    , elapsedSecondsExitFunctions(0.)
    , elapsedSecondsRTCInitialisation(0.)
    , macro_env(*_model-&gt;environment, *this)
    , run_log(std::make_unique&lt;RunLog&gt;())
    , streams(std::vector&lt;cudaStream_t&gt;())
    , singletons(nullptr)
    , singletonsInitialised(false)
    , rtcInitialised(false)
    , isPureRTC(detectPureRTC(model)) {
    ++active_instances;
    initOffsetsAndMap();
    // Register the signal handler.
    util::detail::SignalHandlers::registerSignalHandlers();

    // populate the CUDA agent map
    const auto &amp;am = model-&gt;agents;
    // create new cuda agent and add to the map
    for (auto it = am.cbegin(); it != am.cend(); ++it) {
        // insert into map using value_type and store a reference to the map pair
        agent_map.emplace(it-&gt;first, std::make_unique&lt;CUDAAgent&gt;(*it-&gt;second, *this)).first;
    }

    // populate the CUDA message map
    const auto &amp;mm = model-&gt;messages;
    // create new cuda message and add to the map
    for (auto it_m = mm.cbegin(); it_m != mm.cend(); ++it_m) {
        message_map.emplace(it_m-&gt;first, std::make_unique&lt;CUDAMessage&gt;(*it_m-&gt;second, *this));
    }

    // populate the CUDA submodel map
    const auto &amp;smm = model-&gt;submodels;
    // create new cuda message and add to the map
    for (auto it_sm = smm.cbegin(); it_sm != smm.cend(); ++it_sm) {
        submodel_map.emplace(it_sm-&gt;first, std::unique_ptr&lt;CUDASimulation&gt;(new CUDASimulation(it_sm-&gt;second, this)));
    }

    // Determine which agents will be spatially sorted
    this-&gt;determineAgentsToSort();
}
bool CUDASimulation::detectPureRTC(const std::shared_ptr&lt;const ModelData&gt;&amp; _model) {
    const auto&amp; am = _model-&gt;agents;
    for (auto it = am.cbegin(); it != am.cend(); ++it) {
        for (const auto&amp; af : it-&gt;second-&gt;functions) {
            if (af.second-&gt;func || af.second-&gt;condition)
                return false;
        }
    }
    // TODO: In future this will need to be extended for new forms of device function, e.g. device init
    const auto&amp; as = _model-&gt;submodels;
    for (auto it = as.cbegin(); it != as.cend(); ++it) {
        if (!detectPureRTC(it-&gt;second-&gt;submodel))
          return false;
    }
    return true;
}
CUDASimulation::CUDASimulation(const std::shared_ptr&lt;SubModelData&gt; &amp;submodel_desc, CUDASimulation *master_model)
    : Simulation(submodel_desc, master_model)
    , step_count(0)
    , macro_env(*submodel_desc-&gt;submodel-&gt;environment, *this)
    , run_log(std::make_unique&lt;RunLog&gt;())
    , streams(std::vector&lt;cudaStream_t&gt;())
    , singletons(nullptr)
    , singletonsInitialised(false)
    , rtcInitialised(false)
    , isPureRTC(master_model-&gt;isPureRTC) {
    ++active_instances;
    initOffsetsAndMap();
    // Ensure submodel is valid
    if (submodel_desc-&gt;submodel-&gt;exitConditions.empty() &amp;&amp; submodel_desc-&gt;submodel-&gt;exitConditionCallbacks.empty() &amp;&amp; submodel_desc-&gt;max_steps == 0) {
        THROW exception::InvalidSubModel(&quot;Model &#39;%s&#39; does not contain any exit conditions or exit condition callbacks and submodel &#39;%s&#39; max steps is set to 0, SubModels must exit of their own accord, &quot;
            &quot;in CUDASimulation::CUDASimulation().&quot;,
            submodel_desc-&gt;submodel-&gt;name.c_str(), submodel_desc-&gt;name.c_str());
    }

    // populate the CUDA agent map (With SubAgents!)
    const auto &amp;am = model-&gt;agents;
    // create new cuda agent and add to the map
    for (auto it = am.cbegin(); it != am.cend(); ++it) {
        // Locate the mapping
        auto _mapping = submodel_desc-&gt;subagents.find(it-&gt;second-&gt;name);
        if (_mapping != submodel_desc-&gt;subagents.end()) {
            // Agent is mapped, create subagent
            std::shared_ptr&lt;SubAgentData&gt; &amp;mapping = _mapping-&gt;second;
            // Locate the master agent
            std::shared_ptr&lt;AgentData&gt; masterAgentDesc = mapping-&gt;masterAgent.lock();
            if (!masterAgentDesc) {
                THROW exception::InvalidParent(&quot;Master agent description has expired, in CUDASimulation SubModel constructor.\n&quot;);
            }
            std::unique_ptr&lt;CUDAAgent&gt; &amp;masterAgent = master_model-&gt;agent_map.at(masterAgentDesc-&gt;name);
            agent_map.emplace(it-&gt;first, std::make_unique&lt;CUDAAgent&gt;(*it-&gt;second, *this, masterAgent, mapping));
        } else {
            // Agent is not mapped, create regular agent
            agent_map.emplace(it-&gt;first, std::make_unique&lt;CUDAAgent&gt;(*it-&gt;second, *this)).first;
        }
    }  // insert into map using value_type

    // populate the CUDA message map (Sub Messages not currently supported)
    const auto &amp;mm = model-&gt;messages;
    // create new cuda message and add to the map
    for (auto it_m = mm.cbegin(); it_m != mm.cend(); ++it_m) {
        message_map.emplace(it_m-&gt;first, std::make_unique&lt;CUDAMessage&gt;(*it_m-&gt;second, *this));
    }

    // populate the CUDA submodel map
    const auto &amp;smm = model-&gt;submodels;
    // create new cuda model and add to the map
    for (auto it_sm = smm.cbegin(); it_sm != smm.cend(); ++it_sm) {
        submodel_map.emplace(it_sm-&gt;first, std::unique_ptr&lt;CUDASimulation&gt;(new CUDASimulation(it_sm-&gt;second, this)));
    }
    // Submodels all run quiet/not verbose by default
    SimulationConfig().verbose = false;
    SimulationConfig().steps = submodel_desc-&gt;max_steps;
}

CUDASimulation::~CUDASimulation() {
    // Ensure we destruct with the right device, otherwise we could dealloc pointers on the wrong device
    int t_device_id = -1;
    gpuErrchk(cudaGetDevice(&amp;t_device_id));
    if (t_device_id != deviceInitialised &amp;&amp; deviceInitialised != -1) {
        gpuErrchk(cudaSetDevice(deviceInitialised));
    }

    submodel_map.clear();  // Test
    // De-initialise, freeing singletons?
    // @todo - this is unsafe in a destructor as it may invoke cuda commands.
    if (singletonsInitialised) {
        // unique pointers cleanup by automatically
        // Drop all constants from the constant cache linked to this model
        singletons-&gt;environment.free(singletons-&gt;curve, instance_id);
        // if (active_instances == 1) {
        //   assert(singletons-&gt;curve.size() == 0);
        // }

        delete singletons;
        singletons = nullptr;
    }

    // Destroy streams, potentially unsafe in a destructor as it will invoke cuda commands.
    // Do this once to re-use existing streams rather than per-step.
    this-&gt;destroyStreams();

    // We must explicitly delete all cuda members before we cuda device reset
    agent_map.clear();
    message_map.clear();
    submodel_map.clear();
    host_api.reset();
    macro_env.free();
#ifdef VISUALISATION
    visualisation.reset();
#endif
    // If we are the last instance to destruct
    // This doesn&#39;t really play nicely if we are passing multi-device CUDASimulations between threads!
    // I think this exists to prevent curve getting left with dead items when exceptions are thrown during the test suite.
    if (deviceInitialised &gt;= 0 &amp;&amp; AUTO_CUDA_DEVICE_RESET) {
        std::shared_lock&lt;std::shared_timed_mutex&gt; maps_lock(active_device_maps_mutex);
        std::unique_lock&lt;std::shared_timed_mutex&gt; lock(active_device_mutex.at(deviceInitialised));
        if (!--active_device_instances.at(deviceInitialised)) {
            // Small chance that time between the atomic and body of this fn will cause a problem
            // Could mutex it with init simulation cuda stuff, but really seems unlikely
            gpuErrchk(cudaDeviceReset());
            EnvironmentManager::getInstance().purge();
            detail::curve::Curve::getInstance().purge();
        }
    }
    if (t_device_id != deviceInitialised) {
        gpuErrchk(cudaSetDevice(t_device_id));
    }
    --active_instances;
}



void CUDASimulation::initFunctions() {
    NVTX_RANGE(&quot;CUDASimulation::initFunctions&quot;);
    std::unique_ptr&lt;util::detail::Timer&gt; initFunctionsTimer(new util::detail::SteadyClockTimer());
    initFunctionsTimer-&gt;start();

    // Execute normal init functions
    for (auto &amp;initFn : model-&gt;initFunctions) {
        initFn(this-&gt;host_api.get());
    }
    // Execute init function callbacks (python)
    for (auto &amp;initFn : model-&gt;initFunctionCallbacks) {
        initFn-&gt;run(this-&gt;host_api.get());
    }
    // Check if host agent creation was used in init functions
    if (model-&gt;initFunctions.size() || model-&gt;initFunctionCallbacks.size()) {
        processHostAgentCreation(0);
    }

    // Record, store and output the elapsed time of the step.
    initFunctionsTimer-&gt;stop();
    this-&gt;elapsedSecondsInitFunctions = initFunctionsTimer-&gt;getElapsedSeconds();
    if (getSimulationConfig().timing) {
        fprintf(stdout, &quot;Init Function Processing time: %.6f s\n&quot;, this-&gt;elapsedSecondsInitFunctions);
    }
}

void CUDASimulation::exitFunctions() {
    NVTX_RANGE(&quot;CUDASimulation::exitFunctions&quot;);
    std::unique_ptr&lt;util::detail::Timer&gt; exitFunctionsTimer(new util::detail::SteadyClockTimer());
    exitFunctionsTimer-&gt;start();

    // Execute exit functions
    for (auto &amp;exitFn : model-&gt;exitFunctions) {
        exitFn(this-&gt;host_api.get());
    }
    // Execute any exit functions from swig/python
    for (auto &amp;exitFn : model-&gt;exitFunctionCallbacks) {
        exitFn-&gt;run(this-&gt;host_api.get());
    }

    // Record, store and output the elapsed time of the step.
    exitFunctionsTimer-&gt;stop();
    this-&gt;elapsedSecondsExitFunctions = exitFunctionsTimer-&gt;getElapsedSeconds();
    if (getSimulationConfig().timing) {
        fprintf(stdout, &quot;Exit Function Processing time: %.6f s\n&quot;, this-&gt;elapsedSecondsExitFunctions);
    }
}

__global__ void spatialSortInitToThreadIndex(unsigned int *output, unsigned int threadCount) {
    const unsigned int TID = blockIdx.x * blockDim.x + threadIdx.x;
    if (TID &lt; threadCount) {
        output[TID] = TID;
    }
}

namespace detail {
template &lt;typename T&gt; struct Dims {
    T x;
    T y;
    T z;
};
}

__global__ void calculateSpatialHash(float* x, float* y, float* z, unsigned int* binIndex, detail::Dims&lt;float&gt; envMin, detail::Dims&lt;float&gt; envWidth, detail::Dims&lt;unsigned int&gt; gridDim, unsigned int threadCount) {
    const unsigned int TID = blockIdx.x * blockDim.x + threadIdx.x;
    if (TID &lt; threadCount) {
        // Compute hash (effectivley an index for to a bin within the partitioning grid in this case)
        int gridPos[3] = {
            static_cast&lt;int&gt;(floorf(((x[TID]-envMin.x) / envWidth.x)*gridDim.x)),
            static_cast&lt;int&gt;(floorf(((y[TID]-envMin.y) / envWidth.y)*gridDim.y)),
            0
        };

        // If 3D, set 3rd component
        if (z) {
            gridPos[2] = static_cast&lt;int&gt;(floorf(((z[TID]-envMin.z) / envWidth.z)*gridDim.z));
        }

        // Compute and set the bin index
        unsigned int bindex;

        if (z) {
            bindex = (unsigned int)(
            (gridPos[2] * gridDim.x * gridDim.y +   // z
            (gridPos[1] * gridDim.x) +              // y
            gridPos[0]));                           // x

        } else {
            bindex = (unsigned int)(
            (gridPos[1] * gridDim.x) +              // y
            gridPos[0]);                            // x
        }

        binIndex[TID] = bindex;
    }
}

void CUDASimulation::determineAgentsToSort() {
    const auto&amp; am = model-&gt;agents;

    // Iterate agents and then agent functions to find any functions which use spatial messaging
    for (auto it = am.cbegin(); it != am.cend(); ++it) {
        const auto&amp; mf = it-&gt;second-&gt;functions;
        for (auto it_f = mf.cbegin(); it_f != mf.cend(); ++it_f) {
            if (auto ptr = it_f-&gt;second-&gt;message_input.lock()) {
                // Check if this agent function uses 3D spatial messages
                if (ptr-&gt;getSortingType() == flamegpu::MessageSortingType::spatial3D) {
                    // Agent uses spatial, check it has correct variables
                    const auto&amp; ad = *(it-&gt;second-&gt;description);
                    if (ad.hasVariable(&quot;x&quot;) &amp;&amp; ad.hasVariable(&quot;y&quot;) &amp;&amp; ad.hasVariable(&quot;z&quot;)) {
                        sortTriggers3D.insert(it_f-&gt;first);
                    }
                }

                // Check if this agent function uses 2D spatial messages
                if (ptr-&gt;getSortingType() == flamegpu::MessageSortingType::spatial2D) {
                    // Agent uses spatial, check it has correct variables
                    const auto&amp; ad = *(it-&gt;second-&gt;description);
                    if (ad.hasVariable(&quot;x&quot;) &amp;&amp; ad.hasVariable(&quot;y&quot;)) {
                        sortTriggers2D.insert(it_f-&gt;first);
                    }
                }
            }
        }
    }
}


void CUDASimulation::spatialSortAgent(const std::string&amp; funcName, const std::string&amp; agentName, const std::string&amp; state, const int mode) {
    // Fetch the appropriate message name
    CUDAAgent&amp; cuda_agent = getCUDAAgent(agentName);
    auto&amp; cudaAgentData = cuda_agent.getAgentDescription();
    auto&amp; funcData = cudaAgentData.functions.at(funcName);
    std::string messageName;
    if (auto ptr = funcData-&gt;message_input.lock()) {
        messageName = ptr-&gt;name;
    } else {
        throw(&quot;Function &quot; + funcName + &quot; registered for auto-spatial sorting but input message type not found!\n&quot;);
    }
    MessageBruteForce::Data* msgData = model-&gt;messages.at(messageName).get();

    // Get the spatial metadata
    float radius;
    detail::Dims&lt;float&gt; envMin {};
    detail::Dims&lt;float&gt; envMax {};
    detail::Dims&lt;float&gt; envWidth {};
    detail::Dims&lt;unsigned int&gt; gridDim {};

    if (auto messageSpatialData2D = dynamic_cast&lt;MessageSpatial2D::Data*&gt;(msgData)) {
        radius = messageSpatialData2D-&gt;radius;
        envMin = {messageSpatialData2D-&gt;minX, messageSpatialData2D-&gt;minY, 0.0f};
        envMax = {messageSpatialData2D-&gt;maxX, messageSpatialData2D-&gt;maxY, 0.0f};
    } else if (auto messageSpatialData3D = dynamic_cast&lt;MessageSpatial3D::Data*&gt;(msgData)) {
        radius = messageSpatialData3D-&gt;radius;
        envMin = {messageSpatialData3D-&gt;minX, messageSpatialData3D-&gt;minY, messageSpatialData3D-&gt;minZ};
        envMax = {messageSpatialData3D-&gt;maxX, messageSpatialData3D-&gt;maxY, messageSpatialData3D-&gt;maxZ};
    } else {
        radius = 0.0f;
        envMin = {0.0f, 0.0f, 0.0f};
        envMax = {0.0f, 0.0f, 0.0f};
    }
    if (radius) {
        envWidth = {(envMax.x-envMin.x), (envMax.y-envMin.y), (envMax.z-envMin.z)};
        gridDim = {static_cast&lt;unsigned int&gt;(ceilf(envWidth.x / radius)), static_cast&lt;unsigned int&gt;(ceilf(envWidth.y / radius)), static_cast&lt;unsigned int&gt;(ceilf(envWidth.z / radius))};
    }


    // Any agent in this list is guaranteed to have x, y, z and _auto_sort_bin_index vars - used in the computation of spatial hash
    // TODO: User could supply alternatives to &quot;x&quot;, &quot;y&quot;, &quot;z&quot; to use alternative variables?
    void* xPtr = cuda_agent.getStateVariablePtr(state, &quot;x&quot;);
    void* yPtr = cuda_agent.getStateVariablePtr(state, &quot;y&quot;);
    void* zPtr = mode == Agent3D ? cuda_agent.getStateVariablePtr(state, &quot;z&quot;) : 0;
    void* binIndexPtr = cuda_agent.getStateVariablePtr(state, &quot;_auto_sort_bin_index&quot;);

    // Compute occupancy
    int blockSize = 0;  // The launch configurator returned block size
    int minGridSize = 0;  // The minimum grid size needed to achieve the // maximum occupancy for a full device // launch
    int gridSize = 0;  // The actual grid size needed, based on input size
    const unsigned int state_list_size = cuda_agent.getStateSize(state);
    cudaOccupancyMaxPotentialBlockSize(&amp;minGridSize, &amp;blockSize, calculateSpatialHash, 0, state_list_size);

    gridSize = (state_list_size + blockSize - 1) / blockSize;

    unsigned int sm_size = 0;
    unsigned int streamIdx = 0;
#if !defined(SEATBELTS) || SEATBELTS
    auto *error_buffer = this-&gt;singletons-&gt;exception.getDevicePtr(streamIdx, this-&gt;getStream(streamIdx));
    sm_size = sizeof(error_buffer);
#endif

    // Launch kernel
    calculateSpatialHash&lt;&lt;&lt;gridSize, blockSize, sm_size, this-&gt;getStream(streamIdx) &gt;&gt;&gt; (reinterpret_cast&lt;float*&gt;(xPtr),
    reinterpret_cast&lt;float*&gt;(yPtr),
    reinterpret_cast&lt;float*&gt;(zPtr),
    reinterpret_cast&lt;unsigned int*&gt;(binIndexPtr),
    envMin,
    envWidth,
    gridDim,
    state_list_size);

    assert(host_api);
    host_api-&gt;agent(agentName).sort&lt;unsigned int&gt;(&quot;_auto_sort_bin_index&quot;, HostAgentAPI::Asc);
}

bool CUDASimulation::step() {
    NVTX_RANGE(std::string(&quot;CUDASimulation::step &quot; + std::to_string(step_count)).c_str());
    // Ensure singletons have been initialised
    initialiseSingletons();

    // Time the individual step, using a CUDAEventTimer if possible, else a steadyClockTimer.
    std::unique_ptr&lt;util::detail::Timer&gt; stepTimer = getDriverAppropriateTimer();
    stepTimer-&gt;start();

    // Init any unset agent IDs
    this-&gt;assignAgentIDs();

    // If verbose, print the step number.
    if (getSimulationConfig().verbose) {
        fprintf(stdout, &quot;Processing Simulation Step %u\n&quot;, step_count);
    }


    // Ensure there are enough streams to execute the layer.
    // Taking into consideration if in-layer concurrency is disabled or not.
    unsigned int nStreams = getMaximumLayerWidth();
    this-&gt;createStreams(nStreams);

    // Reset message list flags
    for (auto m =  message_map.begin(); m != message_map.end(); ++m) {
        m-&gt;second-&gt;setTruncateMessageListFlag();
    }

    // Execute each layer of the simulation.
    unsigned int layerIndex = 0;
    for (auto&amp; layer : model-&gt;layers) {
        // Execute the individual layer
        stepLayer(layer, layerIndex);
        // Increment counter
        ++layerIndex;
    }

    // Run the step functions (including pyhton.)
    stepStepFunctions();

    // Run the exit conditons, detecting wheter or not any we
    bool exitRequired = this-&gt;stepExitConditions();

    // Record, store and output the elapsed time of the step.
    stepTimer-&gt;stop();
    float stepMilliseconds = stepTimer-&gt;getElapsedSeconds();
    this-&gt;elapsedSecondsPerStep.push_back(stepMilliseconds);
    if (getSimulationConfig().timing) {
        // Resolution is 0.5 microseconds, so print to 1 us.
        fprintf(stdout, &quot;Step %d Processing time: %.6f s\n&quot;, this-&gt;step_count, stepMilliseconds);
    }

    // Update step count at the end of the step - when it has completed.
    incrementStepCounter();
    // Update the log for the step.
    processStepLog();
    // Return false if any exit condition&#39;s passed.
    return !exitRequired;
}

void CUDASimulation::stepLayer(const std::shared_ptr&lt;LayerData&gt;&amp; layer, const unsigned int layerIndex) {
    NVTX_RANGE(std::string(&quot;stepLayer &quot; + std::to_string(layerIndex)).c_str());

    std::string message_name;

    // If the layer contains a sub model, it can only execute the sub model.
    if (layer-&gt;sub_model) {
        auto &amp;sm = submodel_map.at(layer-&gt;sub_model-&gt;name);
        sm-&gt;resetStepCounter();
        sm-&gt;simulate();
        sm-&gt;reset(true);
        // Next layer, this layer cannot also contain agent functions
        // Ensure syncrhonisation has occured.
        this-&gt;synchronizeAllStreams();
        return;
    }

    // Track stream index
    int streamIdx = 0;
    // Sum the total number of threads being launched in the layer
    unsigned int totalThreads = 0;

    // Spatially sort the agents
    for (const auto &amp;func_des : layer-&gt;agent_functions) {
        auto func_agent = func_des-&gt;parent.lock();
        if ((func_agent-&gt;sortPeriod != 0) &amp;&amp; (step_count % func_agent-&gt;sortPeriod == 0)) {
            if (sortTriggers3D.find(func_des-&gt;name) != sortTriggers3D.end()) {
                this-&gt;spatialSortAgent(func_des-&gt;name, func_agent-&gt;name, func_des-&gt;initial_state, Agent3D);
            }
            if (sortTriggers2D.find(func_des-&gt;name) != sortTriggers2D.end()) {
                this-&gt;spatialSortAgent(func_des-&gt;name, func_agent-&gt;name, func_des-&gt;initial_state, Agent2D);
            }
        }
    }

    // Map agent memory
    bool has_rtc_func_cond = false;
    for (const auto &amp;func_des : layer-&gt;agent_functions) {
        if ((func_des-&gt;condition) || (!func_des-&gt;rtc_func_condition_name.empty())) {
            auto func_agent = func_des-&gt;parent.lock();
            NVTX_RANGE(std::string(&quot;condition map &quot; + func_agent-&gt;name + &quot;::&quot; + func_des-&gt;name).c_str());
            const CUDAAgent&amp; cuda_agent = getCUDAAgent(func_agent-&gt;name);

            const unsigned int state_list_size = cuda_agent.getStateSize(func_des-&gt;initial_state);
            if (state_list_size == 0) {
                ++streamIdx;
                continue;
            }
            singletons-&gt;scatter.Scan().resize(state_list_size, CUDAScanCompaction::AGENT_DEATH, streamIdx);

            // Configure runtime access of the functions variables within the FLAME_API object
            cuda_agent.mapRuntimeVariables(*func_des, instance_id);

            // Zero the scan flag that will be written to
            singletons-&gt;scatter.Scan().zero(CUDAScanCompaction::AGENT_DEATH, streamIdx);  // @todo - stream

            // Push function&#39;s RTC cache to device if using RTC
            if (!func_des-&gt;rtc_func_condition_name.empty()) {
                has_rtc_func_cond = true;
                std::string func_name = func_des-&gt;name + &quot;_condition&quot;;
                auto &amp;rtc_header = cuda_agent.getRTCHeader(func_name);
                // Sync EnvManager&#39;s RTC cache with RTC header&#39;s cache
                rtc_header.updateEnvCache(singletons-&gt;environment.getRTCCache(instance_id));
                // Push RTC header&#39;s cache to device
                rtc_header.updateDevice(cuda_agent.getRTCInstantiation(func_name));
            }

            totalThreads += state_list_size;
            ++streamIdx;
        }
    }

    // If any condition kernel needs to be executed, do so, by checking the number of threads from before.
    if (totalThreads &gt; 0) {
        auto env_shared_lock = this-&gt;singletons-&gt;environment.getSharedLock();
        auto env_device_lock = this-&gt;singletons-&gt;environment.getDeviceSharedLock();
        if (!has_rtc_func_cond) {
            this-&gt;singletons-&gt;environment.updateDevice(instance_id);
            this-&gt;singletons-&gt;curve.updateDevice();

            // this-&gt;synchronizeAllStreams();  // Not required, the above is snchronizing.
        }

        // Ensure RandomManager is the correct size to accommodate all threads to be launched
        curandState *d_rng = singletons-&gt;rng.resize(totalThreads);  // @todo - stream + sync.
        // Track which stream to use for concurrency
        streamIdx = 0;
        // Sum the total number of threads being launched in the layer, for rng offsetting.
        totalThreads = 0;
        // Launch function condition kernels
        for (const auto &amp;func_des : layer-&gt;agent_functions) {
            if ((func_des-&gt;condition) || (!func_des-&gt;rtc_func_condition_name.empty())) {
                auto func_agent = func_des-&gt;parent.lock();
                NVTX_RANGE(std::string(&quot;condition &quot; + func_agent-&gt;name + &quot;::&quot; + func_des-&gt;name).c_str());
                if (!func_agent) {
                    THROW exception::InvalidAgentFunc(&quot;Agent function condition refers to expired agent.&quot;);
                }
                std::string agent_name = func_agent-&gt;name;
                std::string func_name = func_des-&gt;name;

                const CUDAAgent&amp; cuda_agent = getCUDAAgent(agent_name);

                const unsigned int state_list_size = cuda_agent.getStateSize(func_des-&gt;initial_state);
                if (state_list_size == 0) {
                    ++streamIdx;
                    continue;
                }

                int blockSize = 0;  // The launch configurator returned block size
                int minGridSize = 0;  // The minimum grid size needed to achieve the // maximum occupancy for a full device // launch
                int gridSize = 0;  // The actual grid size needed, based on input size

                //  Agent function condition kernel wrapper args
                detail::curve::Curve::NamespaceHash agentname_hash = detail::curve::Curve::variableRuntimeHash(agent_name.c_str());
                detail::curve::Curve::NamespaceHash funcname_hash = detail::curve::Curve::variableRuntimeHash(func_name.c_str());
                detail::curve::Curve::NamespaceHash agent_func_name_hash = agentname_hash + funcname_hash + instance_id;
                curandState *t_rng = d_rng + totalThreads;
                unsigned int *scanFlag_agentDeath = this-&gt;singletons-&gt;scatter.Scan().Config(CUDAScanCompaction::Type::AGENT_DEATH, streamIdx).d_ptrs.scan_flag;
                unsigned int sm_size = 0;
#if !defined(SEATBELTS) || SEATBELTS
                auto *error_buffer = this-&gt;singletons-&gt;exception.getDevicePtr(streamIdx, this-&gt;getStream(streamIdx));
                sm_size = sizeof(error_buffer);
#endif
                // switch between normal and RTC agent function condition
                if (func_des-&gt;condition) {
                    // calculate the grid block size for agent function condition
                    cudaOccupancyMaxPotentialBlockSize(&amp;minGridSize, &amp;blockSize, func_des-&gt;condition, 0, state_list_size);

                    gridSize = (state_list_size + blockSize - 1) / blockSize;
                    (func_des-&gt;condition) &lt;&lt; &lt;gridSize, blockSize, sm_size, this-&gt;getStream(streamIdx) &gt;&gt; &gt; (
#if !defined(SEATBELTS) || SEATBELTS
                    error_buffer,
#endif
                    instance_id,
                    agent_func_name_hash,
                    state_list_size,
                    t_rng,
                    scanFlag_agentDeath);
                    gpuErrchkLaunch();
                } else {  // RTC function
                    std::string func_condition_identifier = func_name + &quot;_condition&quot;;
                    // get instantiation
                    const jitify::experimental::KernelInstantiation&amp; instance = cuda_agent.getRTCInstantiation(func_condition_identifier);
                    // calculate the grid block size for main agent function
                    CUfunction cu_func = (CUfunction)instance;
                    cuOccupancyMaxPotentialBlockSize(&amp;minGridSize, &amp;blockSize, cu_func, 0, 0, state_list_size);
                    gridSize = (state_list_size + blockSize - 1) / blockSize;
                    // launch the kernel
                    CUresult a = instance.configure(gridSize, blockSize, sm_size, this-&gt;getStream(streamIdx)).launch({
#if !defined(SEATBELTS) || SEATBELTS
                        reinterpret_cast&lt;void*&gt;(&amp;error_buffer),
#endif
                        const_cast&lt;void*&gt;(reinterpret_cast&lt;const void*&gt;(&amp;instance_id)),
                        reinterpret_cast&lt;void*&gt;(&amp;agent_func_name_hash),
                        const_cast&lt;void *&gt;(reinterpret_cast&lt;const void*&gt;(&amp;state_list_size)),
                        reinterpret_cast&lt;void*&gt;(&amp;t_rng),
                        reinterpret_cast&lt;void*&gt;(&amp;scanFlag_agentDeath) });
                    if (a != CUresult::CUDA_SUCCESS) {
                        const char* err_str = nullptr;
                        cuGetErrorString(a, &amp;err_str);
                        THROW exception::InvalidAgentFunc(&quot;There was a problem launching the runtime agent function condition &#39;%s&#39;: %s&quot;, func_des-&gt;rtc_func_condition_name.c_str(), err_str);
                    }
                    gpuErrchkLaunch();
                }

                totalThreads += state_list_size;
                ++streamIdx;
            }
        }

        // Ensure that each condition function has finished before unlocking the environment
        // Potentially there might be performance gains within a model by moving this until after the unmapping, although this may block other threads
        this-&gt;synchronizeAllStreams();
        env_shared_lock.unlock();
        env_device_lock.unlock();
    }

    // Track stream index
    streamIdx = 0;
    // Unmap agent memory, apply condition.
    for (const auto &amp;func_des : layer-&gt;agent_functions) {
        if ((func_des-&gt;condition) || (!func_des-&gt;rtc_func_condition_name.empty())) {
            auto func_agent = func_des-&gt;parent.lock();
            if (!func_agent) {
                THROW exception::InvalidAgentFunc(&quot;Agent function condition refers to expired agent.&quot;);
            }
            NVTX_RANGE(std::string(&quot;condition unmap &quot; + func_agent-&gt;name + &quot;::&quot; + func_des-&gt;name).c_str());
            CUDAAgent&amp; cuda_agent = getCUDAAgent(func_agent-&gt;name);

            // Skip if no agents in the input state
            const unsigned int state_list_size = cuda_agent.getStateSize(func_des-&gt;initial_state);
            if (state_list_size == 0) {
                ++streamIdx;
                continue;
            }

            // unmap the function variables
            cuda_agent.unmapRuntimeVariables(*func_des, instance_id);
#if !defined(SEATBELTS) || SEATBELTS
            // Error check after unmap vars
            this-&gt;singletons-&gt;exception.checkError(&quot;condition &quot; + func_des-&gt;name, streamIdx, this-&gt;getStream(streamIdx));
#endif
            // Process agent function condition
            cuda_agent.processFunctionCondition(*func_des, this-&gt;singletons-&gt;scatter, streamIdx, this-&gt;getStream(streamIdx));
            // Increment the stream tracker.
            ++streamIdx;
        }
    }

    bool has_rtc_func = false;
    streamIdx = 0;
    // Sum the total number of threads being launched in the layer
    totalThreads = 0;
    // for each func function - Loop through to do all mapping of agent and message variables
    for (const auto &amp;func_des : layer-&gt;agent_functions) {
        auto func_agent = func_des-&gt;parent.lock();
        if (!func_agent) {
            THROW exception::InvalidAgentFunc(&quot;Agent function refers to expired agent.&quot;);
        }
        NVTX_RANGE(std::string(&quot;map&quot; + func_agent-&gt;name + &quot;::&quot; + func_des-&gt;name).c_str());

        const CUDAAgent&amp; cuda_agent = getCUDAAgent(func_agent-&gt;name);
        const unsigned int state_list_size = cuda_agent.getStateSize(func_des-&gt;initial_state);
        if (state_list_size == 0) {
            ++streamIdx;
            continue;
        }
        // Resize death flag array if necessary
        singletons-&gt;scatter.Scan().resize(state_list_size, CUDAScanCompaction::AGENT_DEATH, streamIdx);

        // check if a function has an input message
        if (auto im = func_des-&gt;message_input.lock()) {
            std::string inpMessage_name = im-&gt;name;
            CUDAMessage&amp; cuda_message = getCUDAMessage(inpMessage_name);
            // Construct PBM here if required!!
            cuda_message.buildIndex(this-&gt;singletons-&gt;scatter, streamIdx, this-&gt;getStream(streamIdx));  // This is synchronous.
            // Map variables after, as index building can swap arrays
            cuda_message.mapReadRuntimeVariables(*func_des, cuda_agent, instance_id);
        }

        // check if a function has an output message
        if (auto om = func_des-&gt;message_output.lock()) {
            std::string outpMessage_name = om-&gt;name;
            CUDAMessage&amp; cuda_message = getCUDAMessage(outpMessage_name);
            // Resize message list if required
            const unsigned int existingMessages = cuda_message.getTruncateMessageListFlag() ? 0 : cuda_message.getMessageCount();
            cuda_message.resize(existingMessages + state_list_size, this-&gt;singletons-&gt;scatter, streamIdx, existingMessages);
            cuda_message.mapWriteRuntimeVariables(*func_des, cuda_agent, state_list_size, instance_id);
            singletons-&gt;scatter.Scan().resize(state_list_size, CUDAScanCompaction::MESSAGE_OUTPUT, streamIdx);
            // Zero the scan flag that will be written to
            if (func_des-&gt;message_output_optional)
                singletons-&gt;scatter.Scan().zero(CUDAScanCompaction::MESSAGE_OUTPUT, streamIdx);  // @todo - do this in a stream?
        }

        // check if a function has an output agent
        if (auto oa = func_des-&gt;agent_output.lock()) {
            // This will act as a reserve word
            // which is added to variable hashes for agent creation on device
            CUDAAgent&amp; output_agent = getCUDAAgent(oa-&gt;name);

            // Map vars with curve (this allocates/requests enough new buffer space if an existing version is not available/suitable)
            output_agent.mapNewRuntimeVariables(cuda_agent, *func_des, state_list_size, this-&gt;singletons-&gt;scatter, instance_id, streamIdx);  // @todo - stream?
        }

        // Configure runtime access of the functions variables within the FLAME_API object
        cuda_agent.mapRuntimeVariables(*func_des, instance_id);

        // Zero the scan flag that will be written to
        if (func_des-&gt;has_agent_death) {
            singletons-&gt;scatter.Scan().CUDAScanCompaction::zero(CUDAScanCompaction::AGENT_DEATH, streamIdx);  // @todo stream?
        }

        // Push function&#39;s RTC cache to device if using RTC
        if (!func_des-&gt;rtc_func_name.empty()) {
            has_rtc_func = true;
            auto&amp; rtc_header = cuda_agent.getRTCHeader(func_des-&gt;name);
            // Sync EnvManager&#39;s RTC cache with RTC header&#39;s cache
            rtc_header.updateEnvCache(singletons-&gt;environment.getRTCCache(instance_id));
            // Push RTC header&#39;s cache to device
            rtc_header.updateDevice(cuda_agent.getRTCInstantiation(func_des-&gt;name));
        }

        // Count total threads being launched
        totalThreads += cuda_agent.getStateSize(func_des-&gt;initial_state);
        ++streamIdx;
    }

    // If any condition kernel needs to be executed, do so, by checking the number of threads from before.
    if (totalThreads &gt; 0) {
        auto env_shared_lock = this-&gt;singletons-&gt;environment.getSharedLock();
        auto env_device_lock = this-&gt;singletons-&gt;environment.getDeviceSharedLock();
        if (!has_rtc_func) {
            this-&gt;singletons-&gt;environment.updateDevice(instance_id);
            this-&gt;singletons-&gt;curve.updateDevice();
            this-&gt;synchronizeAllStreams();  // This is not strictly required as updateDevice is synchronous.
        }

        // Ensure RandomManager is the correct size to accommodate all threads to be launched
        curandState *d_rng = singletons-&gt;rng.resize(totalThreads);
        // Total threads is now used to provide kernel launches an offset to thread-safe thread-index
        totalThreads = 0;
        streamIdx = 0;

        // for each func function - Loop through to launch all agent functions
        for (const auto &amp;func_des : layer-&gt;agent_functions) {
            auto func_agent = func_des-&gt;parent.lock();
            if (!func_agent) {
                THROW exception::InvalidAgentFunc(&quot;Agent function refers to expired agent.&quot;);
            }
            NVTX_RANGE(std::string(func_agent-&gt;name + &quot;::&quot; + func_des-&gt;name).c_str());
            const void *d_in_messagelist_metadata = nullptr;
            const void *d_out_messagelist_metadata = nullptr;
            id_t *d_agentOut_nextID = nullptr;
            std::string agent_name = func_agent-&gt;name;
            std::string func_name = func_des-&gt;name;
            detail::curve::Curve::NamespaceHash agentname_hash = detail::curve::Curve::variableRuntimeHash(agent_name.c_str());
            detail::curve::Curve::NamespaceHash funcname_hash = detail::curve::Curve::variableRuntimeHash(func_name.c_str());
            detail::curve::Curve::NamespaceHash agent_func_name_hash = agentname_hash + funcname_hash + instance_id;
            detail::curve::Curve::NamespaceHash message_name_inp_hash = 0;
            detail::curve::Curve::NamespaceHash message_name_outp_hash = 0;
            detail::curve::Curve::NamespaceHash agentoutput_hash = 0;

            // check if a function has an input message
            if (auto im = func_des-&gt;message_input.lock()) {
                std::string inpMessage_name = im-&gt;name;
                const CUDAMessage&amp; cuda_message = getCUDAMessage(inpMessage_name);

                // hash message name
                message_name_inp_hash = detail::curve::Curve::variableRuntimeHash(inpMessage_name.c_str());

                d_in_messagelist_metadata = cuda_message.getMetaDataDevicePtr();
            }

            // check if a function has an output message
            if (auto om = func_des-&gt;message_output.lock()) {
                std::string outpMessage_name = om-&gt;name;
                const CUDAMessage&amp; cuda_message = getCUDAMessage(outpMessage_name);

                // hash message name
                message_name_outp_hash =  detail::curve::Curve::variableRuntimeHash(outpMessage_name.c_str());
                d_out_messagelist_metadata = cuda_message.getMetaDataDevicePtr();
            }

            // check if a function has agent output
            if (auto oa = func_des-&gt;agent_output.lock()) {
                agentoutput_hash = (detail::curve::Curve::variableRuntimeHash(&quot;_agent_birth&quot;) ^ funcname_hash) + instance_id;
                CUDAAgent&amp; output_agent = getCUDAAgent(oa-&gt;name);
                d_agentOut_nextID = output_agent.getDeviceNextID();
            }

            const CUDAAgent&amp; cuda_agent = getCUDAAgent(agent_name);

            const unsigned int state_list_size = cuda_agent.getStateSize(func_des-&gt;initial_state);
            if (state_list_size == 0) {
                ++streamIdx;
                continue;
            }

            int blockSize = 0;  // The launch configurator returned block size
            int minGridSize = 0;  // The minimum grid size needed to achieve the // maximum occupancy for a full device // launch
            int gridSize = 0;  // The actual grid size needed, based on input size

            // Agent function kernel wrapper args
            curandState * t_rng = d_rng + totalThreads;
            unsigned int *scanFlag_agentDeath = func_des-&gt;has_agent_death ? this-&gt;singletons-&gt;scatter.Scan().Config(CUDAScanCompaction::Type::AGENT_DEATH, streamIdx).d_ptrs.scan_flag : nullptr;
            unsigned int *scanFlag_messageOutput = this-&gt;singletons-&gt;scatter.Scan().Config(CUDAScanCompaction::Type::MESSAGE_OUTPUT, streamIdx).d_ptrs.scan_flag;
            unsigned int *scanFlag_agentOutput = this-&gt;singletons-&gt;scatter.Scan().Config(CUDAScanCompaction::Type::AGENT_OUTPUT, streamIdx).d_ptrs.scan_flag;
            unsigned int sm_size = 0;
    #if !defined(SEATBELTS) || SEATBELTS
            auto *error_buffer = this-&gt;singletons-&gt;exception.getDevicePtr(streamIdx, this-&gt;getStream(streamIdx));
            sm_size = sizeof(error_buffer);
    #endif

            if (func_des-&gt;func) {   // compile time specified agent function launch
                // calculate the grid block size for main agent function
                cudaOccupancyMaxPotentialBlockSize(&amp;minGridSize, &amp;blockSize, func_des-&gt;func, 0, state_list_size);
                gridSize = (state_list_size + blockSize - 1) / blockSize;

                (func_des-&gt;func) &lt;&lt; &lt;gridSize, blockSize, sm_size, this-&gt;getStream(streamIdx) &gt;&gt; &gt; (
    #if !defined(SEATBELTS) || SEATBELTS
                    error_buffer,
    #endif
                    instance_id,
                    agent_func_name_hash,
                    message_name_inp_hash,
                    message_name_outp_hash,
                    agentoutput_hash,
                    d_agentOut_nextID,
                    state_list_size,
                    d_in_messagelist_metadata,
                    d_out_messagelist_metadata,
                    t_rng,
                    scanFlag_agentDeath,
                    scanFlag_messageOutput,
                    scanFlag_agentOutput);
                gpuErrchkLaunch();
            } else {      // assume this is a runtime specified agent function
                // get instantiation
                const jitify::experimental::KernelInstantiation&amp; instance = cuda_agent.getRTCInstantiation(func_name);
                // calculate the grid block size for main agent function
                CUfunction cu_func = (CUfunction)instance;
                cuOccupancyMaxPotentialBlockSize(&amp;minGridSize, &amp;blockSize, cu_func, 0, 0, state_list_size);
                gridSize = (state_list_size + blockSize - 1) / blockSize;
                // launch the kernel
                CUresult a = instance.configure(gridSize, blockSize, sm_size, this-&gt;getStream(streamIdx)).launch({
#if !defined(SEATBELTS) || SEATBELTS
                    reinterpret_cast&lt;void*&gt;(&amp;error_buffer),
#endif
                    const_cast&lt;void*&gt;(reinterpret_cast&lt;const void*&gt;(&amp;instance_id)),
                    reinterpret_cast&lt;void*&gt;(&amp;agent_func_name_hash),
                    reinterpret_cast&lt;void*&gt;(&amp;message_name_inp_hash),
                    reinterpret_cast&lt;void*&gt;(&amp;message_name_outp_hash),
                    reinterpret_cast&lt;void*&gt;(&amp;agentoutput_hash),
                    reinterpret_cast&lt;void*&gt;(&amp;d_agentOut_nextID),
                    const_cast&lt;void*&gt;(reinterpret_cast&lt;const void*&gt;(&amp;state_list_size)),
                    const_cast&lt;void*&gt;(reinterpret_cast&lt;const void*&gt;(&amp;d_in_messagelist_metadata)),
                    const_cast&lt;void*&gt;(reinterpret_cast&lt;const void*&gt;(&amp;d_out_messagelist_metadata)),
                    const_cast&lt;void*&gt;(reinterpret_cast&lt;const void*&gt;(&amp;t_rng)),
                    reinterpret_cast&lt;void*&gt;(&amp;scanFlag_agentDeath),
                    reinterpret_cast&lt;void*&gt;(&amp;scanFlag_messageOutput),
                    reinterpret_cast&lt;void*&gt;(&amp;scanFlag_agentOutput)});
                if (a != CUresult::CUDA_SUCCESS) {
                    const char* err_str = nullptr;
                    cuGetErrorString(a, &amp;err_str);
                    THROW exception::InvalidAgentFunc(&quot;There was a problem launching the runtime agent function &#39;%s&#39;: %s&quot;, func_name.c_str(), err_str);
                }
                gpuErrchkLaunch();
            }
            totalThreads += state_list_size;
            ++streamIdx;
        }

        // Ensure that each stream of work has finished before releasing the environment lock.
        this-&gt;synchronizeAllStreams();
        env_shared_lock.unlock();
        env_device_lock.unlock();
    }

    streamIdx = 0;
    // for each func function - Loop through to un-map all agent and message variables
    for (const auto &amp;func_des : layer-&gt;agent_functions) {
        auto func_agent = func_des-&gt;parent.lock();
        if (!func_agent) {
            THROW exception::InvalidAgentFunc(&quot;Agent function refers to expired agent.&quot;);
        }
        NVTX_RANGE(std::string(&quot;unmap&quot; + func_agent-&gt;name + &quot;::&quot; + func_des-&gt;name).c_str());
        CUDAAgent&amp; cuda_agent = getCUDAAgent(func_agent-&gt;name);

        const unsigned int state_list_size = cuda_agent.getStateSize(func_des-&gt;initial_state);
        // If agent function wasn&#39;t executed, these are redundant
        if (state_list_size &gt; 0) {
            // check if a function has an input message
            if (auto im = func_des-&gt;message_input.lock()) {
                std::string inpMessage_name = im-&gt;name;
                const CUDAMessage&amp; cuda_message = getCUDAMessage(inpMessage_name);
                cuda_message.unmapRuntimeVariables(*func_des, instance_id);
            }

            // check if a function has an output message
            if (auto om = func_des-&gt;message_output.lock()) {
                std::string outpMessage_name = om-&gt;name;
                CUDAMessage&amp; cuda_message = getCUDAMessage(outpMessage_name);
                cuda_message.unmapRuntimeVariables(*func_des, instance_id);
                cuda_message.swap(func_des-&gt;message_output_optional, state_list_size, this-&gt;singletons-&gt;scatter, streamIdx);
                cuda_message.clearTruncateMessageListFlag();
                cuda_message.setPBMConstructionRequiredFlag();
            }

            // Process agent death (has agent death check is handled by the method)
            // This MUST occur before agent_output, as if agent_output triggers resize then scan_flag for death will be purged
            cuda_agent.processDeath(*func_des, this-&gt;singletons-&gt;scatter, streamIdx, this-&gt;getStream(streamIdx));

            // Process agent state transition (Longer term merge this with process death?)
            cuda_agent.transitionState(func_des-&gt;initial_state, func_des-&gt;end_state, this-&gt;singletons-&gt;scatter, streamIdx, this-&gt;getStream(streamIdx));
        }

        // Process agent function condition
        cuda_agent.clearFunctionCondition(func_des-&gt;initial_state);

        // If agent function wasn&#39;t executed, these are redundant
        if (state_list_size &gt; 0) {
            // check if a function has an output agent
            if (auto oa = func_des-&gt;agent_output.lock()) {
                // This will act as a reserve word
                // which is added to variable hashes for agent creation on device
                CUDAAgent&amp; output_agent = getCUDAAgent(oa-&gt;name);
                // Scatter the agent birth
                output_agent.scatterNew(*func_des, state_list_size, this-&gt;singletons-&gt;scatter, streamIdx, this-&gt;getStream(streamIdx));
                // unmap vars with curve
                output_agent.unmapNewRuntimeVariables(*func_des, instance_id);
            }

            // unmap the function variables
            cuda_agent.unmapRuntimeVariables(*func_des, instance_id);
#if !defined(SEATBELTS) || SEATBELTS
            // Error check after unmap vars
            // This means that curve is cleaned up before we throw exception (mostly prevents curve being polluted if we catch and handle errors)
            this-&gt;singletons-&gt;exception.checkError(func_des-&gt;name, streamIdx, this-&gt;getStream(streamIdx));
#endif
        }

        ++streamIdx;
    }

    // Synchronise to ensure that device memory is in a goood state prior to host layer functions? This can potentially be removed
    this-&gt;synchronizeAllStreams();

    // Execute the host functions.
    layerHostFunctions(layer, layerIndex);

#if !defined(SEATBELTS) || SEATBELTS
    // Reset macro-environment read-write flags
    // Note this does not synchronise threads, it relies on synchronizeAllStreams() post host fns
    macro_env.resetFlagsAsync(streams);
#endif

    // Synchronise  after the host layer functions to ensure that the device is up to date? This can potentially be removed.
    this-&gt;synchronizeAllStreams();
}

void CUDASimulation::layerHostFunctions(const std::shared_ptr&lt;LayerData&gt;&amp; layer, const unsigned int layerIndex) {
    NVTX_RANGE(&quot;CUDASimulation::stepHostFunctions&quot;);
    // Execute all host functions attached to layer
    // TODO: Concurrency?
    assert(host_api);
    for (auto &amp;stepFn : layer-&gt;host_functions) {
        NVTX_RANGE(&quot;hostFunc&quot;);
        stepFn(this-&gt;host_api.get());
    }
    // Execute all host function callbacks attached to layer
    for (auto &amp;stepFn : layer-&gt;host_functions_callbacks) {
        NVTX_RANGE(&quot;hostFunc_swig&quot;);
        stepFn-&gt;run(this-&gt;host_api.get());
    }
    // If we have host layer functions, we might have host agent creation
    if (layer-&gt;host_functions.size() || (layer-&gt;host_functions_callbacks.size())) {
        // @todo - What is the most appropriate stream to use here?
        processHostAgentCreation(0);
    }
}

void CUDASimulation::stepStepFunctions() {
    NVTX_RANGE(&quot;CUDASimulation::step::StepFunctions&quot;);
    // Execute step functions
    for (auto &amp;stepFn : model-&gt;stepFunctions) {
        NVTX_RANGE(&quot;stepFunc&quot;);
        stepFn(this-&gt;host_api.get());
    }
    // Execute step function callbacks
    for (auto &amp;stepFn : model-&gt;stepFunctionCallbacks) {
        NVTX_RANGE(&quot;stepFunc_swig&quot;);
        stepFn-&gt;run(this-&gt;host_api.get());
    }
    // If we have step functions, we might have host agent creation
    if (model-&gt;stepFunctions.size() || model-&gt;stepFunctionCallbacks.size()) {
        processHostAgentCreation(0);
    }
}

bool CUDASimulation::stepExitConditions() {
    NVTX_RANGE(&quot;CUDASimulation::stepExitConditions&quot;);
    // Track if any exit conditions were successful. Use this to control return code and skipsteps.
    // early returning makes timing/stepCounter logic more complicated.
    bool exitConditionExit = false;

    // Execute exit conditions
    for (auto &amp;exitCdns : model-&gt;exitConditions) {
        if (exitCdns(this-&gt;host_api.get()) == EXIT) {
            #ifdef VISUALISATION
                if (visualisation) {
                    visualisation-&gt;updateBuffers(step_count+1);
                }
            #endif
            // Set the flag, and bail out of the exit condition loop.
            exitConditionExit = true;
            break;
        }
    }
    // Execute exit condition callbacks
    if (!exitConditionExit) {
        for (auto &amp;exitCdns : model-&gt;exitConditionCallbacks) {
            if (exitCdns-&gt;run(this-&gt;host_api.get()) == EXIT) {
                #ifdef VISUALISATION
                if (visualisation) {
                    visualisation-&gt;updateBuffers(step_count+1);
                }
                #endif
                // Set the flag, and bail out of the exit condition loop.
                exitConditionExit = true;
                break;
            }
        }
    }
    // No need for this if any exit conditions passed.
    if (!exitConditionExit) {
        // If we have exit conditions functions, we might have host agent creation
        if (model-&gt;exitConditions.size() || model-&gt;exitConditionCallbacks.size()) {
            processHostAgentCreation(0);
        }

        #ifdef VISUALISATION
            if (visualisation) {
                visualisation-&gt;updateBuffers(step_count+1);
            }
        #endif
    }
    return exitConditionExit;
}

void CUDASimulation::simulate() {
    NVTX_RANGE(&quot;CUDASimulation::simulate&quot;);

    // Ensure there is work to do.
    if (agent_map.size() == 0) {
        THROW exception::InvalidCudaAgentMapSize(&quot;Simulation has no agents, in CUDASimulation::simulate().&quot;);
    }

    // Ensure singletons have been initialised
    initialiseSingletons();

    // Create the event timing object, using an appropriate timer implementation.
    std::unique_ptr&lt;util::detail::Timer&gt; simulationTimer = getDriverAppropriateTimer();
    simulationTimer-&gt;start();

    // Create as many streams as required
    unsigned int nStreams = getMaximumLayerWidth();
    this-&gt;createStreams(nStreams);

    // Init any unset agent IDs
    this-&gt;assignAgentIDs();

    // Reinitialise any unmapped agent variables
    if (submodel) {
        int streamIdx = 0;
        for (auto &amp;a : agent_map) {
            a.second-&gt;initUnmappedVars(this-&gt;singletons-&gt;scatter, streamIdx, this-&gt;getStream(streamIdx));
            streamIdx++;
        }
    }

    // Reset the class&#39; elapsed time value.
    this-&gt;elapsedSecondsSimulation = 0.f;
    this-&gt;elapsedSecondsPerStep.clear();
    if (getSimulationConfig().steps &gt; 0) {
        this-&gt;elapsedSecondsPerStep.reserve(getSimulationConfig().steps);
    }

    // Execute init functions
    this-&gt;initFunctions();

    // Reset and log initial state to step log 0
    resetLog();
    processStepLog();

    #ifdef VISUALISATION
    // Pre step-loop visualisation update
    if (visualisation) {
        visualisation-&gt;updateBuffers();
    }
    #endif

    // Run the required number of simulation steps.
    for (unsigned int i = 0; getSimulationConfig().steps == 0 ? true : i &lt; getSimulationConfig().steps; i++) {
        // Run the step
        bool continueSimulation = step();
        if (!continueSimulation) {
            processStepLog();
            break;
        }
        #ifdef VISUALISATION
        // Special case, if steps == 0 and visualisation has been closed
        if (getSimulationConfig().steps == 0 &amp;&amp;
            visualisation &amp;&amp; !visualisation-&gt;isRunning()) {
            visualisation-&gt;join();  // Vis exists in separate thread, make sure it has actually exited
            break;
        }
        #endif
    }

    // Exit functions
    this-&gt;exitFunctions();
    processExitLog();

    // Sync visualistaion after the exit functions
    #ifdef VISUALISATION
    if (visualisation) {
        visualisation-&gt;updateBuffers();
    }
    #endif

    // Record, store and output the elapsed simulation time
    simulationTimer-&gt;stop();
    elapsedSecondsSimulation = simulationTimer-&gt;getElapsedSeconds();
    if (getSimulationConfig().timing) {
        // Resolution is 0.5 microseconds, so print to 1 us.
        fprintf(stdout, &quot;Total Processing time: %.6f s\n&quot;, elapsedSecondsSimulation);
    }
    // Export logs
    if (!SimulationConfig().step_log_file.empty())
        exportLog(SimulationConfig().step_log_file, true, false);
    if (!SimulationConfig().exit_log_file.empty())
        exportLog(SimulationConfig().exit_log_file, false, true);
    if (!SimulationConfig().common_log_file.empty())
        exportLog(SimulationConfig().common_log_file, true, true);
}

void CUDASimulation::reset(bool submodelReset) {
    // Reset step counter
    resetStepCounter();

    if (singletonsInitialised) {
        // Reset environment properties
        singletons-&gt;environment.resetModel(instance_id, *model-&gt;environment);

        // Reseed random, unless performing submodel reset
        if (!submodelReset) {
            singletons-&gt;rng.reseed(getSimulationConfig().random_seed);
        }
    }

    // Cull agents
    if (submodel) {
        // Submodels only want to reset unmapped states, otherwise they will break parent model
        for (auto &amp;a : agent_map) {
            a.second-&gt;cullUnmappedStates();
        }
    } else {
        for (auto &amp;a : agent_map) {
            a.second-&gt;cullAllStates();
        }
    }

    // Cull messagelists
    for (auto &amp;a : message_map) {
        a.second-&gt;setMessageCount(0);
        a.second-&gt;setTruncateMessageListFlag();
    }


    // Trigger reset in all submodels, propagation is not necessary when performing submodel reset
    if (!submodelReset) {
        for (auto &amp;s : submodel_map) {
            s.second-&gt;reset(false);
        }
    }

    // Reset any timing data.
    this-&gt;elapsedSecondsSimulation = 0.f;
    this-&gt;elapsedSecondsPerStep.clear();
}

void CUDASimulation::setPopulationData(AgentVector&amp; population, const std::string&amp; state_name) {
    // Ensure singletons have been initialised
    initialiseSingletons();
    NVTX_RANGE(&quot;CUDASimulation::setPopulationData()&quot;);
    auto it = agent_map.find(population.getAgentName());
    if (it == agent_map.end()) {
        THROW exception::InvalidAgent(&quot;Agent &#39;%s&#39; was not found, &quot;
            &quot;in CUDASimulation::setPopulationData()&quot;,
            population.getAgentName().c_str());
    }
    // This call hierarchy validates agent desc matches and state is valid
    it-&gt;second-&gt;setPopulationData(population, state_name, this-&gt;singletons-&gt;scatter, 0, 0);  // Streamid shouldn&#39;t matter here, also using default stream.
#ifdef VISUALISATION
    if (visualisation) {
        visualisation-&gt;updateBuffers();
    }
#endif
    gpuErrchk(cudaDeviceSynchronize());
    agent_ids_have_init = false;
}
void CUDASimulation::getPopulationData(AgentVector&amp; population, const std::string&amp; state_name) {
    // Ensure singletons have been initialised
    initialiseSingletons();
    NVTX_RANGE(&quot;CUDASimulation::getPopulationData()&quot;);
    gpuErrchk(cudaDeviceSynchronize());
    auto it = agent_map.find(population.getAgentName());
    if (it == agent_map.end()) {
        THROW exception::InvalidAgent(&quot;Agent &#39;%s&#39; was not found, &quot;
            &quot;in CUDASimulation::setPopulationData()&quot;,
            population.getAgentName().c_str());
    }
    // This call hierarchy validates agent desc matches and state is valid
    it-&gt;second-&gt;getPopulationData(population, state_name);
    gpuErrchk(cudaDeviceSynchronize());
}

CUDAAgent&amp; CUDASimulation::getCUDAAgent(const std::string&amp; agent_name) const {
    CUDAAgentMap::const_iterator it;
    it = agent_map.find(agent_name);

    if (it == agent_map.end()) {
        THROW exception::InvalidCudaAgent(&quot;CUDA agent (&#39;%s&#39;) not found, in CUDASimulation::getCUDAAgent().&quot;,
            agent_name.c_str());
    }

    return *(it-&gt;second);
}

AgentInterface&amp; CUDASimulation::getAgent(const std::string&amp; agent_name) {
    // Ensure singletons have been initialised
    initialiseSingletons();

    auto it = agent_map.find(agent_name);

    if (it == agent_map.end()) {
        THROW exception::InvalidCudaAgent(&quot;CUDA agent (&#39;%s&#39;) not found, in CUDASimulation::getAgent().&quot;,
            agent_name.c_str());
    }

    return *(it-&gt;second);
}

CUDAMessage&amp; CUDASimulation::getCUDAMessage(const std::string&amp; message_name) const {
    CUDAMessageMap::const_iterator it;
    it = message_map.find(message_name);

    if (it == message_map.end()) {
        THROW exception::InvalidCudaMessage(&quot;CUDA message (&#39;%s&#39;) not found, in CUDASimulation::getCUDAMessage().&quot;,
            message_name.c_str());
    }

    return *(it-&gt;second);
}

void CUDASimulation::setStepLog(const StepLoggingConfig &amp;stepConfig) {
    // Validate ModelDescription matches
    if (*stepConfig.model != *model) {
        THROW exception::InvalidArgument(&quot;Model descriptions attached to LoggingConfig and CUDASimulation do not match, in CUDASimulation::setStepLog()\n&quot;);
    }
    // Set internal config
    step_log_config = std::make_shared&lt;StepLoggingConfig&gt;(stepConfig);
}
void CUDASimulation::setExitLog(const LoggingConfig &amp;exitConfig) {
    // Validate ModelDescription matches
    if (*exitConfig.model != *model) {
        THROW exception::InvalidArgument(&quot;Model descriptions attached to LoggingConfig and CUDASimulation do not match, in CUDASimulation::setExitLog()\n&quot;);
    }
    // Set internal config
    exit_log_config = std::make_shared&lt;LoggingConfig&gt;(exitConfig);
}

bool CUDASimulation::checkArgs_derived(int argc, const char** argv, int &amp;i) {
    // Get arg as lowercase
    std::string arg(argv[i]);
    std::transform(arg.begin(), arg.end(), arg.begin(), [](unsigned char c) { return std::use_facet&lt; std::ctype&lt;char&gt;&gt;(std::locale()).tolower(c); });
    // -device &lt;uint&gt;, Uses the specified cuda device, defaults to 0
    if ((arg.compare(&quot;--device&quot;) == 0 || arg.compare(&quot;-d&quot;) == 0) &amp;&amp; argc &gt; i+1) {
        config.device_id = static_cast&lt;unsigned int&gt;(strtoul(argv[++i], nullptr, 0));
        return true;
    }
    return false;
}

void CUDASimulation::printHelp_derived() {
    const char *line_fmt = &quot;%-18s %s\n&quot;;
    printf(&quot;CUDA Model Optional Arguments:\n&quot;);
    printf(line_fmt, &quot;-d, --device&quot;, &quot;GPU index&quot;);
}

void CUDASimulation::applyConfig_derived() {
    NVTX_RANGE(&quot;applyConfig_derived&quot;);

    // Handle console_mode
#ifdef VISUALISATION
    if (getSimulationConfig().console_mode) {
        if (visualisation) {
            visualisation-&gt;deactivate();
        }
    }
#endif


    cudaError_t cudaStatus;
    int device_count;

    // default device
    cudaStatus = cudaGetDeviceCount(&amp;device_count);

    if (cudaStatus != cudaSuccess) {
        THROW exception::InvalidCUDAdevice(&quot;Error finding CUDA devices!  Do you have a CUDA-capable GPU installed?&quot;);
    }
    if (device_count == 0) {
        THROW exception::InvalidCUDAdevice(&quot;Error no CUDA devices found!&quot;);
    }

    // Select device
    if (config.device_id &gt;= device_count) {
        THROW exception::InvalidCUDAdevice(&quot;Error setting CUDA device to &#39;%d&#39;, only %d available!&quot;, config.device_id, device_count);
    }
    if (deviceInitialised !=- 1 &amp;&amp; deviceInitialised != config.device_id) {
        THROW exception::InvalidCUDAdevice(&quot;Unable to set CUDA device to &#39;%d&#39; after the CUDASimulation has already initialised on device &#39;%d&#39;.&quot;, config.device_id, deviceInitialised);
    }

    // Check the compute capability of the device, throw an exception if not valid for the executable.
    if (!util::detail::compute_capability::checkComputeCapability(static_cast&lt;int&gt;(config.device_id))) {
        int min_cc = util::detail::compute_capability::minimumCompiledComputeCapability();
        int cc = util::detail::compute_capability::getComputeCapability(static_cast&lt;int&gt;(config.device_id));
        THROW exception::InvalidCUDAComputeCapability(&quot;Error application compiled for CUDA Compute Capability %d and above. Device %u is compute capability %d. Rebuild for SM_%d.&quot;, min_cc, config.device_id, cc, cc);
    }

    cudaStatus = cudaSetDevice(static_cast&lt;int&gt;(config.device_id));
    if (cudaStatus != cudaSuccess) {
        THROW exception::InvalidCUDAdevice(&quot;Unknown error setting CUDA device to &#39;%d&#39;. (%d available)&quot;, config.device_id, device_count);
    }
    // Call cudaFree to initialise the context early
    gpuErrchk(cudaFree(nullptr));

    // Apply changes to submodels
    for (auto &amp;sm : submodel_map) {
        // We&#39;re not actually going to use this value, but it might be useful there later
        // Calling apply config a second time would reinit GPU, which might clear existing gpu allocations etc
        sm.second-&gt;CUDAConfig().device_id = config.device_id;
    }

    // Initialise singletons once a device has been selected.
    initialiseSingletons();

    // We init Random through submodel hierarchy after singletons
    reseed(getSimulationConfig().random_seed);
}

void CUDASimulation::reseed(const uint64_t &amp;seed) {
    SimulationConfig().random_seed = seed;
    singletons-&gt;rng.reseed(seed);

    // Propagate to submodels
    int i = 7;
    for (auto &amp;sm : submodel_map) {
        // Pass random seed on to submodels
        sm.second-&gt;singletons-&gt;rng.reseed(getSimulationConfig().random_seed * i * 23);
        // Mutate seed
        i *= 13;
    }
}
namespace {
    __device__ unsigned int DEVICE_HAS_RESET = 0xDEADBEEF;
    const unsigned int DEVICE_HAS_RESET_FLAG = 0xDEADBEEF;
}  // namespace

void CUDASimulation::initialiseSingletons() {
    // Only do this once.
    if (!singletonsInitialised) {
        // If the device has not been specified, also check the compute capability is OK
        // Check the compute capability of the device, throw an exception if not valid for the executable.
        if (!util::detail::compute_capability::checkComputeCapability(static_cast&lt;int&gt;(config.device_id))) {
            int min_cc = util::detail::compute_capability::minimumCompiledComputeCapability();
            int cc = util::detail::compute_capability::getComputeCapability(static_cast&lt;int&gt;(config.device_id));
            THROW exception::InvalidCUDAComputeCapability(&quot;Error application compiled for CUDA Compute Capability %d and above. Device %u is compute capability %d. Rebuild for SM_%d.&quot;, min_cc, config.device_id, cc, cc);
        }
        gpuErrchk(cudaGetDevice(&amp;deviceInitialised));
        std::unique_lock&lt;std::shared_timed_mutex&gt; maps_lock(active_device_maps_mutex);
        auto &amp;adm = active_device_mutex[deviceInitialised];
        if (active_device_instances.find(deviceInitialised) == active_device_instances.end()) {
            active_device_instances[deviceInitialised] = 0;
        }
        auto &amp;adi = active_device_instances[deviceInitialised];
        std::shared_lock&lt;std::shared_timed_mutex&gt; lock(adm);
        ++(adi);
        // Check if device has been reset
        unsigned int DEVICE_HAS_RESET_CHECK = 0;
        gpuErrchk(cudaMemcpyFromSymbol(&amp;DEVICE_HAS_RESET_CHECK, DEVICE_HAS_RESET, sizeof(unsigned int)));
        if (DEVICE_HAS_RESET_CHECK == DEVICE_HAS_RESET_FLAG) {
            // Device has been reset, purge host mirrors of static objects/singletons
            detail::curve::Curve::getInstance().purge();
            if (singletons) {
                singletons-&gt;rng.purge();
                singletons-&gt;scatter.purge();
            }
            EnvironmentManager::getInstance().purge();
            macro_env.purge();
            // Reset flag
            DEVICE_HAS_RESET_CHECK = 0;  // Any value that doesnt match DEVICE_HAS_RESET_FLAG
            gpuErrchk(cudaMemcpyToSymbol(DEVICE_HAS_RESET, &amp;DEVICE_HAS_RESET_CHECK, sizeof(unsigned int)));
        }
        lock.unlock();
        maps_lock.unlock();
        // Get references to all required singleton and store in the instance.
        singletons = new Singletons(
            detail::curve::Curve::getInstance(),
            EnvironmentManager::getInstance());

        // Reinitialise random for this simulation instance
        singletons-&gt;rng.reseed(getSimulationConfig().random_seed);

        // Pass created RandomManager to host api
        host_api = std::make_unique&lt;HostAPI&gt;(*this, singletons-&gt;rng, singletons-&gt;scatter, agentOffsets, agentData, macro_env, 0, getStream(0));  // Host fns are currently all serial

        for (auto &amp;cm : message_map) {
            cm.second-&gt;init(singletons-&gt;scatter, 0);
        }

        // Populate the environment properties
        if (!submodel) {
            singletons-&gt;environment.init(instance_id, *model-&gt;environment, isPureRTC);
            macro_env.init();
        } else {
            singletons-&gt;environment.init(instance_id, *model-&gt;environment, isPureRTC, mastermodel-&gt;getInstanceID(), *submodel-&gt;subenvironment);
            macro_env.init(*submodel-&gt;subenvironment, mastermodel-&gt;macro_env);
        }

        // Propagate singleton init to submodels
        for (auto &amp;sm : submodel_map) {
            sm.second-&gt;initialiseSingletons();
        }

        // Store the WDDM/TCC driver mode status, for timer class decisions. Result is cached in the anon namespace to avoid multiple queries
        deviceUsingWDDM = util::detail::wddm::deviceIsWDDM();

        singletonsInitialised = true;
    } else {
        int t = -1;
        gpuErrchk(cudaGetDevice(&amp;t));
        if (t != deviceInitialised) {
            THROW exception::CUDAError(&quot;CUDASimulation initialised on device %d, but stepped on device %d.\n&quot;, deviceInitialised, t);
        }
    }
    // Populate the environment properties
    initEnvironmentMgr();

    // Ensure there are enough streams to execute the layer.
    // Taking into consideration if in-layer concurrency is disabled or not.
    unsigned int nStreams = getMaximumLayerWidth();
    this-&gt;createStreams(nStreams);

    // Ensure RTC is set up.
    initialiseRTC();
}

void CUDASimulation::initialiseRTC() {
    // Only do this once.
    if (!rtcInitialised) {
        NVTX_RANGE(&quot;CUDASimulation::initialiseRTC&quot;);
        std::unique_ptr&lt;util::detail::Timer&gt; rtcTimer(new util::detail::SteadyClockTimer());
        rtcTimer-&gt;start();
        // Build any RTC functions
        const auto&amp; am = model-&gt;agents;
        // iterate agents and then agent functions to find any rtc functions or function conditions
        for (auto it = am.cbegin(); it != am.cend(); ++it) {
            auto a_it = agent_map.find(it-&gt;first);
            const auto&amp; mf = it-&gt;second-&gt;functions;
            for (auto it_f = mf.cbegin(); it_f != mf.cend(); ++it_f) {
                // check rtc source to see if this is a RTC function
                if (!it_f-&gt;second-&gt;rtc_source.empty()) {
                    // create CUDA agent RTC function by calling addInstantitateRTCFunction on CUDAAgent with AgentFunctionData
                    a_it-&gt;second-&gt;addInstantitateRTCFunction(*it_f-&gt;second, macro_env);
                }
                // check rtc source to see if the function condition is an rtc condition
                if (!it_f-&gt;second-&gt;rtc_condition_source.empty()) {
                    // create CUDA agent RTC function condition by calling addInstantitateRTCFunction on CUDAAgent with AgentFunctionData
                    a_it-&gt;second-&gt;addInstantitateRTCFunction(*it_f-&gt;second, macro_env, true);
                }
            }
        }

        // Initialise device environment for RTC
        singletons-&gt;environment.initRTC(*this);

        rtcInitialised = true;

        // Record, store and output the elapsed time of the step.
        rtcTimer-&gt;stop();
        this-&gt;elapsedSecondsRTCInitialisation = rtcTimer-&gt;getElapsedSeconds();
        if (getSimulationConfig().timing) {
            fprintf(stdout, &quot;RTC Initialisation Processing time: %.6f s\n&quot;, this-&gt;elapsedSecondsRTCInitialisation);
        }
    }
}

void CUDASimulation::resetDerivedConfig() {
    this-&gt;config = CUDASimulation::Config();
    resetStepCounter();
}


CUDASimulation::Config &amp;CUDASimulation::CUDAConfig() {
    return config;
}
const CUDASimulation::Config &amp;CUDASimulation::getCUDAConfig() const {
    return config;
}
#ifdef VISUALISATION
visualiser::ModelVis &amp;CUDASimulation::getVisualisation() {
    if (!visualisation)
        visualisation = std::make_unique&lt;visualiser::ModelVis&gt;(*this);
    return *visualisation.get();
}
#endif

unsigned int CUDASimulation::getStepCounter() {
    return step_count;
}
void CUDASimulation::resetStepCounter() {
    step_count = 0;
}

void CUDASimulation::initOffsetsAndMap() {
    const auto &amp;md = getModelDescription();
    // Build offsets
    agentOffsets.clear();
    for (const auto &amp;agent : md.agents) {
        agentOffsets.emplace(agent.first, VarOffsetStruct(agent.second-&gt;variables));
    }
    // Build data
    agentData.clear();
    for (const auto &amp;agent : md.agents) {
        AgentDataBufferStateMap agent_states;
        for (const auto&amp;state : agent.second-&gt;states)
            agent_states.emplace(state, AgentDataBuffer());
        agentData.emplace(agent.first, std::move(agent_states));
    }
}

void CUDASimulation::processHostAgentCreation(const unsigned int &amp;streamId) {
    size_t t_bufflen = 0;
    char *t_buff = nullptr;
    char *dt_buff = nullptr;
    // For each agent type
    for (auto &amp;agent : agentData) {
        // We need size of agent
        const VarOffsetStruct &amp;offsets = agentOffsets.at(agent.first);
        // For each state within the agent
        for (auto &amp;state : agent.second) {
            // If the buffer has data
            if (state.second.size()) {
                size_t size_req = offsets.totalSize * state.second.size();
                {  // Ensure we have enough temp memory
                    if (size_req &gt; t_bufflen) {
                        if (t_buff) {
                            free(t_buff);
                            gpuErrchk(cudaFree(dt_buff));
                        }
                        t_buff = reinterpret_cast&lt;char*&gt;(malloc(size_req));
                        gpuErrchk(cudaMalloc(&amp;dt_buff, size_req));
                        t_bufflen = size_req;
                    }
                }
                // Copy buffer memory into a single block
                for (unsigned int i = 0; i &lt; state.second.size(); ++i) {
                    memcpy(t_buff + (i*offsets.totalSize), state.second[i].data, offsets.totalSize);
                }
                // Copy t_buff to device
                gpuErrchk(cudaMemcpyAsync(dt_buff, t_buff, size_req, cudaMemcpyHostToDevice, this-&gt;getStream(streamId)));
                // Scatter to device
                auto &amp;cudaagent = agent_map.at(agent.first);
                cudaagent-&gt;scatterHostCreation(state.first, static_cast&lt;unsigned int&gt;(state.second.size()), dt_buff, offsets, this-&gt;singletons-&gt;scatter, streamId, this-&gt;getStream(streamId));
                // Clear buffer
                state.second.clear();
            }
        }
    }
    // Release temp memory
    if (t_buff) {
        free(t_buff);
        gpuErrchk(cudaFree(dt_buff));
    }
}

void CUDASimulation::RTCSafeCudaMemcpyToSymbol(const void* symbol, const char* rtc_symbol_name, const void* src, size_t count, size_t offset) const {
    // make the mem copy to runtime API symbol
    gpuErrchk(cudaMemcpyToSymbol(symbol, src, count, offset));
    // loop through agents
    for (const auto&amp; agent_pair : agent_map) {
        // loop through any agent functions
        for (const CUDAAgent::CUDARTCFuncMapPair&amp; rtc_func_pair : agent_pair.second-&gt;getRTCFunctions()) {
            CUdeviceptr rtc_dev_ptr = 0;
            // get the RTC device symbol
            rtc_dev_ptr = rtc_func_pair.second-&gt;get_global_ptr(rtc_symbol_name);
            // make the memcpy to the rtc version of the symbol
            gpuErrchkDriverAPI(cuMemcpyHtoD(rtc_dev_ptr + offset, src, count));
        }
    }
}

void CUDASimulation::RTCSafeCudaMemcpyToSymbolAddress(void* ptr, const char* rtc_symbol_name, const void* src, size_t count, size_t offset) const {
    // offset the device pointer by casting to char
    void* offset_ptr = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;char*&gt;(ptr) + offset);
    // make the mem copy to runtime API symbol
    gpuErrchk(cudaMemcpy(offset_ptr, src, count, cudaMemcpyHostToDevice));
    // loop through agents
    for (const auto&amp; agent_pair : agent_map) {
        // loop through any agent functions
        for (const CUDAAgent::CUDARTCFuncMapPair&amp; rtc_func_pair : agent_pair.second-&gt;getRTCFunctions()) {
            CUdeviceptr rtc_dev_ptr = 0;
            // get the RTC device symbol
            rtc_dev_ptr = rtc_func_pair.second-&gt;get_global_ptr(rtc_symbol_name);
            // make the memcpy to the rtc version of the symbol
            gpuErrchkDriverAPI(cuMemcpyHtoD(rtc_dev_ptr + offset, src, count));
        }
    }
}

void CUDASimulation::incrementStepCounter() {
    this-&gt;step_count++;
    this-&gt;singletons-&gt;environment.setProperty({instance_id, &quot;_stepCount&quot;}, this-&gt;step_count);
}

double CUDASimulation::getElapsedTimeSimulation() const {
    // Get the value
    return this-&gt;elapsedSecondsSimulation;
}

double CUDASimulation::getElapsedTimeInitFunctions() const {
    // Get the value
    return this-&gt;elapsedSecondsInitFunctions;
}

double CUDASimulation::getElapsedTimeExitFunctions() const {
    // Get the value
    return this-&gt;elapsedSecondsExitFunctions;
}
double CUDASimulation::getElapsedTimeRTCInitialisation() const {
    // Get the value
    return this-&gt;elapsedSecondsRTCInitialisation;
}

std::vector&lt;double&gt; CUDASimulation::getElapsedTimeSteps() const {
    // returns a copy of the timing vector, to avoid mutabililty issues. This should not be called in a performacne intensive part of the application.
    std::vector&lt;double&gt; rtn = this-&gt;elapsedSecondsPerStep;
    return rtn;
}

double CUDASimulation::getElapsedTimeStep(unsigned int step) const {
    if (step &gt; this-&gt;elapsedSecondsPerStep.size()) {
        THROW exception::OutOfBoundsException(&quot;getElapsedTimeStep out of bounds.\n&quot;);
    }
    return this-&gt;elapsedSecondsPerStep.at(step);
}

void CUDASimulation::initEnvironmentMgr() {
    if (!singletons) {
        THROW exception::UnknownInternalError(&quot;CUDASimulation::initEnvironmentMgr() called before singletons member initialised.&quot;);
    }

    // Set any properties loaded from file during arg parse stage
    for (const auto &amp;prop : env_init) {
        const EnvironmentManager::NamePair np = { instance_id , prop.first.first };
        if (!singletons-&gt;environment.containsProperty(np)) {
            THROW exception::InvalidEnvProperty(&quot;Environment init data contains unexpected environment property &#39;%s&#39;, &quot;
                &quot;in CUDASimulation::initEnvironmentMgr()\n&quot;, prop.first.first.c_str());
        }
        const std::type_index val_type = singletons-&gt;environment.type(np);
        if (val_type == std::type_index(typeid(float))) {
            singletons-&gt;environment.setProperty&lt;float&gt;(np, prop.first.second, *static_cast&lt;float*&gt;(prop.second.ptr));
        } else if (val_type == std::type_index(typeid(double))) {
            singletons-&gt;environment.setProperty&lt;double&gt;(np, prop.first.second, *static_cast&lt;double*&gt;(prop.second.ptr));
        } else if (val_type == std::type_index(typeid(int64_t))) {
            singletons-&gt;environment.setProperty&lt;int64_t&gt;(np, prop.first.second, *static_cast&lt;int64_t*&gt;(prop.second.ptr));
        } else if (val_type == std::type_index(typeid(uint64_t))) {
            singletons-&gt;environment.setProperty&lt;uint64_t&gt;(np, prop.first.second, *static_cast&lt;uint64_t*&gt;(prop.second.ptr));
        } else if (val_type == std::type_index(typeid(int32_t))) {
            singletons-&gt;environment.setProperty&lt;int32_t&gt;(np, prop.first.second, *static_cast&lt;int32_t*&gt;(prop.second.ptr));
        } else if (val_type == std::type_index(typeid(uint32_t))) {
            singletons-&gt;environment.setProperty&lt;uint32_t&gt;(np, prop.first.second, *static_cast&lt;uint32_t*&gt;(prop.second.ptr));
        } else if (val_type == std::type_index(typeid(int16_t))) {
            singletons-&gt;environment.setProperty&lt;int16_t&gt;(np, prop.first.second, *static_cast&lt;int16_t*&gt;(prop.second.ptr));
        } else if (val_type == std::type_index(typeid(uint16_t))) {
            singletons-&gt;environment.setProperty&lt;uint16_t&gt;(np, prop.first.second, *static_cast&lt;uint16_t*&gt;(prop.second.ptr));
        } else if (val_type == std::type_index(typeid(int8_t))) {
            singletons-&gt;environment.setProperty&lt;int8_t&gt;(np, prop.first.second, *static_cast&lt;int8_t*&gt;(prop.second.ptr));
        } else if (val_type == std::type_index(typeid(uint8_t))) {
            singletons-&gt;environment.setProperty&lt;uint8_t&gt;(np, prop.first.second, *static_cast&lt;uint8_t*&gt;(prop.second.ptr));
        } else {
            THROW exception::InvalidEnvProperty(&quot;Environment init data contains environment property &#39;%s&#39; of unsupported type &#39;%s&#39;, &quot;
                &quot;this should have been caught during file parsing, &quot;
                &quot;in CUDASimulation::initEnvironmentMgr()\n&quot;, prop.first.first.c_str(), val_type.name());
        }
    }
    // Clear init
    env_init.clear();
}
void CUDASimulation::resetLog() {
    run_log-&gt;step.clear();
    run_log-&gt;exit = LogFrame();
    run_log-&gt;random_seed = SimulationConfig().random_seed;
    run_log-&gt;step_log_frequency = step_log_config ? step_log_config-&gt;frequency : 0;
}
void CUDASimulation::processStepLog() {
    if (!step_log_config)
        return;
    if (step_count % step_log_config-&gt;frequency != 0)
        return;
    // Iterate members of step log to build the step log frame
    std::map&lt;std::string, util::Any&gt; environment_log;
    for (const auto &amp;prop_name : step_log_config-&gt;environment) {
        // Fetch the named environment prop
        environment_log.emplace(prop_name, singletons-&gt;environment.getPropertyAny(instance_id, prop_name));
    }
    std::map&lt;util::StringPair, std::pair&lt;std::map&lt;LoggingConfig::NameReductionFn, util::Any&gt;, unsigned int&gt;&gt; agents_log;
    for (const auto &amp;name_state : step_log_config-&gt;agents) {
        // Create the named sub map
        const std::string &amp;agent_name = name_state.first.first;
        const std::string &amp;agent_state = name_state.first.second;
        HostAgentAPI host_agent = host_api-&gt;agent(agent_name, agent_state);
        auto &amp;agent_state_log = agents_log.emplace(name_state.first, std::make_pair(std::map&lt;LoggingConfig::NameReductionFn, util::Any&gt;(), UINT_MAX)).first-&gt;second;
        // Log individual variable reductions
        for (const auto &amp;name_reduction : *name_state.second.first) {
            // Perform the corresponding reduction
            auto result = name_reduction.function(host_agent, name_reduction.name);
            // Store the result
            agent_state_log.first.emplace(name_reduction, std::move(result));
        }
        // Log count of agents in state
        if (name_state.second.second) {
            agent_state_log.second = host_api-&gt;agent(agent_name, agent_state).count();
        }
    }

    // Append to step log
    run_log-&gt;step.push_back(LogFrame(std::move(environment_log), std::move(agents_log), step_count));
}

void CUDASimulation::processExitLog() {
    if (!exit_log_config)
        return;
    // Iterate members of step log to build the step log frame
    std::map&lt;std::string, util::Any&gt; environment_log;
    for (const auto &amp;prop_name : exit_log_config-&gt;environment) {
        // Fetch the named environment prop
        environment_log.emplace(prop_name, singletons-&gt;environment.getPropertyAny(instance_id, prop_name));
    }
    std::map&lt;util::StringPair, std::pair&lt;std::map&lt;LoggingConfig::NameReductionFn, util::Any&gt;, unsigned int&gt;&gt; agents_log;
    for (const auto &amp;name_state : exit_log_config-&gt;agents) {
        // Create the named sub map
        const std::string &amp;agent_name = name_state.first.first;
        const std::string &amp;agent_state = name_state.first.second;
        HostAgentAPI host_agent = host_api-&gt;agent(agent_name, agent_state);
        auto &amp;agent_state_log = agents_log.emplace(name_state.first, std::make_pair(std::map&lt;LoggingConfig::NameReductionFn, util::Any&gt;(), UINT_MAX)).first-&gt;second;
        // Log individual variable reductions
        for (const auto &amp;name_reduction : *name_state.second.first) {
            // Perform the corresponding reduction
            auto result = name_reduction.function(host_agent, name_reduction.name);
            // Store the result
            agent_state_log.first.emplace(name_reduction, std::move(result));
        }
        // Log count of agents in state
        if (name_state.second.second) {
            agent_state_log.second = host_api-&gt;agent(agent_name, agent_state).count();
        }
    }

    // Set Log
    run_log-&gt;exit = LogFrame(std::move(environment_log), std::move(agents_log), step_count);
}
const RunLog &amp;CUDASimulation::getRunLog() const {
    return *run_log;
}

void CUDASimulation::createStreams(const unsigned int nStreams) {
    // There should always be atleast 1 stream, as some tests require the 0th stream even when there is no concurrent work to be done.
    unsigned int totalStreams = std::max(nStreams, 1u);
    while (streams.size() &lt; totalStreams) {
        cudaStream_t stream = 0;
        gpuErrchk(cudaStreamCreate(&amp;stream));
        streams.push_back(stream);
    }
}

cudaStream_t CUDASimulation::getStream(const unsigned int n) {
    // Return the appropriate stream, unless concurrency is disabled in which case always stream 0.
    if (this-&gt;streams.size() &lt;= n) {
        unsigned int nStreams = getMaximumLayerWidth();
        this-&gt;createStreams(nStreams);
    }

    if (getCUDAConfig().inLayerConcurrency &amp;&amp; n &lt; streams.size()) {
        return streams.at(n);
    } else {
        return streams.at(0);
    }
}

void CUDASimulation::destroyStreams() {
    // Destroy streams.
    for (auto stream : streams) {
        gpuErrchk(cudaStreamDestroy(stream));
    }
    streams.clear();
}

void CUDASimulation::synchronizeAllStreams() {
    // Destroy streams.
    for (auto stream : streams) {
        gpuErrchk(cudaStreamSynchronize(stream));
    }
}

void CUDASimulation::assignAgentIDs() {
    NVTX_RANGE(&quot;CUDASimulation::assignAgentIDs&quot;);
    if (!agent_ids_have_init) {
        // Ensure singletons have been initialised
        initialiseSingletons();

        for (auto &amp;a : agent_map) {
            a.second-&gt;assignIDs(*host_api);  // This is cheap if the CUDAAgent thinks it&#39;s IDs are already assigned
        }
        agent_ids_have_init = true;
    }
}

}  // namespace flamegpu
</pre></div>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, University of Sheffield.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXX-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-XXXXXXX-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>