
.. _program_listing_file_include_flamegpu_runtime_messaging_MessageArray3D_MessageArray3DDevice.cuh:

Program Listing for File MessageArray3DDevice.cuh
=================================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_messaging_MessageArray3D_MessageArray3DDevice.cuh>` (``include/flamegpu/runtime/messaging/MessageArray3D/MessageArray3DDevice.cuh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEARRAY3D_MESSAGEARRAY3DDEVICE_CUH_
   #define INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEARRAY3D_MESSAGEARRAY3DDEVICE_CUH_
   
   
   #include "flamegpu/runtime/messaging/MessageArray3D.h"
   #include "flamegpu/runtime/messaging/MessageBruteForce/MessageBruteForceDevice.cuh"
   
   
   namespace flamegpu {
   
   class MessageArray3D::In {
       friend class Message;
   
    public:
       class Message {
           const MessageArray3D::In &_parent;
           size_type index;
   
        public:
           __device__ Message(const MessageArray3D::In &parent, const size_type &_index) : _parent(parent), index(_index) {}
           __device__ bool operator==(const Message& rhs) const { return  this->index == rhs.index; }
           __device__ bool operator!=(const Message& rhs) const { return  this->index != rhs.index; }
           __device__ size_type getIndex() const { return this->index; }
           template<typename T, size_type N>
           __device__ T getVariable(const char(&variable_name)[N]) const;
           template<typename T, MessageNone::size_type N, unsigned int M>
           __device__ T getVariable(const char(&variable_name)[M], const unsigned int &index) const;
       };
       class WrapFilter {
           friend class Message;
   
        public:
           class Message {
               const WrapFilter&_parent;
               int relative_cell[3];
               size_type index_1d = 0;
   
            public:
               __device__ Message(const WrapFilter&parent, const int &relative_x, const int &relative_y, const int &relative_z)
                   : _parent(parent) {
                   relative_cell[0] = relative_x;
                   relative_cell[1] = relative_y;
                   relative_cell[2] = relative_z;
               }
               __device__ bool operator==(const Message& rhs) const {
                   return this->relative_cell[0] == rhs.relative_cell[0]
                       && this->relative_cell[1] == rhs.relative_cell[1]
                       && this->relative_cell[2] == rhs.relative_cell[2];
                       // && this->_parent.loc[0] == rhs._parent.loc[0]
                       // && this->_parent.loc[1] == rhs._parent.loc[1]
                       // && this->_parent.loc[2] == rhs._parent.loc[2];
               }
               __device__ bool operator!=(const Message& rhs) const { return !(*this == rhs); }
               inline __device__ Message& operator++();
               __device__ size_type getX() const {
                   return (this->_parent.loc[0] + relative_cell[0] + this->_parent.metadata->dimensions[0]) % this->_parent.metadata->dimensions[0];
               }
               __device__ size_type getY() const {
                   return (this->_parent.loc[1] + relative_cell[1] + this->_parent.metadata->dimensions[1]) % this->_parent.metadata->dimensions[1];
               }
               __device__ size_type getZ() const {
                   return (this->_parent.loc[2] + relative_cell[2] + this->_parent.metadata->dimensions[2]) % this->_parent.metadata->dimensions[2];
               }
               template<typename T, unsigned int N>
               __device__ T getVariable(const char(&variable_name)[N]) const;
               template<typename T, MessageNone::size_type N, unsigned int M>
               __device__ T getVariable(const char(&variable_name)[M], const unsigned int& index) const;
           };
           class iterator {
               Message _message;
   
            public:
               __device__ iterator(const WrapFilter&parent, const int &relative_x, const int &relative_y, const int &relative_z)
                   : _message(parent, relative_x, relative_y, relative_z) {
                   // Increment to find first message
                   ++_message;
               }
               __device__ iterator& operator++() { ++_message;  return *this; }
               __device__ iterator operator++(int) {
                   iterator temp = *this;
                   ++*this;
                   return temp;
               }
               __device__ bool operator==(const iterator& rhs) const { return  _message == rhs._message; }
               __device__ bool operator!=(const iterator& rhs) const { return  _message != rhs._message; }
               __device__ Message& operator*() { return _message; }
               __device__ Message* operator->() { return &_message; }
           };
           inline __device__ WrapFilter(const MetaData *_metadata, const detail::curve::Curve::NamespaceHash &_combined_hash, const size_type &x, const size_type &y, const size_type &z, const size_type &_radius);
           inline __device__ iterator begin(void) const {
               // Bin before initial bin, as the constructor calls increment operator
               return iterator(*this, -static_cast<int>(radius), -static_cast<int>(radius), -static_cast<int>(radius)-1);
           }
           inline __device__ iterator end(void) const {
               // Final bin, as the constructor calls increment operator
               return iterator(*this, radius, radius, radius);
           }
   
        private:
           size_type loc[3];
           const size_type radius;
           const MetaData *metadata;
           detail::curve::Curve::NamespaceHash combined_hash;
       };
       class Filter {
           friend class Message;
   
        public:
           class Message {
               const Filter& _parent;
               int relative_cell[3];
               size_type index_1d = 0;
   
            public:
               __device__ Message(const Filter& parent, const int& relative_x, const int& relative_y, const int& relative_z)
                   : _parent(parent) {
                   relative_cell[0] = relative_x;
                   relative_cell[1] = relative_y;
                   relative_cell[2] = relative_z;
               }
               __device__ bool operator==(const Message& rhs) const {
                   return this->relative_cell[0] == rhs.relative_cell[0]
                       && this->relative_cell[1] == rhs.relative_cell[1]
                       && this->relative_cell[2] == rhs.relative_cell[2];
                       // && this->_parent.loc[0] == rhs._parent.loc[0]
                       // && this->_parent.loc[1] == rhs._parent.loc[1]
                       // && this->_parent.loc[2] == rhs._parent.loc[2];
               }
               __device__ bool operator!=(const Message& rhs) const { return !(*this == rhs); }
               inline __device__ Message& operator++();
               __device__ size_type getX() const {
                   return this->_parent.loc[0] + relative_cell[0];
               }
               __device__ size_type getY() const {
                   return this->_parent.loc[1] + relative_cell[1];
               }
               __device__ size_type getZ() const {
                   return this->_parent.loc[2] + relative_cell[2];
               }
               template<typename T, unsigned int N>
               __device__ T getVariable(const char(&variable_name)[N]) const;
               template<typename T, MessageNone::size_type N, unsigned int M>
               __device__ T getVariable(const char(&variable_name)[M], const unsigned int& index) const;
           };
           class iterator {
               Message _message;
   
            public:
               __device__ iterator(const Filter& parent, const int& relative_x, const int& relative_y, const int& relative_z)
                   : _message(parent, relative_x, relative_y, relative_z) {
                   // Increment to find first message
                   ++_message;
               }
               __device__ iterator& operator++() { ++_message;  return *this; }
               __device__ iterator operator++(int) {
                   iterator temp = *this;
                   ++* this;
                   return temp;
               }
               __device__ bool operator==(const iterator& rhs) const { return  _message == rhs._message; }
               __device__ bool operator!=(const iterator& rhs) const { return  _message != rhs._message; }
               __device__ Message& operator*() { return _message; }
               __device__ Message* operator->() { return &_message; }
           };
           inline __device__ Filter(const MetaData* _metadata, const detail::curve::Curve::NamespaceHash& _combined_hash, const size_type& x, const size_type& y, const size_type& z, const size_type& _radius);
           inline __device__ iterator begin(void) const {
               // Bin before initial bin, as the constructor calls increment operator
               return iterator(*this,  min_cell[0], min_cell[1], min_cell[2] - 1);
           }
           inline __device__ iterator end(void) const {
               // Final bin, as the constructor calls increment operator
               return iterator(*this, max_cell[0], max_cell[1], max_cell[2]);
           }
   
        private:
           size_type loc[3];
           int min_cell[3];
           int max_cell[3];
           const MetaData* metadata;
           detail::curve::Curve::NamespaceHash combined_hash;
       };
       __device__ In(detail::curve::Curve::NamespaceHash agentfn_hash, detail::curve::Curve::NamespaceHash message_hash, const void *_metadata)
           : combined_hash(agentfn_hash + message_hash)
           , metadata(reinterpret_cast<const MetaData*>(_metadata))
       { }
       inline __device__ WrapFilter wrap(const size_type &x, const size_type &y, const size_type &z, const size_type &radius = 1) const {
   #if !defined(SEATBELTS) || SEATBELTS
           if (radius == 0) {
               DTHROW("%u is not a valid radius for accessing Array3D message lists.\n", radius);
           } else if ((radius * 2) + 1 > metadata->dimensions[0] ||
                      (radius * 2) + 1 > metadata->dimensions[1] ||
                      (radius * 2) + 1 > metadata->dimensions[2]) {
               unsigned int min_r = metadata->dimensions[0] < metadata->dimensions[1] ? metadata->dimensions[0] : metadata->dimensions[1];
               min_r = min_r < metadata->dimensions[2] ? min_r : metadata->dimensions[2];
               min_r = min_r % 2 == 0 ? min_r - 2: min_r - 1;
               min_r /= 2;
               DTHROW("%u is not a valid radius for accessing Array3D message lists, as the diameter of messages accessed exceeds one or more of the message list dimensions (%u, %u, %u)."
               " Maximum supported radius for this message list is %u.\n",
               radius, metadata->dimensions[0], metadata->dimensions[1], metadata->dimensions[2], min_r);
           } else if (x >= metadata->dimensions[0] ||
                      y >= metadata->dimensions[1] ||
                      z >= metadata->dimensions[2]) {
               DTHROW("(%u, %u, %u) is not a valid position for iterating an Array3D message list of dimensions (%u, %u, %u), location must be within bounds.",
                   x, y, z, metadata->dimensions[0], metadata->dimensions[1], metadata->dimensions[2]);
           }
   #endif
           return WrapFilter(metadata, combined_hash, x, y, z, radius);
       }
       inline __device__ Filter operator()(const size_type& x, const size_type& y, const size_type& z, const size_type& radius = 1) const {
   #if !defined(SEATBELTS) || SEATBELTS
           if (radius == 0) {
               DTHROW("%u is not a valid radius for accessing Array3D message lists.\n", radius);
           } else if (x >= metadata->dimensions[0] ||
                      y >= metadata->dimensions[1] ||
                      z >= metadata->dimensions[2]) {
               DTHROW("(%u, %u, %u) is not a valid position for iterating an Array3D message list of dimensions (%u, %u, %u), location must be within bounds.",
                   x, y, z, metadata->dimensions[0], metadata->dimensions[1], metadata->dimensions[2]);
           }
   #endif
           return Filter(metadata, combined_hash, x, y, z, radius);
       }
       __device__ size_type getDimX() const {
           return metadata->dimensions[0];
       }
       __device__ size_type getDimY() const {
           return metadata->dimensions[1];
       }
       __device__ size_type getDimZ() const {
           return metadata->dimensions[2];
       }
       __device__ size_type size(void) const {
           return metadata->length;
       }
       __device__ Message at(const size_type &x, const size_type &y, const size_type &z) const {
   #if !defined(SEATBELTS) || SEATBELTS
           if (x >= metadata->dimensions[0] || y >= metadata->dimensions[1] || z >= metadata->dimensions[2]) {
               DTHROW("Index is out of bounds for Array3D messagelist ([%u, %u, %u] >= [%u, %u, %u]).\n", x, y, z, metadata->dimensions[0], metadata->dimensions[1], metadata->dimensions[2]);
           }
   #endif
           const size_type index_1d =
               z * metadata->dimensions[0] * metadata->dimensions[1]  +
               y * metadata->dimensions[0]  +
               x;
           return Message(*this, index_1d);
       }
   
    private:
       detail::curve::Curve::NamespaceHash combined_hash;
       const MetaData * const metadata;
   };
   
   class MessageArray3D::Out {
    public:
       __device__ Out(detail::curve::Curve::NamespaceHash agentfn_hash, detail::curve::Curve::NamespaceHash message_hash, const void *_metadata, unsigned int *scan_flag_messageOutput)
           : combined_hash(agentfn_hash + message_hash)
           , scan_flag(scan_flag_messageOutput)
           , metadata(reinterpret_cast<const MetaData*>(_metadata))
       { }
       inline __device__ void setIndex(const size_type &x, const size_type &y, const size_type &z) const;
       template<typename T, unsigned int N>
       __device__ void setVariable(const char(&variable_name)[N], T value) const;
       template<typename T, unsigned int N, unsigned int M>
       __device__ void setVariable(const char(&variable_name)[M], const unsigned int& index, T value) const;
   
    protected:
       detail::curve::Curve::NamespaceHash combined_hash;
       unsigned int *scan_flag;
       const MetaData * const metadata;
   };
   
   template<typename T, unsigned int N>
   __device__ T MessageArray3D::In::Message::getVariable(const char(&variable_name)[N]) const {
   #if !defined(SEATBELTS) || SEATBELTS
       // Ensure that the message is within bounds.
       if (index >= this->_parent.metadata->length) {
           DTHROW("Invalid Array3D message, unable to get variable '%s'.\n", variable_name);
           return static_cast<T>(0);
       }
   #endif
       // get the value from curve using the stored hashes and message index.
       return detail::curve::Curve::getMessageVariable<T>(variable_name, this->_parent.combined_hash, index);
   }
   template<typename T, MessageNone::size_type N, unsigned int M> __device__
   T MessageArray3D::In::Message::getVariable(const char(&variable_name)[M], const unsigned int& array_index) const {
       // simple indexing assumes index is the thread number (this may change later)
   #if !defined(SEATBELTS) || SEATBELTS
       // Ensure that the message is within bounds.
       if (index >= this->_parent.metadata->length) {
           DTHROW("Invalid Array3D message, unable to get variable '%s'.\n", variable_name);
           return {};
       }
   #endif
       // get the value from curve using the stored hashes and message index.
       T value = detail::curve::Curve::getMessageArrayVariable<T, N>(variable_name, this->_parent.combined_hash, index, array_index);
       return value;
   }
   template<typename T, unsigned int N>
   __device__ T MessageArray3D::In::WrapFilter::Message::getVariable(const char(&variable_name)[N]) const {
   #if !defined(SEATBELTS) || SEATBELTS
       // Ensure that the message is within bounds.
       if (index_1d >= this->_parent.metadata->length) {
           DTHROW("Invalid Array3D message, unable to get variable '%s'.\n", variable_name);
           return static_cast<T>(0);
       }
   #endif
       // get the value from curve using the stored hashes and message index.
       return detail::curve::Curve::getMessageVariable<T>(variable_name, this->_parent.combined_hash, index_1d);
   }
   template<typename T, MessageNone::size_type N, unsigned int M> __device__
   T MessageArray3D::In::WrapFilter::Message::getVariable(const char(&variable_name)[M], const unsigned int& array_index) const {
       // simple indexing assumes index is the thread number (this may change later)
   #if !defined(SEATBELTS) || SEATBELTS
       // Ensure that the message is within bounds.
       if (index_1d >= this->_parent.metadata->length) {
           DTHROW("Invalid Array3D message, unable to get variable '%s'.\n", variable_name);
           return {};
       }
   #endif
       // get the value from curve using the stored hashes and message index.
       T value = detail::curve::Curve::getMessageArrayVariable<T, N>(variable_name, this->_parent.combined_hash, index, array_index);
       return value;
   }
   template<typename T, unsigned int N>
   __device__ T MessageArray3D::In::Filter::Message::getVariable(const char(&variable_name)[N]) const {
   #if !defined(SEATBELTS) || SEATBELTS
       // Ensure that the message is within bounds.
       if (index_1d >= this->_parent.metadata->length) {
           DTHROW("Invalid Array3D message, unable to get variable '%s'.\n", variable_name);
           return static_cast<T>(0);
       }
   #endif
       // get the value from curve using the stored hashes and message index.
       return detail::curve::Curve::getMessageVariable<T>(variable_name, this->_parent.combined_hash, index_1d);
   }
   template<typename T, MessageNone::size_type N, unsigned int M> __device__
   T MessageArray3D::In::Filter::Message::getVariable(const char(&variable_name)[M], const unsigned int& array_index) const {
       // simple indexing assumes index is the thread number (this may change later)
   #if !defined(SEATBELTS) || SEATBELTS
       // Ensure that the message is within bounds.
       if (index_1d >= this->_parent.metadata->length) {
           DTHROW("Invalid Array3D message, unable to get variable '%s'.\n", variable_name);
           return {};
       }
   #endif
       // get the value from curve using the stored hashes and message index.
       T value = detail::curve::Curve::getMessageArrayVariable<T, N>(variable_name, this->_parent.combined_hash, index, array_index);
       return value;
   }
   
   template<typename T, unsigned int N>
   __device__ void MessageArray3D::Out::setVariable(const char(&variable_name)[N], T value) const {  // message name or variable name
       if (variable_name[0] == '_') {
   #if !defined(SEATBELTS) || SEATBELTS
           DTHROW("Variable names starting with '_' are reserved for internal use, with '%s', in MessageArray3D::Out::setVariable().\n", variable_name);
   #endif
           return;  // Fail silently
       }
       unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
   
       // set the variable using curve
       detail::curve::Curve::setMessageVariable<T>(variable_name, combined_hash, value, index);
   
       // setIndex() sets the optional message scan flag
   }
   template<typename T, unsigned int N, unsigned int M>
   __device__ void MessageArray3D::Out::setVariable(const char(&variable_name)[M], const unsigned int& array_index, T value) const {
       if (variable_name[0] == '_') {
   #if !defined(SEATBELTS) || SEATBELTS
           DTHROW("Variable names starting with '_' are reserved for internal use, with '%s', in MessageArray3D::Out::setVariable().\n", variable_name);
   #endif
           return;  // Fail silently
       }
       unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
   
       // set the variable using curve
       detail::curve::Curve::setMessageArrayVariable<T, N>(variable_name, combined_hash, value, index, array_index);
   
       // setIndex() sets the optional message scan flag
   }
   
   __device__ inline void MessageArray3D::Out::setIndex(const size_type &x, const size_type &y, const size_type &z) const {
       unsigned int index = (blockDim.x * blockIdx.x) + threadIdx.x;
       size_type index_1d =
           z * metadata->dimensions[0] * metadata->dimensions[1] +
           y * metadata->dimensions[0] +
           x;
   #if !defined(SEATBELTS) || SEATBELTS
       if (x >= metadata->dimensions[0] ||
           y >= metadata->dimensions[1] ||
           z >= metadata->dimensions[2]) {
           DTHROW("MessageArray3D index [%u, %u, %u] is out of bounds [%u, %u, %u]\n", x, y, z, metadata->dimensions[0], metadata->dimensions[1], metadata->dimensions[2]);
       }
   #endif
   
       // set the variable using curve
       detail::curve::Curve::setMessageVariable<size_type>("___INDEX", combined_hash, index_1d, index);
   
       // Set scan flag incase the message is optional
       this->scan_flag[index] = 1;
   }
   __device__ inline MessageArray3D::In::WrapFilter::WrapFilter(const MetaData *_metadata, const detail::curve::Curve::NamespaceHash &_combined_hash, const size_type &x, const size_type &y, const size_type &z, const size_type &_radius)
       : radius(_radius)
       , metadata(_metadata)
       , combined_hash(_combined_hash) {
       loc[0] = x;
       loc[1] = y;
       loc[2] = z;
   }
   __device__ inline MessageArray3D::In::WrapFilter::Message& MessageArray3D::In::WrapFilter::Message::operator++() {
       if (relative_cell[2] >= static_cast<int>(_parent.radius)) {
           relative_cell[2] = -static_cast<int>(_parent.radius);
           if (relative_cell[1] >= static_cast<int>(_parent.radius)) {
               relative_cell[1] = -static_cast<int>(_parent.radius);
               relative_cell[0]++;
           } else {
               relative_cell[1]++;
           }
       } else {
           relative_cell[2]++;
       }
       // Skip origin cell
       if (relative_cell[0] == 0 && relative_cell[1] == 0 && relative_cell[2] == 0) {
           relative_cell[2]++;
       }
       // Wrap over boundaries
       const unsigned int their_x = (this->_parent.loc[0] + relative_cell[0] + this->_parent.metadata->dimensions[0]) % this->_parent.metadata->dimensions[0];
       const unsigned int their_y = (this->_parent.loc[1] + relative_cell[1] + this->_parent.metadata->dimensions[1]) % this->_parent.metadata->dimensions[1];
       const unsigned int their_z = (this->_parent.loc[2] + relative_cell[2] + this->_parent.metadata->dimensions[2]) % this->_parent.metadata->dimensions[2];
       // Solve to 1 dimensional bin index
       index_1d = their_z * this->_parent.metadata->dimensions[0] * this->_parent.metadata->dimensions[1] +
                  their_y * this->_parent.metadata->dimensions[0] +
                  their_x;
       return *this;
   }
   __device__ inline MessageArray3D::In::Filter::Filter(const MetaData* _metadata, const detail::curve::Curve::NamespaceHash& _combined_hash, const size_type& x, const size_type& y, const size_type& z, const size_type& _radius)
       : metadata(_metadata)
       , combined_hash(_combined_hash) {
       loc[0] = x;
       loc[1] = y;
       loc[2] = z;
       min_cell[0] = static_cast<int>(x) - static_cast<int>(_radius) < 0 ? -static_cast<int>(x) : - static_cast<int>(_radius);
       min_cell[1] = static_cast<int>(y) - static_cast<int>(_radius) < 0 ? -static_cast<int>(y) : - static_cast<int>(_radius);
       min_cell[2] = static_cast<int>(z) - static_cast<int>(_radius) < 0 ? -static_cast<int>(z) : - static_cast<int>(_radius);
       max_cell[0] = x + _radius >= _metadata->dimensions[0] ? static_cast<int>(_metadata->dimensions[0]) - 1 - static_cast<int>(x) : static_cast<int>(_radius);
       max_cell[1] = y + _radius >= _metadata->dimensions[1] ? static_cast<int>(_metadata->dimensions[1]) - 1 - static_cast<int>(y) : static_cast<int>(_radius);
       max_cell[2] = z + _radius >= _metadata->dimensions[2] ? static_cast<int>(_metadata->dimensions[2]) - 1 - static_cast<int>(z) : static_cast<int>(_radius);
   }
   __device__ inline MessageArray3D::In::Filter::Message& MessageArray3D::In::Filter::Message::operator++() {
       if (relative_cell[2] >= _parent.max_cell[2]) {
           relative_cell[2] = _parent.min_cell[2];
           if (relative_cell[1] >= _parent.max_cell[1]) {
               relative_cell[1] = _parent.min_cell[1];
               relative_cell[0]++;
           } else {
               relative_cell[1]++;
           }
       } else {
           relative_cell[2]++;
       }
       // Skip origin cell
       if (relative_cell[0] == 0 && relative_cell[1] == 0 && relative_cell[2] == 0) {
           if (relative_cell[2] >= _parent.max_cell[2]) {
               relative_cell[2] = _parent.min_cell[2];
               if (relative_cell[1] >= _parent.max_cell[1]) {
                   relative_cell[1] = _parent.min_cell[1];
                   relative_cell[0]++;
               } else {
                   relative_cell[1]++;
               }
           } else {
               relative_cell[2]++;
           }
       }
       // Solve to 1 dimensional bin index
       index_1d = (this->_parent.loc[2] + relative_cell[2]) * this->_parent.metadata->dimensions[0] * this->_parent.metadata->dimensions[1] +
                  (this->_parent.loc[1] + relative_cell[1]) * this->_parent.metadata->dimensions[0] +
                  (this->_parent.loc[0] + relative_cell[0]);
       return *this;
   }
   
   }  // namespace flamegpu
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_MESSAGING_MESSAGEARRAY3D_MESSAGEARRAY3DDEVICE_CUH_
