
.. _program_listing_file_include_flamegpu_model_ModelDescription.h:

Program Listing for File ModelDescription.h
===========================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_model_ModelDescription.h>` (``include/flamegpu/model/ModelDescription.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_MODEL_MODELDESCRIPTION_H_
   #define INCLUDE_FLAMEGPU_MODEL_MODELDESCRIPTION_H_
   
   #include <map>
   #include <memory>
   #include <set>
   #include <string>
   
   
   #include "flamegpu/gpu/CUDAEnsemble.h"
   #include "flamegpu/model/ModelData.h"
   #include "flamegpu/gpu/CUDASimulation.h"
   #include "flamegpu/runtime/messaging/MessageBruteForce/MessageBruteForceHost.h"
   
   namespace flamegpu {
   
   class AgentDescription;
   class LayerDescription;
   class SubModelDescription;
   class DependencyNode;
   struct ModelData;
   
   class ModelDescription {
       friend CUDASimulation::CUDASimulation(const ModelDescription& _model, int argc, const char** argv);
       friend CUDAEnsemble::CUDAEnsemble(const ModelDescription& model, int argc, const char** argv);
       friend class RunPlanVector;
       friend class RunPlan;
       friend class LoggingConfig;
    public:
       explicit ModelDescription(const std::string &model_name);
       ModelDescription(const ModelDescription &other_model) = delete;
       ModelDescription(ModelDescription &&other_model) noexcept = delete;
       ModelDescription& operator=(const ModelDescription &other_model) = delete;
       ModelDescription& operator=(ModelDescription &&other_model) noexcept = delete;
       bool operator==(const ModelDescription& rhs) const;
       bool operator!=(const ModelDescription& rhs) const;
   
       AgentDescription& newAgent(const std::string &agent_name);
       AgentDescription& Agent(const std::string &agent_name);
   
       template<typename MessageType>
       typename MessageType::Description& newMessage(const std::string &message_name) {
           if (!hasMessage<MessageType>(message_name)) {
               auto rtn = std::shared_ptr<typename MessageType::Data>(new typename MessageType::Data(model, message_name));
               model->messages.emplace(message_name, rtn);
               return *reinterpret_cast<typename MessageType::Description*>(rtn->description.get());
           }
           THROW exception::InvalidMessageName("Message with name '%s' already exists, "
               "in ModelDescription::newMessage().",
               message_name.c_str());
       }
       MessageBruteForce::Description& newMessage(const std::string &message_name);
       template<typename MessageType>
       typename MessageType::Description& Message(const std::string &message_name) {
           auto rtn = model->messages.find(message_name);
           if (rtn != model->messages.end()) {
               if (auto r = std::dynamic_pointer_cast<typename MessageType::Data>(rtn->second)) {
                   return *reinterpret_cast<typename MessageType::Description*>(r->description.get());
               }
               THROW exception::InvalidMessageName("Message ('%s') is not of correct type, "
                   "in ModelDescription::Message().",
                   message_name.c_str());
           }
           THROW exception::InvalidMessageName("Message ('%s') was not found, "
               "in ModelDescription::Message().",
               message_name.c_str());
       }
       MessageBruteForce::Description& Message(const std::string &message_name);
       EnvironmentDescription& Environment();
       SubModelDescription &newSubModel(const std::string &submodel_name, const ModelDescription &submodel_description);
       SubModelDescription &SubModel(const std::string &submodel_name);
   
       LayerDescription& newLayer(const std::string &name = "");
       LayerDescription& Layer(const std::string &name);
       LayerDescription& Layer(const ModelData::size_type &layer_index);
   
       void addInitFunction(FLAMEGPU_INIT_FUNCTION_POINTER func_p);
       void addStepFunction(FLAMEGPU_STEP_FUNCTION_POINTER func_p);
       void addExitFunction(FLAMEGPU_EXIT_FUNCTION_POINTER func_p);
   #ifdef SWIG
   
       inline void addInitFunctionCallback(HostFunctionCallback *func_callback);
       inline void addStepFunctionCallback(HostFunctionCallback *func_callback);
       inline void addExitFunctionCallback(HostFunctionCallback *func_callback);
   #endif
   
       void addExitCondition(FLAMEGPU_EXIT_CONDITION_POINTER func_p);
   #ifdef SWIG
   
       inline void addExitConditionCallback(HostFunctionConditionCallback *func_callback);
   #endif
   
       std::string getName() const;
       const DependencyGraph& getDependencyGraph() const;
       void addExecutionRoot(DependencyNode& root);
       void generateLayers();
       void generateDependencyGraphDOTDiagram(std::string outputFileName) const;
       std::string getConstructedLayersString() const;
       const AgentDescription& getAgent(const std::string &agent_name) const;
       template<typename MessageType>
       const typename MessageType::Description& getMessage(const std::string &message_name) const {
           auto rtn = model->messages.find(message_name);
           if (rtn != model->messages.end()) {
               if (auto r = std::dynamic_pointer_cast<typename MessageType::Data>(rtn->second)) {
                   return *reinterpret_cast<typename MessageType::Description*>(r->description.get());
               }
               THROW exception::InvalidMessageType("Message ('%s') is not of correct type, "
                   "in ModelDescription::getMessage().",
                   message_name.c_str());
           }
           THROW exception::InvalidMessageName("Message ('%s') was not found, "
               "in ModelDescription::getMessage().",
               message_name.c_str());
       }
       const MessageBruteForce::Description& getMessage(const std::string &message_name) const;
       const SubModelDescription& getSubModel(const std::string &submodel_name) const;
       const EnvironmentDescription& getEnvironment() const;
       const LayerDescription& getLayer(const std::string &name) const;
       const LayerDescription& getLayer(const ModelData::size_type &layer_index) const;
   
       bool hasAgent(const std::string &agent_name) const;
       template<typename MessageType>
       bool hasMessage(const std::string &message_name) const {
           auto a = model->messages.find(message_name);
           if (a != model->messages.end()) {
               if (std::dynamic_pointer_cast<typename MessageType::Data>(a->second))
                   return true;
           }
           return false;
       }
       bool hasMessage(const std::string &message_name) const;
       bool hasLayer(const std::string &name) const;
       bool hasLayer(const ModelData::size_type &layer_index) const;
       bool hasSubModel(const std::string &submodel_name) const;
   
       ModelData::size_type getAgentsCount() const;
       ModelData::size_type getMessagesCount() const;
       ModelData::size_type getLayersCount() const;
   
    private:
        std::shared_ptr<ModelData> model;
   };
   
   #ifdef SWIG
   void ModelDescription::addInitFunctionCallback(HostFunctionCallback* func_callback) {
       if (std::find(model->initFunctionCallbacks.begin(), model->initFunctionCallbacks.end(), func_callback) != model->initFunctionCallbacks.end()) {
               THROW exception::InvalidHostFunc("Attempted to add same init function callback twice,"
                   "in ModelDescription::addInitFunctionCallback()");
       }
       model->initFunctionCallbacks.push_back(func_callback);
   }
   void ModelDescription::addStepFunctionCallback(HostFunctionCallback* func_callback) {
       if (std::find(model->stepFunctionCallbacks.begin(), model->stepFunctionCallbacks.end(), func_callback) != model->stepFunctionCallbacks.end()) {
               THROW exception::InvalidHostFunc("Attempted to add same step function callback twice,"
                   "in ModelDescription::addStepFunctionCallback()");
       }
       model->stepFunctionCallbacks.push_back(func_callback);
   }
   void ModelDescription::addExitFunctionCallback(HostFunctionCallback* func_callback) {
       if (std::find(model->exitFunctionCallbacks.begin(), model->exitFunctionCallbacks.end(), func_callback) != model->exitFunctionCallbacks.end()) {
               THROW exception::InvalidHostFunc("Attempted to add same exit function callback twice,"
                   "in ModelDescription::addExitFunctionCallback()");
       }
       model->exitFunctionCallbacks.push_back(func_callback);
   }
   void ModelDescription::addExitConditionCallback(HostFunctionConditionCallback *func_callback) {
       if (std::find(model->exitConditionCallbacks.begin(), model->exitConditionCallbacks.end(), func_callback) != model->exitConditionCallbacks.end()) {
               THROW exception::InvalidHostFunc("Attempted to add same exit condition callback twice,"
                   "in ModelDescription::addExitConditionCallback()");
       }
       model->exitConditionCallbacks.push_back(func_callback);
   }
   #endif
   
   }  // namespace flamegpu
   
   #endif  // INCLUDE_FLAMEGPU_MODEL_MODELDESCRIPTION_H_
