
.. _program_listing_file_include_flamegpu_runtime_utility_HostEnvironment.cuh:

Program Listing for File HostEnvironment.cuh
============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_runtime_utility_HostEnvironment.cuh>` (``include/flamegpu/runtime/utility/HostEnvironment.cuh``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_RUNTIME_UTILITY_HOSTENVIRONMENT_CUH_
   #define INCLUDE_FLAMEGPU_RUNTIME_UTILITY_HOSTENVIRONMENT_CUH_
   
   #include <cuda_runtime.h>
   #include <device_launch_parameters.h>  // Required for SEATBELTS=OFF builds for some reason.
   
   #include <unordered_map>
   #include <array>
   #include <string>
   #include <utility>
   #include <set>
   #include <vector>
   
   #include "flamegpu/gpu/CUDAMacroEnvironment.h"
   #include "flamegpu/gpu/detail/CUDAErrorChecking.cuh"
   #include "flamegpu/runtime/utility/EnvironmentManager.cuh"
   #include "flamegpu/runtime/utility/HostMacroProperty.cuh"
   
   namespace flamegpu {
   
   class HostEnvironment {
       friend class HostAPI;
   
    protected:
       explicit HostEnvironment(const unsigned int &instance_id, CUDAMacroEnvironment &_macro_env);
       EnvironmentManager &env_mgr;
       CUDAMacroEnvironment& macro_env;
       const unsigned int instance_id;
   
    public:
       template<typename T>
       T getProperty(const std::string &name) const;
       template<typename T, EnvironmentManager::size_type N>
       std::array<T, N> getProperty(const std::string &name) const;
       template<typename T>
       T getProperty(const std::string &name, const EnvironmentManager::size_type &index) const;
   #ifdef SWIG
   
       template<typename T>
       std::vector<T> getPropertyArray(const std::string &name) const;
   #endif
   
       template<typename T>
       T setProperty(const std::string &name, const T &value) const;
       template<typename T, EnvironmentManager::size_type N>
       std::array<T, N> setProperty(const std::string &name, const std::array<T, N> &value) const;
       template<typename T>
       T setProperty(const std::string &name, const EnvironmentManager::size_type &index, const T &value) const;
   #ifdef SWIG
   
       template<typename T>
       std::vector<T> setPropertyArray(const std::string &name, const std::vector<T> &value) const;
   #endif
   
       template<typename T, unsigned int I = 1, unsigned int J = 1, unsigned int K = 1, unsigned int W = 1>
       HostMacroProperty<T, I, J, K, W> getMacroProperty(const std::string& name) const;
   #ifdef SWIG
   
       template<typename T>
       HostMacroProperty_swig<T> getMacroProperty_swig(const std::string& name) const;
   #endif
   };
   
   template<typename T>
   T HostEnvironment::setProperty(const std::string &name, const T &value) const {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in HostEnvironment::set().");
       }
       return env_mgr.setProperty<T>({ instance_id, name }, value);
   }
   template<typename T, EnvironmentManager::size_type N>
   std::array<T, N> HostEnvironment::setProperty(const std::string &name, const std::array<T, N> &value) const {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in HostEnvironment::set().");
       }
       return env_mgr.setProperty<T, N>({ instance_id, name }, value);
   }
   template<typename T>
   T HostEnvironment::setProperty(const std::string &name, const EnvironmentManager::size_type &index, const T &value) const {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in HostEnvironment::set().");
       }
       return env_mgr.setProperty<T>({ instance_id, name }, index, value);
   }
   #ifdef SWIG
   template<typename T>
   std::vector<T> HostEnvironment::setPropertyArray(const std::string &name, const std::vector<T> &value) const {
       if (!name.empty() && name[0] == '_') {
           THROW exception::ReservedName("Environment property names cannot begin with '_', this is reserved for internal usage, "
               "in HostEnvironment::setArray().");
       }
       return env_mgr.setPropertyArray<T>({ instance_id, name }, value);
   }
   #endif  // SWIG
   
   template<typename T>
   T HostEnvironment::getProperty(const std::string &name) const  {
       return env_mgr.getProperty<T>({ instance_id, name });
   }
   template<typename T, EnvironmentManager::size_type N>
   std::array<T, N> HostEnvironment::getProperty(const std::string &name) const  {
       return env_mgr.getProperty<T, N>({ instance_id, name });
   }
   template<typename T>
   T HostEnvironment::getProperty(const std::string &name, const EnvironmentManager::size_type &index) const  {
       return env_mgr.getProperty<T>({ instance_id, name }, index);
   }
   #ifdef SWIG
   template<typename T>
   std::vector<T> HostEnvironment::getPropertyArray(const std::string& name) const {
       return env_mgr.getPropertyArray<T>({instance_id, name});
   }
   #endif  // SWIG
   
   template<typename T, unsigned int I, unsigned int J, unsigned int K, unsigned int W>
   HostMacroProperty<T, I, J, K, W> HostEnvironment::getMacroProperty(const std::string& name) const {
       return macro_env.getProperty<T, I, J, K, W>(name);
   }
   
   #ifdef SWIG
   template<typename T>
   HostMacroProperty_swig<T> HostEnvironment::getMacroProperty_swig(const std::string& name) const {
       return macro_env.getProperty_swig<T>(name);
   }
   #endif
   }  // namespace flamegpu
   
   #endif  // INCLUDE_FLAMEGPU_RUNTIME_UTILITY_HOSTENVIRONMENT_CUH_
