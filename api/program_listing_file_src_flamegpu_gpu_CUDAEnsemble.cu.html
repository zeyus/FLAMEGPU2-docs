

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Program Listing for File CUDAEnsemble.cu &mdash; FLAME GPU 2 0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: black" >
          

          
            <a href="../index.html" class="icon icon-home"> FLAME GPU 2
          

          
            
            <img src="../_static/flamegpu2-icon-notext-128.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
<li class="toctree-l1"><a class="reference internal" href="class_view_hierarchy.html">Class Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_view_hierarchy.html">File Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="unabridged_api.html">Full API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FLAME GPU 2</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File CUDAEnsemble.cu</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/program_listing_file_src_flamegpu_gpu_CUDAEnsemble.cu.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-cudaensemble-cu">
<span id="program-listing-file-src-flamegpu-gpu-cudaensemble-cu"></span><h1>Program Listing for File CUDAEnsemble.cu<a class="headerlink" href="#program-listing-for-file-cudaensemble-cu" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_flamegpu_gpu_CUDAEnsemble.cu.html#file-src-flamegpu-gpu-cudaensemble-cu"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/flamegpu/gpu/CUDAEnsemble.cu</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#include &quot;flamegpu/gpu/CUDAEnsemble.h&quot;

#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;memory&gt;
#include &lt;thread&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

#include &quot;flamegpu/model/ModelDescription.h&quot;
#include &quot;flamegpu/sim/RunPlanVec.h&quot;
#include &quot;flamegpu/util/compute_capability.cuh&quot;
#include &quot;flamegpu/util/SteadyClockTimer.h&quot;
#include &quot;flamegpu/gpu/CUDASimulation.h&quot;
#include &quot;flamegpu/io/factory.h&quot;
#include &quot;flamegpu/util/filesystem.h&quot;
#include &quot;flamegpu/sim/LoggingConfig.h&quot;
#include &quot;flamegpu/sim/SimRunner.h&quot;
#include &quot;flamegpu/sim/LogFrame.h&quot;
#include &quot;flamegpu/sim/SimLogger.h&quot;


CUDAEnsemble::CUDAEnsemble(const ModelDescription&amp; _model, int argc, const char** argv)
    : model(_model.model-&gt;clone()) {
    initialise(argc, argv);
}
CUDAEnsemble::~CUDAEnsemble() {
    // Nothing to do
}



void CUDAEnsemble::simulate(const RunPlanVec &amp;plans) {
    // Validate that RunPlan model matches CUDAEnsemble model
    if (*plans.environment != this-&gt;model-&gt;environment-&gt;properties) {
        THROW InvalidArgument(&quot;RunPlan is for a different ModelDescription, in CUDAEnsemble::simulate()&quot;);
    }
    // Validate/init output directories
    if (!config.out_directory.empty()) {
        // Validate out format is right
        config.out_format = WriterFactory::detectSupportedFileExt(config.out_format);
        if (config.out_format.empty()) {
            THROW InvalidArgument(&quot;The out_directory config option also requires the out_format options to be set to a suitable type (e.g. &#39;json&#39;, &#39;xml&#39;), in CUDAEnsemble::simulate()&quot;);
        }
        // Create any missing directories
        try {
            util::filesystem::recursive_create_dir(config.out_directory);
        } catch (const std::exception &amp;e) {
            THROW InvalidArgument(&quot;Unable to use output directory &#39;%s&#39;, in CUDAEnsemble::simulate(): %s&quot;, config.out_directory.c_str(), e.what());
        }
        for (const auto &amp;p : plans) {
            const auto subdir = p.getOutputSubdirectory();
            if (!subdir.empty()) {
                path sub_path = config.out_directory;
                try {
                    sub_path.append(subdir);
                    util::filesystem::recursive_create_dir(sub_path);
                } catch (const std::exception &amp;e) {
                    THROW InvalidArgument(&quot;Unable to use output subdirectory &#39;%s&#39;, in CUDAEnsemble::simulate(): %s&quot;, sub_path.generic_string().c_str(), e.what());
                }
            }
        }
    }
    // Purge run logs, and resize ready for new runs
    // Resize means we can setup logs during execution out of order, without risk of list being reallocated
    run_logs.clear();
    run_logs.resize(plans.size());
    // Workout how many devices and runner we will be executing
    int ct = -1;
    gpuErrchk(cudaGetDeviceCount(&amp;ct));
    std::set&lt;int&gt; devices;
    if (config.devices.size()) {
        devices = config.devices;
    } else {
        for (int i = 0; i &lt; ct; ++i) {
        devices.emplace(i);
        }
    }
    // Check that each device is capable, and init cuda context
    for (auto d = devices.begin(); d != devices.end(); ++d) {
        if (!util::compute_capability::checkComputeCapability(*d)) {
            fprintf(stderr, &quot;FLAMEGPU2 has not been built with an appropriate compute capability for device %d, this device will not be used.\n&quot;, *d);
            d = devices.erase(d);
            --d;
        } else {
            gpuErrchk(cudaSetDevice(*d));
            gpuErrchk(cudaFree(nullptr));
        }
    }
    // Return to device 0 (or check original device first?)
    gpuErrchk(cudaSetDevice(0));

    // Init runners, devices * concurrent runs
    std::atomic&lt;unsigned int&gt; err_ct = {0};
    std::atomic&lt;unsigned int&gt; next_run = {0};
    const size_t TOTAL_RUNNERS = devices.size() * config.concurrent_runs;
    SimRunner *runners = static_cast&lt;SimRunner *&gt;(malloc(sizeof(SimRunner) * TOTAL_RUNNERS));

    // Log Time (We can&#39;t use CUDA events here, due to device resets)
    auto ensemble_timer = util::SteadyClockTimer();
    ensemble_timer.start();
    // Reset the elapsed time.
    ensemble_elapsed_time = 0.f;

    // Logging thread-safety items
    std::queue&lt;unsigned int&gt; log_export_queue;
    std::mutex log_export_queue_mutex;
    std::condition_variable log_export_queue_cdn;

    // Init with placement new
    {
        if (!config.silent)
            printf(&quot;\rCUDAEnsemble progress: %u/%u&quot;, 0, static_cast&lt;unsigned int&gt;(plans.size()));
        unsigned int i = 0;
        for (auto &amp;d : devices) {
            for (unsigned int j = 0; j &lt; config.concurrent_runs; ++j) {
                new (&amp;runners[i++]) SimRunner(model, err_ct, next_run, plans, step_log_config, exit_log_config, d, j, !config.silent, run_logs, log_export_queue, log_export_queue_mutex, log_export_queue_cdn);
            }
        }
    }

    // Init log worker
    SimLogger *log_worker = nullptr;
    if (!config.out_directory.empty() &amp;&amp; !config.out_format.empty()) {
        log_worker = new SimLogger(run_logs, plans, config.out_directory, config.out_format, log_export_queue, log_export_queue_mutex, log_export_queue_cdn);
    } else if (!config.out_directory.empty() ^ !config.out_format.empty())  {
        fprintf(stderr, &quot;Warning: Only 1 of out_directory and out_format is set, both must be set for logging to commence to file.\n&quot;);
    }

    // Wait for all runners to exit
    for (unsigned int i = 0; i &lt; TOTAL_RUNNERS; ++i) {
        runners[i].thread.join();
        runners[i].~SimRunner();
    }
    // Notify logger to exit
    if (log_worker) {
        {
            std::lock_guard&lt;std::mutex&gt; lck(log_export_queue_mutex);
            log_export_queue.push(UINT_MAX);
        }
        log_export_queue_cdn.notify_one();
        log_worker-&gt;thread.join();
        delete log_worker;
        log_worker = nullptr;
    }

    // Record and store the elapsed time
    ensemble_timer.stop();
    ensemble_elapsed_time = ensemble_timer.getElapsedMilliseconds();

    // Ensemble has finished, print summary
    if (!config.silent) {
        printf(&quot;\rCUDAEnsemble completed %u runs successfully!\n&quot;, static_cast&lt;unsigned int&gt;(plans.size() - err_ct));
        if (err_ct)
            printf(&quot;There were a total of %u errors.\n&quot;, err_ct.load());
    }
    if (config.timing) {
        printf(&quot;Ensemble time elapsed: %fms\n&quot;, ensemble_elapsed_time);
    }

    // Free memory
    free(runners);
}

void CUDAEnsemble::initialise(int argc, const char** argv) {
    if (!checkArgs(argc, argv)) {
        exit(EXIT_FAILURE);
    }
}
int CUDAEnsemble::checkArgs(int argc, const char** argv) {
    // Parse optional args
    int i = 1;
    for (; i &lt; argc; i++) {
        // Get arg as lowercase
        std::string arg(argv[i]);
        std::transform(arg.begin(), arg.end(), arg.begin(), [](unsigned char c) { return std::use_facet&lt; std::ctype&lt;char&gt;&gt;(std::locale()).tolower(c); });
        // --concurrent &lt;runs&gt;, Number of concurrent simulations to run per device
        if (arg.compare(&quot;--concurrent&quot;) == 0 || arg.compare(&quot;-c&quot;) == 0) {
            if (i + 1 &gt;= argc) {
                fprintf(stderr, &quot;%s requires a trailing argument\n&quot;, arg.c_str());
                return false;
            }
            config.concurrent_runs = static_cast&lt;unsigned int&gt;(strtoul(argv[++i], nullptr, 0));
            continue;
        }
        // --devices &lt;string&gt;, comma separated list of uints
        if (arg.compare(&quot;--devices&quot;) == 0 || arg.compare(&quot;-d&quot;) == 0) {
            if (i + 1 &gt;= argc) {
                fprintf(stderr, &quot;%s requires a trailing argument\n&quot;, arg.c_str());
                return false;
            }
            // Split and parse string
            std::string device_string = argv[++i];
            device_string += &quot;,&quot;;  // Append comma, to catch final item
            int max_id = 0;  // Catch max device so we can validate it exists
            size_t pos;
            while ((pos = device_string.find(&quot;,&quot;)) != std::string::npos) {
                const unsigned int id = static_cast&lt;unsigned int&gt;(strtoul(device_string.substr(0, pos).c_str(), nullptr, 0));
                if (id == 0 &amp;&amp; (device_string.length() &lt; 2 || (device_string[0] != &#39;0&#39; || device_string[1] != &#39;,&#39;))) {
                    fprintf(stderr, &quot;&#39;%s&#39; is not a valid device index.\n&quot;, device_string.substr(0, pos).c_str());
                    printHelp(argv[0]);
                    return false;
                }
                max_id = static_cast&lt;int&gt;(id) &gt; max_id ? id : max_id;
                config.devices.emplace(id);
                device_string.erase(0, pos + 1);
            }
            int ct = -1;
            gpuErrchk(cudaGetDeviceCount(&amp;ct));
            if (max_id &gt;= ct) {
                fprintf(stderr, &quot;Device id %u exceeds available CUDA devices %d\n&quot;, max_id, ct);
                printHelp(argv[0]);
                return false;
            }
            continue;
        }
        // -o/--out &lt;directory&gt; &lt;filetype&gt;, Quiet FLAME GPU output.
        if (arg.compare(&quot;--out&quot;) == 0 || arg.compare(&quot;-o&quot;) == 0) {
            if (i + 2 &gt;= argc) {
                fprintf(stderr, &quot;%s requires two trailing arguments\n&quot;, arg.c_str());
                return false;
            }
            // Validate output directory is valid (and recursively create it if necessary)
            try {
                path out_directory = argv[++i];
                util::filesystem::recursive_create_dir(out_directory);
                config.out_directory = out_directory.generic_string();
            } catch (const std::exception &amp;e) {
                // Catch any exceptions, probably std::filesystem::filesystem_error, but other implementation defined errors also possible
                fprintf(stderr, &quot;Unable to use &#39;%s&#39; as output directory:\n%s\n&quot;, argv[i], e.what());
                return false;
            }
            // Validate output format is available in io module
            config.out_format = WriterFactory::detectSupportedFileExt(argv[++i]);
            if (config.out_format.empty()) {
                fprintf(stderr, &quot;&#39;%s&#39; is not a supported output file type.\n&quot;, argv[i]);
                return false;
            }
            continue;
        }
        // -s/--silent, Don&#39;t report progress to console.
        if (arg.compare(&quot;--silent&quot;) == 0 || arg.compare(&quot;-s&quot;) == 0) {
            config.silent = true;
            continue;
        }
        // -t/--timing, Output timing information to stdout
        if (arg.compare(&quot;--timing&quot;) == 0 || arg.compare(&quot;-t&quot;) == 0) {
            config.timing = true;
            continue;
        }
        fprintf(stderr, &quot;Unexpected argument: %s\n&quot;, arg.c_str());
        printHelp(argv[0]);
        return false;
    }
    return true;
}
void CUDAEnsemble::printHelp(const char *executable) {
    printf(&quot;Usage: %s [optional arguments]\n&quot;, executable);
    printf(&quot;Optional Arguments:\n&quot;);
    const char *line_fmt = &quot;%-18s %s\n&quot;;
    printf(line_fmt, &quot;-d, --devices &lt;device ids&gt;&quot;, &quot;Comma separated list of device ids to be used&quot;);
    printf(line_fmt, &quot;&quot;, &quot;By default, all available devices will be used.&quot;);
    printf(line_fmt, &quot;-c, --concurrent &lt;runs&gt;&quot;, &quot;Number of concurrent simulations to run per device&quot;);
    printf(line_fmt, &quot;&quot;, &quot;By default, 4 will be used.&quot;);
    printf(line_fmt, &quot;-o, --out &lt;directory&gt; &lt;filetype&gt;&quot;, &quot;Directory and filetype for ensemble outputs&quot;);
    printf(line_fmt, &quot;-s, --silent&quot;, &quot;Don&#39;t print progress information to console&quot;);
    printf(line_fmt, &quot;-t, --timing&quot;, &quot;Output timing information to stdout&quot;);
}
void CUDAEnsemble::setStepLog(const StepLoggingConfig &amp;stepConfig) {
    // Validate ModelDescription matches
    if (*stepConfig.model != *model) {
      THROW InvalidArgument(&quot;Model descriptions attached to LoggingConfig and CUDAEnsemble do not match, in CUDAEnsemble::setStepLog()\n&quot;);
    }
    // Set internal config
    step_log_config = std::make_shared&lt;StepLoggingConfig&gt;(stepConfig);
}
void CUDAEnsemble::setExitLog(const LoggingConfig &amp;exitConfig) {
    // Validate ModelDescription matches
    if (*exitConfig.model != *model) {
      THROW InvalidArgument(&quot;Model descriptions attached to LoggingConfig and CUDAEnsemble do not match, in CUDAEnsemble::setExitLog()\n&quot;);
    }
    // Set internal config
    exit_log_config = std::make_shared&lt;LoggingConfig&gt;(exitConfig);
}
const std::vector&lt;RunLog&gt; &amp;CUDAEnsemble::getLogs() {
    return run_logs;
}
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, University of Sheffield.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>