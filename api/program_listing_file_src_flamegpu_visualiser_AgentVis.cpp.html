

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Program Listing for File AgentVis.cpp &mdash; FLAME GPU 2 0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: black" >
          

          
            <a href="../index.html" class="icon icon-home"> FLAME GPU 2
          

          
            
            <img src="../_static/flamegpu2-icon-notext-128.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
<li class="toctree-l1"><a class="reference internal" href="class_view_hierarchy.html">Class Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_view_hierarchy.html">File Hierarchy</a></li>
<li class="toctree-l1"><a class="reference internal" href="unabridged_api.html">Full API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FLAME GPU 2</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File AgentVis.cpp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/program_listing_file_src_flamegpu_visualiser_AgentVis.cpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-agentvis-cpp">
<span id="program-listing-file-src-flamegpu-visualiser-agentvis-cpp"></span><h1>Program Listing for File AgentVis.cpp<a class="headerlink" href="#program-listing-for-file-agentvis-cpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_flamegpu_visualiser_AgentVis.cpp.html#file-src-flamegpu-visualiser-agentvis-cpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/flamegpu/visualiser/AgentVis.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#include &quot;flamegpu/visualiser/AgentVis.h&quot;

#include &quot;flamegpu/gpu/CUDAAgent.h&quot;
#include &quot;flamegpu/model/AgentData.h&quot;
#include &quot;flamegpu/visualiser/color/ColorFunction.h&quot;
#include &quot;flamegpu/visualiser/color/StaticColor.h&quot;
#include &quot;FLAMEGPU_Visualisation.h&quot;  // TODO - This should probably be flamegpu2-visualiser/FLAMEGPU_Visualisation.h?

AgentVis::AgentVis(CUDAAgent &amp;_agent, const std::shared_ptr&lt;AutoPalette&gt;&amp; autopalette)
    : owned_auto_palette(nullptr)
    , agent(_agent)
    , agentData(_agent.getAgentDescription()) {
    if (_agent.getAgentDescription().variables.find(&quot;x&quot;) != _agent.getAgentDescription().variables.end()) {
        core_tex_buffers.emplace(TexBufferConfig::Position_x, &quot;x&quot;);
    }
    if (_agent.getAgentDescription().variables.find(&quot;y&quot;) != _agent.getAgentDescription().variables.end()) {
        core_tex_buffers.emplace(TexBufferConfig::Position_y, &quot;y&quot;);
    }
    if (_agent.getAgentDescription().variables.find(&quot;z&quot;) != _agent.getAgentDescription().variables.end()) {
        core_tex_buffers.emplace(TexBufferConfig::Position_z, &quot;z&quot;);
    }
    if (autopalette) {
        setColor(autopalette-&gt;next());
        auto_palette = autopalette;  // setColor() clears auto_palette
    }
}

AgentStateVis &amp;AgentVis::State(const std::string &amp;state_name) {
    // If state exists
    if (agentData.states.find(state_name) != agentData.states.end()) {
        // If state is not already in vis map
        auto visAgentState = states.find(state_name);
        if (visAgentState == states.end()) {
            // Create new vis agent
            auto &amp;rtn = states.emplace(state_name, AgentStateVis(*this, state_name)).first-&gt;second;
            auto ap = auto_palette.lock();
            if (ap) {
                const Color c = ap-&gt;next();
                rtn.setColor(c);
            }
            return rtn;
        }
        return visAgentState-&gt;second;
    }
    THROW InvalidAgentName(&quot;State &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
        &quot;in AgentVis::State()\n&quot;,
        state_name.c_str(), agentData.name.c_str());
}


void AgentVis::setXVariable(const std::string &amp;var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setXVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Position_x].agentVariableName = var_name;
}
void AgentVis::setYVariable(const std::string &amp;var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setYVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Position_y].agentVariableName = var_name;
}
void AgentVis::setZVariable(const std::string &amp;var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setZVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Position_z].agentVariableName = var_name;
}
void AgentVis::setForwardXVariable(const std::string&amp; var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setDirectionXVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Forward_x].agentVariableName = var_name;
}
void AgentVis::setForwardYVariable(const std::string&amp; var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setDirectionYVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Forward_y].agentVariableName = var_name;
}
void AgentVis::setForwardZVariable(const std::string&amp; var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setDirectionZVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Forward_z].agentVariableName = var_name;
}
void AgentVis::setUpXVariable(const std::string&amp; var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setUpXVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Up_x].agentVariableName = var_name;
}
void AgentVis::setUpYVariable(const std::string&amp; var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setUpYVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Up_y].agentVariableName = var_name;
}
void AgentVis::setUpZVariable(const std::string&amp; var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setUpZVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Up_z].agentVariableName = var_name;
}
void AgentVis::setYawVariable(const std::string&amp; var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setYawVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Heading].agentVariableName = var_name;
}
void AgentVis::setPitchVariable(const std::string&amp; var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setPitchVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Pitch].agentVariableName = var_name;
}
void AgentVis::setRollVariable(const std::string&amp; var_name) {
    if (agentData.variables.find(var_name) == agentData.variables.end()) {
        THROW InvalidAgentVar(&quot;Variable &#39;%s&#39; was not found within agent &#39;%s&#39;, &quot;
            &quot;in AgentVis::setRollVariable()\n&quot;,
            var_name.c_str(), agentData.name.c_str());
    }
    core_tex_buffers[TexBufferConfig::Bank].agentVariableName = var_name;
}
void AgentVis::clearXVariable() {
    core_tex_buffers.erase(TexBufferConfig::Position_x);
}
void AgentVis::clearYVariable() {
    core_tex_buffers.erase(TexBufferConfig::Position_y);
}
void AgentVis::clearZVariable() {
    core_tex_buffers.erase(TexBufferConfig::Position_z);
}
void AgentVis::clearForwardXVariable() {
    core_tex_buffers.erase(TexBufferConfig::Forward_x);
}
void AgentVis::clearForwardYVariable() {
    core_tex_buffers.erase(TexBufferConfig::Forward_y);
}
void AgentVis::clearForwardZVariable() {
    core_tex_buffers.erase(TexBufferConfig::Forward_z);
}
void AgentVis::clearUpXVariable() {
    core_tex_buffers.erase(TexBufferConfig::Up_x);
}
void AgentVis::clearUpYVariable() {
    core_tex_buffers.erase(TexBufferConfig::Up_y);
}
void AgentVis::clearUpZVariable() {
    core_tex_buffers.erase(TexBufferConfig::Up_z);
}
void AgentVis::clearYawVariable() {
    core_tex_buffers.erase(TexBufferConfig::Heading);
}
void AgentVis::clearPitchVariable() {
    core_tex_buffers.erase(TexBufferConfig::Pitch);
}
void AgentVis::clearRollVariable() {
    core_tex_buffers.erase(TexBufferConfig::Bank);
}
std::string AgentVis::getXVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Position_x);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getYVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Position_y);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getZVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Position_z);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getForwardXVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Forward_x);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getForwardYVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Forward_y);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getForwardZVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Forward_z);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getUpXVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Up_x);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getUpYVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Up_y);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getUpZVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Up_z);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getYawVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Heading);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getPitchVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Pitch);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
std::string AgentVis::getRollVariable() const {
    const auto it = core_tex_buffers.find(TexBufferConfig::Bank);
    return it != core_tex_buffers.end() ? it-&gt;second.agentVariableName : &quot;&quot;;
}
void AgentVis::initBindings(std::unique_ptr&lt;FLAMEGPU_Visualisation&gt; &amp;vis) {
    // Pass each state&#39;s vis config to the visualiser
    for (auto &amp;state : agentData.states) {
        // For each agent state, give the visualiser
        // vis config
        AgentStateConfig &amp;vc = this-&gt;defaultConfig;  // Default to parent if child hasn&#39;t been configured
        if (states.find(state) != states.end()) {
            vc = states.at(state).config;
        }
        vis-&gt;addAgentState(agentData.name, state, vc, core_tex_buffers, vc.tex_buffers);
    }
}
void AgentVis::requestBufferResizes(std::unique_ptr&lt;FLAMEGPU_Visualisation&gt; &amp;vis) {
    for (auto &amp;state : agentData.states) {
        auto &amp;state_map = agent.state_map.at(state);
        vis-&gt;requestBufferResizes(agentData.name, state, state_map-&gt;getSize());
    }
}
void AgentVis::updateBuffers(std::unique_ptr&lt;FLAMEGPU_Visualisation&gt; &amp;vis) {
    for (auto &amp;state : agentData.states) {
        AgentStateConfig &amp;state_config = this-&gt;defaultConfig;  // Default to parent if child hasn&#39;t been configured
        if (states.find(state) != states.end()) {
            state_config = states.at(state).config;
        }
        auto&amp; state_data_map = agent.state_map.at(state);
        // Update buffer pointers inside the map
        // These get changed per state, but should be fine
        for (auto &amp;tb : core_tex_buffers) {
            tb.second.t_d_ptr = state_data_map-&gt;getVariablePointer(tb.second.agentVariableName);
        }
        for (auto &amp;tb : state_config.tex_buffers) {
            tb.second.t_d_ptr = state_data_map-&gt;getVariablePointer(tb.second.agentVariableName);
        }
        // Pass the updated map to the update function
        vis-&gt;updateAgentStateBuffer(agentData.name, state, state_data_map-&gt;getSize(), core_tex_buffers, state_config.tex_buffers);
    }
}

void AgentVis::setModel(const std::string &amp;modelPath, const std::string &amp;texturePath) {
    AgentStateConfig::setString(&amp;defaultConfig.model_path, modelPath);
    if (!texturePath.empty()) {
        AgentStateConfig::setString(&amp;defaultConfig.model_texture, texturePath);
        clearColor();
    }
    // Apply to all states which haven&#39;t had the setting overriden
    for (auto &amp;s : states) {
        if (!s.second.configFlags.model_path) {
            AgentStateConfig::setString(&amp;s.second.config.model_path, modelPath);
            if (!texturePath.empty())
                AgentStateConfig::setString(&amp;s.second.config.model_texture, texturePath);
        }
    }
}
void AgentVis::setModel(const Stock::Models::Model &amp;model) {
    AgentStateConfig::setString(&amp;defaultConfig.model_path, model.modelPath);
    if (model.texturePath &amp;&amp; model.texturePath[0] != &#39;\0&#39;)
        AgentStateConfig::setString(&amp;defaultConfig.model_texture, model.texturePath);
    // Apply to all states which haven&#39;t had the setting overridden
    for (auto &amp;s : states) {
        if (!s.second.configFlags.model_path) {
            AgentStateConfig::setString(&amp;s.second.config.model_path, model.modelPath);
            if (model.texturePath &amp;&amp; model.texturePath[0] != &#39;\0&#39;)
                AgentStateConfig::setString(&amp;s.second.config.model_texture, model.texturePath);
        }
    }
}
void AgentVis::setModelScale(float xLen, float yLen, float zLen) {
    if (xLen &lt;= 0 || yLen &lt;= 0 || zLen &lt;= 0) {
        THROW InvalidArgument(&quot;AgentVis::setModelScale(): Invalid argument, lengths must all be positive.\n&quot;);
    }
    defaultConfig.model_scale[0] = xLen;
    defaultConfig.model_scale[1] = yLen;
    defaultConfig.model_scale[2] = zLen;
    // Apply to all states which haven&#39;t had the setting overriden
    for (auto &amp;s : states) {
        if (!s.second.configFlags.model_scale) {
            s.second.config.model_scale[0] = xLen;
            s.second.config.model_scale[1] = yLen;
            s.second.config.model_scale[2] = zLen;
        }
    }
}
void AgentVis::setModelScale(float maxLen) {
  if (maxLen &lt;= 0) {
        THROW InvalidArgument(&quot;AgentVis::setModelScale(): Invalid argument, maxLen must be positive.\n&quot;);
    }
    defaultConfig.model_scale[0] = -maxLen;
    // Apply to all states which haven&#39;t had the setting overriden
    for (auto &amp;s : states) {
        if (!s.second.configFlags.model_scale) {
            s.second.config.model_scale[0] = -maxLen;
        }
    }
}

void AgentVis::setAutoPalette(const Palette&amp; ap) {
    owned_auto_palette = std::make_shared&lt;AutoPalette&gt;(ap);
    auto_palette = owned_auto_palette;
}
void AgentVis::setColor(const ColorFunction&amp; cf) {
    // Remove old, we only ever want 1 color value
    defaultConfig.tex_buffers.erase(TexBufferConfig::Color);
    if (!cf.getAgentVariableName().empty() &amp;&amp; !cf.getSamplerName().empty())
        defaultConfig.tex_buffers.emplace(TexBufferConfig::Color, CustomTexBufferConfig{ cf.getAgentVariableName(), cf.getSamplerName() });
    defaultConfig.color_shader_src = cf.getSrc();
    auto_palette.reset();
    owned_auto_palette = nullptr;
    // Clear texture, can&#39;t have both colour and texture
    if (defaultConfig.model_texture) {
        free(const_cast&lt;char*&gt;(defaultConfig.model_texture));
    }
}
void AgentVis::clearColor() {
    defaultConfig.tex_buffers.erase(TexBufferConfig::Color);
    defaultConfig.color_shader_src = &quot;&quot;;
    auto_palette.reset();
    owned_auto_palette = nullptr;
}
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, University of Sheffield.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>