
.. _program_listing_file_include_flamegpu_sim_RunPlanVec.h:

Program Listing for File RunPlanVec.h
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_sim_RunPlanVec.h>` (``include/flamegpu/sim/RunPlanVec.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_SIM_RUNPLANVEC_H_
   #define INCLUDE_FLAMEGPU_SIM_RUNPLANVEC_H_
   
   #include <random>
   #include <vector>
   #include <unordered_map>
   #include <string>
   #include <memory>
   
   #include "flamegpu/sim/RunPlan.h"
   #include "flamegpu/exception/FGPUStaticAssert.h"
   
   class ModelDescription;
   class EnvironmentDescription;
   
   class RunPlanVec : private std::vector<RunPlan>  {
       friend class RunPlan;
       friend class SimRunner;
       friend void CUDAEnsemble::simulate(const RunPlanVec &plans);
   
    public:
       explicit RunPlanVec(const ModelDescription &model, unsigned int initial_length);
       void setRandomSimulationSeed(const unsigned int &initial_seed, const unsigned int &step = 0);
       void setSteps(const unsigned int &steps);
       void setOutputSubdirectory(const std::string &subdir);
       template<typename T>
       void setProperty(const std::string &name, const T &value);
       template<typename T, EnvironmentManager::size_type N>
       void setProperty(const std::string &name, const std::array<T, N> &value);
       template<typename T>
       void setProperty(const std::string &name, const EnvironmentManager::size_type &index, const T &value);
   #ifdef SWIG
   
       template<typename T>
       void setPropertyArray(const std::string &name, const EnvironmentManager::size_type &length, const std::vector<T> &value);
   #endif
   
       template<typename T>
       void setPropertyUniformDistribution(const std::string &name, const T &min, const T &max);
       template<typename T>
       void setPropertyUniformDistribution(const std::string &name, const EnvironmentManager::size_type &index, const T &min, const T &max);
       void setRandomPropertySeed(const unsigned int &seed);
       template<typename T>
       void setPropertyUniformRandom(const std::string &name, const T &min, const T &max);
       template<typename T>
       void setPropertyUniformRandom(const std::string &name, const EnvironmentManager::size_type &index, const T &min, const T &max);
       template<typename T>
       void setPropertyNormalRandom(const std::string &name, const T &mean, const T &stddev);
       template<typename T>
       void setPropertyNormalRandom(const std::string &name, const EnvironmentManager::size_type &index, const T &mean, const T &stddev);
       template<typename T>
       void setPropertyLogNormalRandom(const std::string &name, const T &mean, const T &stddev);
       template<typename T>
       void setPropertyLogNormalRandom(const std::string &name, const EnvironmentManager::size_type &index, const T &mean, const T &stddev);
       template<typename T, typename rand_dist>
       void setPropertyRandom(const std::string &name, rand_dist &distribution);
       template<typename T, typename rand_dist>
       void setPropertyRandom(const std::string &name, const EnvironmentManager::size_type &index, rand_dist &distribution);
   
   #ifndef SWIG
       using std::vector<RunPlan>::begin;
       using std::vector<RunPlan>::end;
       using std::vector<RunPlan>::size;
       using std::vector<RunPlan>::operator[];
       using std::vector<RunPlan>::insert;
   #else
       // Can't get SWIG %import to use std::vector<RunPlan> so manually implement the required items
       size_t size() const { return std::vector<RunPlan>::size(); }
       RunPlan& operator[] (const size_t _Pos) { return std::vector<RunPlan>::operator[](_Pos); }
   #endif
   
       RunPlanVec operator+(const RunPlan& rhs) const;
       RunPlanVec operator+(const RunPlanVec& rhs) const;
       RunPlanVec& operator+=(const RunPlan& rhs);
       RunPlanVec& operator+=(const RunPlanVec& rhs);
       RunPlanVec& operator*=(const unsigned int& rhs);
       RunPlanVec operator*(const unsigned int& rhs) const;
   
    private:
       RunPlanVec(const std::shared_ptr<const std::unordered_map<std::string, EnvironmentDescription::PropData>> &environment, const bool &allow_0_steps);
       std::mt19937 rand;
       std::shared_ptr<const std::unordered_map<std::string, EnvironmentDescription::PropData>> environment;
       const bool allow_0_steps;
   };
   
   template<typename T>
   void RunPlanVec::setProperty(const std::string &name, const T &value) {
       // Validation
       const auto it = environment->find(name);
       if (it == environment->end()) {
           THROW InvalidEnvProperty("Environment description does not contain property '%s', "
               "in RunPlanVec::setProperty()\n",
               name.c_str());
       }
       if (it->second.data.type != std::type_index(typeid(T))) {
           THROW InvalidEnvPropertyType("Environment property '%s' type mismatch '%s' != '%s', "
               "in RunPlanVec::setProperty()\n",
               name.c_str(), it->second.data.type.name(), std::type_index(typeid(T)).name());
       }
       if (it->second.data.elements == 1) {
           THROW InvalidEnvPropertyType("Environment property '%s' is an array with %u elements, array method should be used, "
               "in RunPlanVec::setProperty()\n",
               name.c_str(), it->second.data.elements);
       }
       for (auto &i : *this) {
           i.setProperty<T>(name, value);
       }
   }
   template<typename T, EnvironmentManager::size_type N>
   void RunPlanVec::setProperty(const std::string &name, const std::array<T, N> &value) {
       // Validation
       const auto it = environment->find(name);
       if (it == environment->end()) {
           THROW InvalidEnvProperty("Environment description does not contain property '%s', "
               "in RunPlanVec::setProperty()\n",
               name.c_str());
       }
       if (it->second.data.type != std::type_index(typeid(T))) {
           THROW InvalidEnvPropertyType("Environment property '%s' type mismatch '%s' != '%s', "
               "in RunPlanVec::setProperty()\n",
               name.c_str(), it->second.data.type.name(), std::type_index(typeid(T)).name());
       }
       if (it->second.data.elements != N) {
           THROW InvalidEnvPropertyType("Environment property array '%s' length mismatch %u != %u "
               "in RunPlan::setProperty()\n",
               name.c_str(), it->second.data.elements, N);
       }
       for (auto &i : *this) {
           i.setProperty<T, N>(name, value);
       }
   }
   template<typename T>
   void RunPlanVec::setProperty(const std::string &name, const EnvironmentManager::size_type &index, const T &value) {
       // Validation
       const auto it = environment->find(name);
       if (it == environment->end()) {
           THROW InvalidEnvProperty("Environment description does not contain property '%s', "
               "in RunPlanVec::setProperty()\n",
               name.c_str());
       }
       if (it->second.data.type != std::type_index(typeid(T))) {
           THROW InvalidEnvPropertyType("Environment property '%s' type mismatch '%s' != '%s', "
               "in RunPlanVec::setProperty()\n",
               name.c_str(), it->second.data.type.name(), std::type_index(typeid(T)).name());
       }
       if (it->second.data.elements >= index) {
           throw std::out_of_range("Environment property array index out of bounds "
               "in RunPlan::setProperty()\n");
       }
       for (auto &i : *this) {
           i.setProperty<T>(name, index, value);
       }
   }
   #ifdef SWIG
   template<typename T>
   void RunPlanVec::setPropertyArray(const std::string &name, const EnvironmentManager::size_type &N, const std::vector<T> &value) {
       // Validation
       const auto it = environment->find(name);
       if (it == environment->end()) {
           THROW InvalidEnvProperty("Environment description does not contain property '%s', "
               "in RunPlanVec::setProperty()\n",
               name.c_str());
       }
       if (it->second.data.type != std::type_index(typeid(T))) {
           THROW InvalidEnvPropertyType("Environment property '%s' type mismatch '%s' != '%s', "
               "in RunPlanVec::setProperty()\n",
               name.c_str(), it->second.data.type.name(), std::type_index(typeid(T)).name());
       }
       if (it->second.data.elements != N) {
           THROW InvalidEnvPropertyType("Environment property array '%s' length mismatch %u != %u "
               "in RunPlanVec::setProperty()\n",
               name.c_str(), it->second.data.elements, N);
       }
       if (value.size() != N) {
           THROW InvalidEnvProperty("Environment property array length does not match the value provided, %u != %llu,"
               "in RunPlanVec::setProperty()\n",
               name.c_str(), value.size(), N);
       }
       for (auto &i : *this) {
           i.setPropertyArray<T>(name, N, value);
       }
   }
   #endif
   
   template<typename T>
   void RunPlanVec::setPropertyUniformDistribution(const std::string &name, const T &min, const T &max) {
       // Validation
       if (this->size() < 2) {
           THROW std::out_of_range("Unable to apply a property distribution a vector with less than 2 elements, "
               "in RunPlanVec::setPropertyUniformDistribution()\n");
       }
       const auto it = environment->find(name);
       if (it == environment->end()) {
           THROW InvalidEnvProperty("Environment description does not contain property '%s', "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str());
       }
       if (it->second.data.type != std::type_index(typeid(T))) {
           THROW InvalidEnvPropertyType("Environment property '%s' type mismatch '%s' != '%s', "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str(), it->second.data.type.name(), std::type_index(typeid(T)).name());
       }
       if (it->second.data.elements != 1) {
           THROW InvalidEnvPropertyType("Environment property '%s' is an array with %u elements, array method should be used, "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str(), it->second.data.elements);
       }
       unsigned int ct = 0;
       for (auto &i : *this) {
           const double a = static_cast<double>(ct++) / (this->size() - 1);
           const T lerp = static_cast<T>(round(min * (1.0 - a) + max * a));
           i.setProperty<T>(name, lerp);
       }
   }
   template<typename T>
   void RunPlanVec::setPropertyUniformDistribution(const std::string &name, const EnvironmentManager::size_type &index, const T &min, const T &max) {
       // Validation
       if (this->size() < 2) {
           THROW std::out_of_range("Unable to apply a property distribution a vector with less than 2 elements, "
               "in RunPlanVec::setPropertyUniformDistribution()\n");
       }
       const auto it = environment->find(name);
       if (it == environment->end()) {
           THROW InvalidEnvProperty("Environment description does not contain property '%s', "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str());
       }
       if (it->second.data.type != std::type_index(typeid(T))) {
           THROW InvalidEnvPropertyType("Environment property '%s' type mismatch '%s' != '%s', "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str(), it->second.data.type.name(), std::type_index(typeid(T)).name());
       }
       if (it->second.data.elements >= index) {
           throw std::out_of_range("Environment property array index out of bounds "
               "in RunPlan::setPropertyUniformDistribution()\n");
       }
       unsigned int ct = 0;
       for (auto &i : *this) {
           const double a = static_cast<double>(ct++) / (this->size() - 1);
           const T lerp = static_cast<T>(round(min * (1.0 - a) + max * a));
           i.setProperty<T>(name, index, lerp);
       }
   }
   
   template<typename T, typename rand_dist>
   void RunPlanVec::setPropertyRandom(const std::string &name, rand_dist &distribution) {
       // Validation
       if (this->size() < 2) {
           THROW std::out_of_range("Unable to apply a property distribution a vector with less than 2 elements, "
               "in RunPlanVec::setPropertyUniformDistribution()\n");
       }
       const auto it = environment->find(name);
       if (it == environment->end()) {
           THROW InvalidEnvProperty("Environment description does not contain property '%s', "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str());
       }
       if (it->second.data.type != std::type_index(typeid(T))) {
           THROW InvalidEnvPropertyType("Environment property '%s' type mismatch '%s' != '%s', "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str(), it->second.data.type.name(), std::type_index(typeid(T)).name());
       }
       if (it->second.data.elements != 1) {
           THROW InvalidEnvPropertyType("Environment property '%s' is an array with %u elements, array method should be used, "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str(), it->second.data.elements);
       }
       for (auto &i : *this) {
           i.setProperty<T>(name, static_cast<T>(distribution(this->rand)));
       }
   }
   template<typename T, typename rand_dist>
   void RunPlanVec::setPropertyRandom(const std::string &name, const EnvironmentManager::size_type &index, rand_dist &distribution) {
       // Validation
       if (this->size() < 2) {
           THROW std::out_of_range("Unable to apply a property distribution a vector with less than 2 elements, "
               "in RunPlanVec::setPropertyUniformDistribution()\n");
       }
       const auto it = environment->find(name);
       if (it == environment->end()) {
           THROW InvalidEnvProperty("Environment description does not contain property '%s', "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str());
       }
       if (it->second.data.type != std::type_index(typeid(T))) {
           THROW InvalidEnvPropertyType("Environment property '%s' type mismatch '%s' != '%s', "
               "in RunPlanVec::setPropertyUniformDistribution()\n",
               name.c_str(), it->second.data.type.name(), std::type_index(typeid(T)).name());
       }
       if (it->second.data.elements >= index) {
           throw std::out_of_range("Environment property array index out of bounds "
               "in RunPlan::setPropertyUniformDistribution()\n");
       }
       for (auto &i : *this) {
           i.setProperty<T>(name, index, static_cast<T>(distribution(this->rand)));
       }
   }
   template<typename T>
   void RunPlanVec::setPropertyUniformRandom(const std::string &name, const T &min, const T &max) {
       static_assert(FGPU_SA::_Is_IntType<T>::value, "Invalid template argument for RunPlanVec::setPropertyUniformRandom(const std::string &name, const T &min, const T&max)");
       std::uniform_int_distribution<T> dist(min, max);
       setPropertyRandom<T>(name, dist);
   }
   template<typename T>
   void RunPlanVec::setPropertyUniformRandom(const std::string &name, const EnvironmentManager::size_type &index, const T &min, const T &max) {
       static_assert(FGPU_SA::_Is_IntType<T>::value, "Invalid template argument for RunPlanVec::setPropertyUniformRandom(const std::string &name, const EnvironmentManager::size_type &index, const T &min, const T&max)");
       std::uniform_int_distribution<T> dist(min, max);
       setPropertyRandom<T>(name, index, dist);
   }
   template<typename T>
   void RunPlanVec::setPropertyNormalRandom(const std::string &name, const T &mean, const T &stddev) {
       static_assert(FGPU_SA::_Is_RealType<T>::value, "Invalid template argument for RunPlanVec::setPropertyNormalRandom(const std::string &name, const T &mean, const T &stddev)");
       std::normal_distribution<T> dist(mean, stddev);
       setPropertyRandom<T>(name, dist);
   }
   template<typename T>
   void RunPlanVec::setPropertyNormalRandom(const std::string &name, const EnvironmentManager::size_type &index, const T &mean, const T &stddev) {
       static_assert(FGPU_SA::_Is_RealType<T>::value, "Invalid template argument for RunPlanVec::setPropertyNormalRandom(const std::string &name, const EnvironmentManager::size_type &index, const T &mean, const T &stddev)");
       std::normal_distribution<T> dist(mean, stddev);
       setPropertyRandom<T>(name, index, dist);
   }
   template<typename T>
   void RunPlanVec::setPropertyLogNormalRandom(const std::string &name, const T &mean, const T &stddev) {
       static_assert(FGPU_SA::_Is_RealType<T>::value, "Invalid template argument for RunPlanVec::setPropertyLogNormalRandom(const std::string &name, const T &mean, const T &stddev)");
       std::lognormal_distribution<T> dist(mean, stddev);
       setPropertyRandom<T>(name, dist);
   }
   template<typename T>
   void RunPlanVec::setPropertyLogNormalRandom(const std::string &name, const EnvironmentManager::size_type &index, const T &mean, const T &stddev) {
       static_assert(FGPU_SA::_Is_RealType<T>::value, "Invalid template argument for RunPlanVec::setPropertyLogNormalRandom(const std::string &name, const EnvironmentManager::size_type &index, const T &mean, const T &stddev)");
       std::lognormal_distribution<T> dist(mean, stddev);
       setPropertyRandom<T>(name, index, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const float &min, const float &max) {
       std::uniform_real_distribution<float> dist(min, max);
       setPropertyRandom<float>(name, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const EnvironmentManager::size_type &index, const float &min, const float &max) {
       std::uniform_real_distribution<float> dist(min, max);
       setPropertyRandom<float>(name, index, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const double &min, const double &max) {
       std::uniform_real_distribution<double> dist(min, max);
       setPropertyRandom<double>(name, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const EnvironmentManager::size_type &index, const double &min, const double &max) {
       std::uniform_real_distribution<double> dist(min, max);
       setPropertyRandom<double>(name, index, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const char &min, const char &max) {
       std::uniform_int_distribution<int16_t> dist(min, max);
       setPropertyRandom<char>(name, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const EnvironmentManager::size_type &index, const char &min, const char &max) {
       std::uniform_int_distribution<int16_t> dist(min, max);
       setPropertyRandom<char>(name, index, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const unsigned char &min, const unsigned char &max) {
       std::uniform_int_distribution<uint16_t> dist(min, max);
       setPropertyRandom<unsigned char>(name, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const EnvironmentManager::size_type &index, const unsigned char &min, const unsigned char &max) {
       std::uniform_int_distribution<uint16_t> dist(min, max);
       setPropertyRandom<unsigned char>(name, index, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const signed char &min, const signed char &max) {
       std::uniform_int_distribution<int16_t> dist(min, max);
       setPropertyRandom<signed char>(name, dist);
   }
   template<>
   inline void RunPlanVec::setPropertyUniformRandom(const std::string &name, const EnvironmentManager::size_type &index, const signed char &min, const signed char &max) {
       std::uniform_int_distribution<int16_t> dist(min, max);
       setPropertyRandom<signed char>(name, index, dist);
   }
   #endif  // INCLUDE_FLAMEGPU_SIM_RUNPLANVEC_H_
