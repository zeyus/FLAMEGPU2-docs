
.. _program_listing_file_include_flamegpu_pop_AgentVector.h:

Program Listing for File AgentVector.h
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_flamegpu_pop_AgentVector.h>` (``include/flamegpu/pop/AgentVector.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef INCLUDE_FLAMEGPU_POP_AGENTVECTOR_H_
   #define INCLUDE_FLAMEGPU_POP_AGENTVECTOR_H_
   
   #include <string>
   #include <utility>
   #include <memory>
   #include <map>
   
   #include "flamegpu/pop/MemoryVector.h"
   #include "flamegpu/model/AgentData.h"
   
   class AgentInstance;
   class AgentDescription;
   class AgentVector_CAgent;
   class AgentVector_Agent;
   
   class AgentVector {
       static const float RESIZE_FACTOR;
       friend class CUDAAgentStateList;
   
    public:
       typedef unsigned int size_type;
       typedef AgentVector_Agent Agent;
       typedef AgentVector_CAgent CAgent;
       typedef std::map<std::string, std::unique_ptr<GenericMemoryVector>> AgentDataMap;
   
       // member typedefs provided through inheriting from std::iterator
       // They might all be wrong
       class const_iterator;
       class const_reverse_iterator;
       class iterator : public std::iterator<
           std::input_iterator_tag,  // iterator_category
           Agent,                    // value_type
           size_type,                // difference_type
           const Agent*,             // pointer
           Agent                     // reference
       > {
           friend class AgentVector;
           const std::shared_ptr<const AgentData>& _agent;
           const std::weak_ptr<AgentDataMap> _data;
           size_type _pos;
        public:
           operator AgentVector::const_iterator() const {
               return const_iterator(_agent, _data, _pos);
           }
           iterator(const std::shared_ptr<const AgentData>& agent, std::weak_ptr<AgentDataMap> data, size_type pos = 0)
               : _agent(agent), _data(std::move(data)), _pos(pos) { }
           iterator& operator++() { ++_pos; return *this; }
           iterator operator++(int) { iterator retval = *this; ++(*this); return retval; }
           bool operator==(iterator other) const { return _pos == other._pos &&
               (_data.lock() == other._data.lock() || (_data.lock() && other._data.lock() && *_data.lock() == *other._data.lock()));
           }
           bool operator!=(iterator other) const { return !(*this == other); }
           Agent operator*() const;
       };
       class const_iterator : public std::iterator<
           std::input_iterator_tag,  // iterator_category
           CAgent,                   // value_type
           size_type,                // difference_type
           const CAgent*,            // pointer
           CAgent                    // reference
       > {
           friend class AgentVector;
           const std::shared_ptr<const AgentData> &_agent;
           const std::weak_ptr<AgentDataMap> _data;
           size_type _pos;
        public:
           const_iterator(const std::shared_ptr<const AgentData>& agent, std::weak_ptr<AgentDataMap> data, size_type pos = 0)
               : _agent(agent), _data(std::move(data)), _pos(pos) { }
           const_iterator& operator++() { ++_pos; return *this; }
           const_iterator operator++(int) { const_iterator retval = *this; ++(*this); return retval; }
           bool operator==(const_iterator other) const { return _pos == other._pos &&
               (_data.lock() == other._data.lock() || (_data.lock() && other._data.lock() && *_data.lock() == *other._data.lock()));
           }
           bool operator!=(const_iterator other) const { return !(*this == other); }
           CAgent operator*() const;
       };
       class reverse_iterator : public std::iterator<
           std::input_iterator_tag,  // iterator_category
           Agent,                    // value_type
           size_type,                // difference_type
           const Agent*,             // pointer
           Agent                     // reference
       > {
           friend class AgentVector;
           const std::shared_ptr<const AgentData> &_agent;
           const std::weak_ptr<AgentDataMap> _data;
           size_type _pos;
        public:
           operator AgentVector::const_reverse_iterator() const {
               return const_reverse_iterator(_agent, _data, _pos);
           }
           explicit reverse_iterator(const std::shared_ptr<const AgentData>& agent, std::weak_ptr<AgentDataMap> data, size_type pos = 0)
               : _agent(agent), _data(std::move(data)), _pos(pos) { }
           reverse_iterator& operator++() { --_pos; return *this; }
           reverse_iterator operator++(int) { reverse_iterator retval = *this; ++(*this); return retval; }
           bool operator==(reverse_iterator other) const { return _pos == other._pos &&
               (_data.lock() == other._data.lock() || (_data.lock() && other._data.lock() && *_data.lock() == *other._data.lock()));
           }
           bool operator!=(reverse_iterator other) const { return !(*this == other); }
           Agent operator*() const;
       };
       class const_reverse_iterator : public std::iterator<
           std::input_iterator_tag,  // iterator_category
           CAgent,                   // value_type
           size_type,                // difference_type
           const CAgent*,            // pointer
           CAgent                    // reference
       > {
           friend class AgentVector;
           const std::shared_ptr<const AgentData>& _agent;
           const std::weak_ptr<AgentDataMap> _data;
           size_type _pos;
        public:
           explicit const_reverse_iterator(const std::shared_ptr<const AgentData>& agent, std::weak_ptr<AgentDataMap> data, size_type pos = 0)
               : _agent(agent), _data(std::move(data)), _pos(pos) { }
           const_reverse_iterator& operator++() { --_pos; return *this; }
           const_reverse_iterator operator++(int) { const_reverse_iterator retval = *this; ++(*this); return retval; }
           bool operator==(const_reverse_iterator other) const { return _pos == other._pos &&
               (_data.lock() == other._data.lock() || (_data.lock() && other._data.lock() && *_data.lock() == *other._data.lock()));
           }
           bool operator!=(const_reverse_iterator other) const { return !(*this == other); }
           CAgent operator*() const;
       };
       explicit AgentVector(const AgentDescription &agent_desc, size_type count = 0);
       AgentVector(const AgentVector &other);
       AgentVector(AgentVector &&other) noexcept;
       AgentVector& operator=(const AgentVector &other);
       AgentVector& operator=(AgentVector &&other) noexcept;
   
       // Element access
       Agent at(size_type pos);
       CAgent at(size_type pos) const;
       Agent operator[](size_type pos);
       CAgent operator[](size_type pos) const;
       Agent front();
       CAgent front() const;
       Agent back();
       CAgent back() const;
       template<typename T>
       T *data(const std::string &variable_name);
       template<typename T>
       const T* data(const std::string &variable_name) const;
       void* data(const std::string& variable_name);
       const void* data(const std::string& variable_name) const;
   
       // Iterators
       iterator begin() noexcept;
       const_iterator begin() const noexcept;
       const_iterator cbegin() const noexcept;
       iterator end() noexcept;
       const_iterator end() const noexcept;
       const_iterator cend() const noexcept;
       reverse_iterator rbegin() noexcept;
       const_reverse_iterator rbegin() const noexcept;
       const_reverse_iterator crbegin() const noexcept;
       reverse_iterator rend() noexcept;
       const_reverse_iterator rend() const noexcept;
       const_reverse_iterator crend() const noexcept;
   
       // Capacity
       bool empty() const;
       size_type size() const;
       static size_type max_size();
       void reserve(size_type new_cap);
       size_type capacity() const;
       void shrink_to_fit();
   
       // Modifiers
       void clear();
   
       iterator insert(const_iterator pos, const AgentInstance& value);
       iterator insert(size_type pos, const AgentInstance& value);
       iterator insert(const_iterator pos, const Agent& value);
       iterator insert(size_type pos, const Agent& value);
   #ifdef SWIG
       void py_insert(size_type pos, const AgentInstance& value);
       void py_insert(size_type pos, const Agent& value);
   #endif
   
       iterator insert(const_iterator pos, size_type count, const AgentInstance& value);
       iterator insert(size_type pos, size_type count, const AgentInstance& value);
       iterator insert(const_iterator pos, size_type count, const Agent& value);
       iterator insert(size_type pos, size_type count, const Agent& value);
   #ifdef SWIG
       void py_insert(size_type pos, size_type count, const AgentInstance& value);
       void py_insert(size_type pos, size_type count, const Agent& value);
   #endif
   
       template<class InputIt>
       iterator insert(const_iterator pos, InputIt first, InputIt last);
       template<class InputIt>
       iterator insert(size_type pos, InputIt first, InputIt last);
       iterator erase(const_iterator pos);
       iterator erase(size_type pos);
   #ifdef SWIG
       void py_erase(size_type pos);
   #endif
   
       iterator erase(const_iterator first, const_iterator last);
       iterator erase(size_type first, size_type last);
   #ifdef SWIG
       void py_erase(size_type first, size_type last);
   #endif
   
       void push_back(const AgentInstance& value);
       void push_back();
       void pop_back();
       void resize(size_type count);
       void swap(AgentVector& other) noexcept;
       bool operator==(const AgentVector &other) const;
       bool operator!=(const AgentVector &other) const;
   
       // Util
       std::string getAgentName() const { return agent->name; }
       bool matchesAgentType(const AgentData &other) const;
       bool matchesAgentType(const AgentDescription& other) const;
       std::type_index getVariableType(const std::string& variable_name) const;
       const VariableMap &getVariableMetaData() const;
       std::string getInitialState() const;
   
    private:
       void resize(size_type count, bool init);
       std::shared_ptr<const AgentData> agent;
       size_type _size;
       size_type _capacity;
       std::shared_ptr<AgentDataMap> _data;
   };
   
   #include "flamegpu/pop/AgentVector_Agent.h"
   
   template<typename T>
   T* AgentVector::data(const std::string& variable_name) {
       // Is variable name found
       const auto &var = agent->variables.find(variable_name);
       if (var == agent->variables.end()) {
           THROW InvalidAgentVar("Variable with name '%s' was not found in agent '%s', "
               "in AgentVector::data().",
               variable_name.c_str(), agent->name.c_str());
       }
       if (std::type_index(typeid(T)) != var->second.type) {
           THROW InvalidVarType("Variable '%s' is of a different type. "
               "'%s' was expected, but '%s' was requested,"
               "in AgentVector::data().",
               variable_name.c_str(), var->second.type.name(), typeid(T).name());
       }
       // Does the map have a vector
       const auto& map_it = _data->find(variable_name);
       if (map_it != _data->end())
           return static_cast<T*>(map_it->second->getDataPtr());
       return nullptr;
   }
   template<typename T>
   const T* AgentVector::data(const std::string& variable_name) const {
       // Is variable name found
       const auto& var = agent->variables.find(variable_name);
       if (var == agent->variables.end()) {
           THROW InvalidAgentVar("Variable with name '%s' was not found in agent '%s', "
               "in AgentVector::data().",
               variable_name.c_str(), agent->name.c_str());
       }
       if (std::type_index(typeid(T)) != var->second.type) {
           THROW InvalidVarType("Variable '%s' is of a different type. "
               "'%s' was expected, but '%s' was requested,"
               "in AgentVector::data().",
               variable_name.c_str(), var->second.type.name(), typeid(T).name());
       }
       // Does the map have a vector
       const auto& map_it = _data->find(variable_name);
       if (map_it != _data->end())
           return static_cast<T*>(map_it->second->getDataPtr());
       return nullptr;
   }
   
   template<class InputIt>
   AgentVector::iterator AgentVector::insert(const_iterator pos, InputIt first, InputIt last) {
       if (pos._agent != agent && *pos._agent != *agent) {
           THROW InvalidAgent("Agent description mismatch, '%' provided to pos, '%' required, "
               "in AgentVector::push_back().\n",
               last._agent->name.c_str(), agent->name.c_str());
       }
       return insert(pos._pos, first, last);
   }
   
   template<class InputIt>
   AgentVector::iterator AgentVector::insert(size_type pos, InputIt first, InputIt last) {
       // Insert elements inrange first-last before pos
       if (first == last)
           return iterator(agent, _data, pos);
       // Confirm they are for the same agent type
       if (first._agent != agent && *first._agent != *agent) {
           THROW InvalidAgent("Agent description mismatch, '%' provided to first, '%' required, "
               "in AgentVector::push_back().\n",
               first._agent->name.c_str(), agent->name.c_str());
       }
       if (last._agent != agent && *last._agent != *agent) {
           THROW InvalidAgent("Agent description mismatch, '%' provided to last, '%' required, "
               "in AgentVector::push_back().\n",
               last._agent->name.c_str(), agent->name.c_str());
       }
       // Expand capacity if required
       const size_type first_copy_index = first._pos < last._pos ? first._pos : last._pos;
       const size_type end_copy_index = first._pos < last._pos ? last._pos : first._pos;
       const size_type copy_count = end_copy_index - first_copy_index;
       {
           size_type new_capacity = _capacity;
           assert((_capacity * RESIZE_FACTOR) + 1 > _capacity);
           while (_size + copy_count > new_capacity) {
               new_capacity = static_cast<size_type>(new_capacity * RESIZE_FACTOR) + 1;
           }
           resize(new_capacity, true);
       }
       // Get first index;
       const size_type insert_index = pos;
       // Fix each variable
       auto first_data = first._data.lock();
       if (!first_data) {
           THROW ExpiredWeakPtr("The AgentVector which owns the passed iterators has been deallocated, "
               "in AgentVector::insert().\n");
       }
       for (const auto& v : agent->variables) {
           const auto it = _data->find(v.first);
           char* t_data = static_cast<char*>(it->second->getDataPtr());
           const size_t variable_size = v.second.type_size * v.second.elements;
           // Move all items after this index backwards count places
           for (unsigned int i = _size - 1; i >= insert_index; --i) {
               // Copy items individually, incase the src and destination overlap
               memcpy(t_data + (i + copy_count) * variable_size, t_data + i * variable_size, variable_size);
           }
           // Copy across item data
           const auto other_it = first_data->find(v.first);
           const char* o_data = static_cast<const char*>(other_it->second->getReadOnlyDataPtr());
           memcpy(t_data + insert_index * variable_size, o_data + first_copy_index * variable_size, copy_count * variable_size);
       }
       // Increase size
       _size += copy_count;
       // Return iterator to first inserted item
       return iterator(agent, _data, insert_index);
   }
   
   #ifdef SWIG
   void AgentVector::py_insert(size_type pos, const AgentInstance& value) {
       insert(pos, value);
   }
   void AgentVector::py_insert(size_type pos, const Agent& value) {
       insert(pos, value);
   }
   void AgentVector::py_insert(size_type pos, size_type count, const AgentInstance& value) {
       insert(pos, count, value);
   }
   void AgentVector::py_insert(size_type pos, size_type count, const Agent& value) {
       insert(pos, count, value);
   }
   void AgentVector::py_erase(size_type pos) {
       erase(pos);
   }
   void AgentVector::py_erase(size_type first, size_type last) {
       erase(first, last);
   }
   #endif
   #endif  // INCLUDE_FLAMEGPU_POP_AGENTVECTOR_H_
